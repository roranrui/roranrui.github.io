<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>若然无亦的Blog</title>
  
  <subtitle>长日终有时, 长梦终有逝</subtitle>
  <link href="https://roranrui.cn/atom.xml" rel="self"/>
  
  <link href="https://roranrui.cn/"/>
  <updated>2022-05-08T07:17:47.637Z</updated>
  <id>https://roranrui.cn/</id>
  
  <author>
    <name>若然无亦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++-std::move总结</title>
    <link href="https://roranrui.cn/posts/62884e14/"/>
    <id>https://roranrui.cn/posts/62884e14/</id>
    <published>2022-05-08T07:06:43.000Z</published>
    <updated>2022-05-08T07:17:47.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-std-move总结"><a href="#C-std-move总结" class="headerlink" title="C++-std::move总结"></a>C++-std::move总结</h1><h2 id="一-移动语义"><a href="#一-移动语义" class="headerlink" title="一. 移动语义"></a>一. 移动语义</h2><p>移动语义可以使得编译器使用不那么昂贵的移动操作，来替换昂过的复制操作。同拷贝构造函数、拷贝赋值运算符赋予人们复制意义的能力一样，移动构造函数、移动赋值运算符也赋予人们移动语义的能力。更通俗的说：移动语义是通过移动构造函数或者移动赋值运算符实现的</p><p>举个例子，对于C++标准库提供的<code>std::shared_ptr&lt;&gt;</code>智能指针，当对其进行复制操作时，需要增加其引用计数，而引用计数是个原子类型，因此增加引用计数是个耗时操作；而当对其进行移动操作的时候，则引用计数会保持不变，也即无需进行引用计数的操作。</p><h2 id="二-左值引用和右值引用"><a href="#二-左值引用和右值引用" class="headerlink" title="二. 左值引用和右值引用"></a>二. 左值引用和右值引用</h2><p>已知左值引用的形式为 <code>T&amp; t</code></p><p>右值引用是在左值引用的基础上多加一个<code>&amp;</code>，形式变为 <code>T&amp;&amp; t</code></p><p>这种通过 <code>&amp;</code> 的个数区分左值引用和右值引用的方法，在大多数的普通函数中没有问题，但是放到模板参数或者 <code>auto</code> 关键字之后的位置就不太灵了，因为这些地方会推导实际的类型，正是有了参数推导，才使得模板中出现了“万能引用”的说法，也就是下面这样：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token number">2020</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  函数 <code>func</code> 即能接受变量 <code>year</code> 这样的左值作为参数，也能接受 <code>2020</code> 这样的常数作为右值，简直太完美。那么这里是怎样推导的呢？这就要请出一个引用的“折叠”规则了，描述如下：</p><p>  A&amp; &amp; 折叠成 A&amp;<br>  A&amp; &amp;&amp; 折叠成 A&amp;<br>  A&amp;&amp; &amp; 折叠成 A&amp;<br>  A&amp;&amp; &amp;&amp; 折叠成 A&amp;&amp;</p></blockquote><h2 id="三-std-move使用与作用"><a href="#三-std-move使用与作用" class="headerlink" title="三. std::move使用与作用"></a>三. std::move使用与作用</h2><p>把左值转化成右值的转化函数， <code>std::move</code> 函数的实现</p><pre class="line-numbers language-cpp"><code class="language-cpp">  <span class="token comment" spellcheck="true">/**   *  @brief  Convert a value to an rvalue.   *  @param  __t  A thing of arbitrary type.   *  @return The parameter cast to an rvalue-reference to allow moving it.  */</span>  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> _Tp<span class="token operator">></span>    <span class="token keyword">constexpr</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span>    <span class="token function">move</span><span class="token punctuation">(</span>_Tp<span class="token operator">&amp;&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>    <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token operator">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">></span><span class="token operator">::</span>type<span class="token operator">&amp;&amp;</span><span class="token operator">></span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>std::move 的内部只做了一个强制类型转换，除此之外啥也没干，其实就是对传入的参数重新解释了一下，并没有实质性的动作。</p><p><strong>作用</strong>:</p><p>那么为什么要使用 std::move 这个名字呢？这个名字更多的是起到提醒的作用，告诉使用者这里可能进行了到右值的转化，相关的对象后续可能发生移动，“被掏空”了，如果你继续使用这个对象，行为是未定义的，后果自负。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-std-move总结&quot;&gt;&lt;a href=&quot;#C-std-move总结&quot; class=&quot;headerlink&quot; title=&quot;C++-std::move总结&quot;&gt;&lt;/a&gt;C++-std::move总结&lt;/h1&gt;&lt;h2 id=&quot;一-移动语义&quot;&gt;&lt;a href=&quot;#一</summary>
      
    
    
    
    <category term="C++学习" scheme="https://roranrui.cn/categories/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++-Lambda表达式</title>
    <link href="https://roranrui.cn/posts/7d872b64/"/>
    <id>https://roranrui.cn/posts/7d872b64/</id>
    <published>2022-05-08T05:51:44.000Z</published>
    <updated>2022-05-08T06:45:36.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-Lambda表达式"><a href="#C-Lambda表达式" class="headerlink" title="C++ Lambda表达式"></a>C++ Lambda表达式</h1><blockquote><p>   Lambda表达式是现代C++在C ++ 11和更高版本中的一个新的语法糖 ，在C++11、C++14、C++17和C++20中Lambda表达的内容还在不断更新。 lambda表达式（也称为lambda函数）是在调用或作为函数参数传递的位置处定义匿名函数对象的便捷方法。通常，lambda用于封装传递给算法或异步方法的几行代码 。本文主要介绍Lambda的工作原理以及使用方法。</p></blockquote><h2 id="一-Lambda表达式定义"><a href="#一-Lambda表达式定义" class="headerlink" title="一. Lambda表达式定义"></a>一. Lambda表达式定义</h2><p> ISO C ++标准官网展示了一个简单的lambda 表示式实例:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token keyword">void</span> <span class="token function">abssort</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span> x<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span><span class="token function">sort</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> x <span class="token operator">+</span> n<span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// Lambda expression begins</span>        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">float</span> a<span class="token punctuation">,</span> <span class="token keyword">float</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">abs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;</span> std<span class="token operator">::</span><span class="token function">abs</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// end of lambda expression</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第三个参数传递的是排序规则, 直接将排序函数的实现写在应该传递函数的位置，省去了定义排序函数的过程，对于这种不需要复用，且短小的函数，直接传递函数体可以增加代码的可读性。</p><h3 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/f86a9e30f7474aff10be27e4b51c6f64.png"></p><ol><li><strong>捕获列表</strong>。在C ++规范中也称为Lambda导入器， 捕获列表总是出现在Lambda函数的开始处。实际上，[]是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数，捕获列表能够捕捉上下文中的变量以供Lambda函数使用。</li><li>参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略。</li><li><strong>可变规格</strong><em>。mutable修饰符， 默认情况下Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</em></li><li><strong>异常说明</strong>。用于Lamdba表达式内部函数抛出异常。</li><li><strong>返回类型</strong>。 追踪返回类型形式声明函数的返回类型。我们可以在不需要返回值的时候也可以连同符号”-&gt;”一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。</li><li><strong>lambda函数体</strong>。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</li></ol><h4 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h4><ul><li>[]表示不捕获任何变量</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>[var]表示值传递方式捕获变量var</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>[=]表示值传递方式捕获所有父作用域的变量（包括this）</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">{</span>            std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"index: "</span><span class="token operator">&lt;&lt;</span> index <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>                 <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span><span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>[&amp;var]表示引用传递捕捉变量var</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>num<span class="token punctuation">]</span><span class="token punctuation">{</span>        num <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">{</span>        num <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"index: "</span><span class="token operator">&lt;&lt;</span> index <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span>             <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span><span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>[this]表示值传递方式捕捉当前的this指针</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">class</span> <span class="token class-name">Lambda</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">lambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">{</span>             <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Lambda demo<span class="token punctuation">;</span>    demo<span class="token punctuation">.</span><span class="token function">lambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了单独使用外, 也可一起组合使用, 如:</p><ul><li><p>[=,&amp;a,&amp;b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量。</p></li><li><p>[&amp;,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量。</p></li></ul><blockquote><p>  不过值得注意的是，捕捉列表不允许变量重复传递。下面一些例子就是典型的重复，会导致编译时期的错误。例如：</p><ul><li>[=,a]这里已经以值传递方式捕捉了所有变量，但是重复捕捉a了，会报错的;</li><li>[&amp;,&amp;this]这里&amp;已经以引用传递方式捕捉了所有变量，再捕捉this也是一种重复。</li></ul></blockquote><h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><blockquote><p>  除了捕获列表之外，lambda还可以接受输入参数。参数列表是可选的，并且在大多数方面类似于函数的参数列表。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> second<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> first <span class="token operator">+</span> second<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">function</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="异常说明"><a href="#异常说明" class="headerlink" title="异常说明"></a>异常说明</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// C4297 expected </span><span class="token punctuation">{</span>      <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h4><p>同函数, 若无return语句, 则编译器返回推导类型为void</p><h4 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h4><p>Lambda表达式的lambda主体（标准语法中的<em>复合语句</em>）可以包含普通方法或函数的主体可以包含的任何内容。</p><h2 id="二-Lambda工作原理"><a href="#二-Lambda工作原理" class="headerlink" title="二. Lambda工作原理"></a>二. Lambda工作原理</h2><blockquote><p>  编译器会把一个lambda表达式生成一个匿名类的匿名对象，并在类中重载函数调用运算符,实现了一个operator()方法。</p><p>  <strong>仿函数与Lamdba表达式的作用是一致的</strong></p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> print <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等价于</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">print_class</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用构造的类创建对象，print此时就是一个函数对象</span><span class="token keyword">auto</span> print <span class="token operator">=</span> <span class="token function">print_class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三-一些简单案例"><a href="#三-一些简单案例" class="headerlink" title="三. 一些简单案例"></a>三. 一些简单案例</h3><p><strong>遍历算法</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">myPrint</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">myPrint2</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// 顺序插入数据</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/// 逆序输出数据</span>    <span class="token comment" spellcheck="true">/// 第一种</span><span class="token comment" spellcheck="true">//    for (auto it = v.size() - 1; it > 0; it++)</span><span class="token comment" spellcheck="true">//    {</span><span class="token comment" spellcheck="true">//        cout &lt;&lt; it &lt;&lt; endl;</span><span class="token comment" spellcheck="true">//    }</span>    <span class="token comment" spellcheck="true">/// 第二种</span><span class="token comment" spellcheck="true">//    for_each(v.begin(), v.end(), myPrint);</span>    <span class="token comment" spellcheck="true">/// 第三种</span><span class="token comment" spellcheck="true">//    for_each(v.begin(), v.end(), myPrint2());</span>    <span class="token comment" spellcheck="true">///第四种</span><span class="token comment" spellcheck="true">//    for_each(v.begin(), v.end(), [](int x){cout &lt;&lt; x &lt;&lt; endl;});</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>线程创建</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// vector 容器存储线程</span>    vector<span class="token operator">&lt;</span>thread<span class="token operator">></span> workers<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        workers<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread function\n"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main thread\n"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 通过 for_each 循环每一个线程</span>    <span class="token comment" spellcheck="true">// 第三个参数赋值一个task任务</span>    <span class="token comment" spellcheck="true">// 符号'[]'会告诉编译器我们正在用一个匿名函数</span>    <span class="token comment" spellcheck="true">// lambda函数将它的参数作为线程的引用t</span>    <span class="token comment" spellcheck="true">// 然后一个一个的join</span>    <span class="token function">for_each</span><span class="token punctuation">(</span>workers<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> workers<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>thread <span class="token operator">&amp;</span>t<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-Lambda表达式&quot;&gt;&lt;a href=&quot;#C-Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;C++ Lambda表达式&quot;&gt;&lt;/a&gt;C++ Lambda表达式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;   Lambda表达式是现代C+</summary>
      
    
    
    
    <category term="C++学习" scheme="https://roranrui.cn/categories/C-%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>第十五天_搜索与回溯算法(中等)</title>
    <link href="https://roranrui.cn/posts/7ad381b5/"/>
    <id>https://roranrui.cn/posts/7ad381b5/</id>
    <published>2022-05-08T03:59:01.000Z</published>
    <updated>2022-05-08T05:17:44.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十五天-搜索与回溯算法-中等"><a href="#第十五天-搜索与回溯算法-中等" class="headerlink" title="第十五天_搜索与回溯算法(中等)"></a>第十五天_搜索与回溯算法(中等)</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树（BST，Binary Search Tree），也称<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91&amp;spm=1001.2101.3001.7020">二叉排序树</a>或二叉查找树。</p><blockquote><p>  二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质： </p><ol><li>非空<strong>左子树</strong>的所有键值<strong>小于</strong>其根结点的键值。</li><li>非空<strong>右子树</strong>的所有键值<strong>大于</strong>其根结点的键值。</li><li>左、右子树都是二叉搜索树。</li></ol></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/20200904165827405.png"></p><p>上图值为10的结点的右子树为7，比10小，不满足条件2，所以这棵树不是二叉搜索树。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/20200904165842348.png"></p><p>上图各个结点都满足条件，所以这棵树是二叉搜索树。</p><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-二叉树中和为某一值的路径"><a href="#1-二叉树中和为某一值的路径" class="headerlink" title="1. 二叉树中和为某一值的路径"></a>1. 二叉树中和为某一值的路径</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220508120213318.png"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220508120222440.png"></p><p><strong>解题思路:</strong></p><p>本题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 <strong>先序遍历 + 路径记录</strong> 两部分。</p><p><strong>先序遍历</strong>： 按照 “根、左、右” 的顺序，遍历树的所有节点。<br><strong>路径记录</strong>： 在先序遍历中，记录从根节点到当前节点的路径。当路径满足 ① 根节点到叶节点形成的路径 且 ② 各节点值的和等于目标值 sum 时，将此路径加入结果列表。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220508120806381.png" alt="image-20220508120806381"></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">pathSum</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">recur</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        path<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 减法匹配</span>        target <span class="token operator">-</span><span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 遍历到底, 添加路径</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>        path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220508121836942.png"></p><h3 id="2-二叉搜索树与双向链表"><a href="#2-二叉搜索树与双向链表" class="headerlink" title="2. 二叉搜索树与双向链表"></a>2. 二叉搜索树与双向链表</h3><p><img src="C:/Users/13993/AppData/Roaming/Typora/typora-user-images/image-20220508122807095.png"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220508122856579.png"></p><p>解题思路：<br>本文解法基于性质：二叉搜索树的<a href="https://roranrui.cn/posts/1c3cffbc/"><strong>中序遍历</strong></a>为 递增序列 。<br>将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</p><ol><li><strong>排序链表</strong>： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点。</li><li><strong>双向链表</strong>： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 。</li><li><strong>循环链表</strong>： 设链表头节点 head 和尾节点 tail ，则应构建 head.left = tail 和 tail.right = head 。</li></ol><p><strong>中序遍历</strong> 为对二叉树作 “左、根、右” 顺序遍历，递归实现如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 打印中序遍历</span><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 左</span>    cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 根</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 右</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/1599401091-PKIjds-Picture1.png"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220508123649382.png"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220508124012133.png"></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*// Definition for a Node.class Node {public:    int val;    Node* left;    Node* right;    Node() {}    Node(int _val) {        val = _val;        left = NULL;        right = NULL;    }    Node(int _val, Node* _left, Node* _right) {        val = _val;        left = _left;        right = _right;    }};*/</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    Node<span class="token operator">*</span> <span class="token function">treeToDoublyList</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 形成双向链表</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 形成循环链表</span>        head<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> pre<span class="token punctuation">;</span>        pre<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    Node <span class="token operator">*</span>pre<span class="token punctuation">,</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// 递归中序遍历 </span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>Node <span class="token operator">*</span>cur<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> pre<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token keyword">else</span> head <span class="token operator">=</span> cur<span class="token punctuation">;</span>        cur<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> pre<span class="token punctuation">;</span>        pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220508130427936.png"></p><h3 id="3-二叉搜索树的第-k-大节点"><a href="#3-二叉搜索树的第-k-大节点" class="headerlink" title="3. 二叉搜索树的第 k 大节点"></a>3. 二叉搜索树的第 k 大节点</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220508130515215.png"></p><p><strong>解题思路：</strong><br>本文解法基于性质：二叉搜索树的中序遍历为递增序列。根据此性质，易得二叉搜索树的 <strong>中序遍历倒序</strong> 为 递减序列 。<br>因此，求 “二叉搜索树第 k 大的节点” 可转化为求 “此树的<strong>中序遍历倒序</strong>的第 k 个节点”。</p><p><strong>中序遍历倒序</strong>:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为求第 k 个节点，需要实现以下三项工作：</p><ul><li>递归遍历时计数，统计当前节点的序号；</li><li>递归到第 k 个节点时，应记录结果 res；</li><li>记录结果后，后续的遍历即失去意义，应提前终止（即返回）；</li></ul><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-</span><span class="token operator">></span>k <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> res<span class="token punctuation">,</span> k<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// 中序遍历得到倒序序列</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> res <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220508131717851.png"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十五天-搜索与回溯算法-中等&quot;&gt;&lt;a href=&quot;#第十五天-搜索与回溯算法-中等&quot; class=&quot;headerlink&quot; title=&quot;第十五天_搜索与回溯算法(中等)&quot;&gt;&lt;/a&gt;第十五天_搜索与回溯算法(中等)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下配置OpenCV</title>
    <link href="https://roranrui.cn/posts/9223e133/"/>
    <id>https://roranrui.cn/posts/9223e133/</id>
    <published>2022-05-07T13:34:56.000Z</published>
    <updated>2022-05-07T15:07:04.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu下配置OpenCV的环境"><a href="#Ubuntu下配置OpenCV的环境" class="headerlink" title="Ubuntu下配置OpenCV的环境"></a>Ubuntu下配置OpenCV的环境</h1><blockquote><p>  个人先看看这篇文章: <a href="https://roranrui.cn/posts/f18a3b77/">OpenCV在CLion下的环境配置 | 若然无亦的Blog (roranrui.cn)</a></p></blockquote><h2 id="一-前置准备"><a href="#一-前置准备" class="headerlink" title="一. 前置准备"></a>一. 前置准备</h2><ul><li><p>下载OpenCV源码: <a href="https://opencv.org/releases/">https://opencv.org/releases/</a></p></li><li><p>下载OpenCV_Contrib拓展库: <a href="https://github.com/opencv/opencv_contrib">https://github.com/opencv/opencv_contrib</a></p><ul><li><blockquote><p>如果官网下载失败, 可以尝试从这里下载:</p><p><a href="https://pan.baidu.com/s/1OOPVQVbZEPuBqU0NHCDQaA">https://pan.baidu.com/s/1OOPVQVbZEPuBqU0NHCDQaA</a></p><p>提取码: rrwy</p></blockquote></li></ul></li><li><p>下载QT:  <a href="https://www.qt.io/download">https://www.qt.io/download</a></p></li><li><p>安装cmake, gcc, g++:</p></li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> cmake<span class="token function">sudo</span> apt <span class="token function">install</span> gcc<span class="token function">sudo</span> apt <span class="token function">install</span> g++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>安装依赖环境:</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span>  build-essential <span class="token function">sudo</span> apt <span class="token function">install</span> cmake <span class="token function">git</span> libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev   <span class="token function">sudo</span> apt <span class="token function">install</span> python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​第三行中，可能会出现 【无法定位软件包libjasper-dev 的错误提示】</p><p>​依次输入以下命令:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> add-apt-repository <span class="token string">"deb http://security.ubuntu.com/ubuntu xenial-security main"</span><span class="token function">sudo</span> apt update<span class="token function">sudo</span> apt upgrade<span class="token function">sudo</span> apt <span class="token function">install</span> libjasper1 libjasper-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>将下载到的OpenCV文件解压, 同级目录下新建一个<code>build</code>文件夹</p><blockquote><p>这里我将带版本号的文件夹的版本号去掉了 即opencv-4.5.4 -&gt; opencv</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507215022064.png" alt="image-20220507215022064"></p><hr><h2 id="二-编译"><a href="#二-编译" class="headerlink" title="二. 编译"></a>二. 编译</h2><p><strong>在bulid路径下执行:</strong></p><p><strong>cmake编译参数:</strong></p><pre class="line-numbers language-bash"><code class="language-bash">cmake <span class="token punctuation">..</span>/opencv -DCMAKE_BUILD_TYPE<span class="token operator">=</span>Release \-DOPENCV_GENERATE_PKGCONFIG<span class="token operator">=</span>ON \-DOPENCV_EXTRA_MODULES_PATH<span class="token operator">=</span>/home/roranrui/mylibs/opencv/opencv_contrib/modules -DBUILD_DOCS<span class="token operator">=</span>ON -DBUILD_EXAMPLES<span class="token operator">=</span>ON \-DOPENCV_GENERATE_PKGCONFIG<span class="token operator">=</span>ON \-DWITH_GTK_2_X<span class="token operator">=</span>ON \-DWITH_OPENGL<span class="token operator">=</span>ON<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>-DOPENCV_EXTRA_MODULES_PATH=</p><p>这里换成自己的路径</p><h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题:"></a>出现问题:</h3><p><strong>卡住</strong>(大概率发生)</p><p>如果没有连接外网，执行过程会卡住，是因为文件下载不下来，等他卡完（一会儿就会跳过结束）这时候，去build文件夹，打开CMakeDownloadLog.txt文件，这里面记录了下载失败的文件，搜索关键词cmake_download，我这里有13个</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507220344961.png" alt="一般是这几个"></p><blockquote><p>  可以在这里下载这些缺失的文件: <a href="https://pan.baidu.com/s/1MTw7nEjrTZBlHoQ4x1KAlg">https://pan.baidu.com/s/1MTw7nEjrTZBlHoQ4x1KAlg</a>提取码: rrwy</p></blockquote><p>使用方法：ippicv_2020_lnx_intel64_20191018_general.tgz这个文件放在<code>/home/roranrui/mylibs/opencv/opencv/3rdparty/ippicv/</code>文件夹下，并打开该文件夹下的<strong>ippicv.cmake</strong>文件，修改如下:</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507220659915.png" alt="image-20220507220659915"></p><p>face_landmark_model.dat这个文件放在<code>/home/roranrui/mylibs/opencv/opencv_contrib/modules/face/</code>文件夹，并修改该文件夹下的<strong>CMakeLists.txt</strong>文件如下：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507220833500.png" alt="image-20220507220833500"></p><p>其余的文件均放在opencv_contrib/modules/xfeatures2d/src/文件夹下</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507220344961.png" alt="这几个"></p><p>build文件夹下继续执行构建命令 -j 后面是线程数</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">make</span> -j4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译完成后:</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/20201027182832744.png"></p><p>再执行:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">make</span> <span class="token function">install</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就ok</p><hr><h2 id="三-配置路径"><a href="#三-配置路径" class="headerlink" title="三. 配置路径"></a>三. 配置路径</h2><h3 id="如何确定自己的共享链接库位置以及版本？"><a href="#如何确定自己的共享链接库位置以及版本？" class="headerlink" title="如何确定自己的共享链接库位置以及版本？"></a><strong>如何确定自己的共享链接库位置以及版本？</strong></h3><p><strong>ubutnu终端中输入：</strong></p><pre class="line-numbers language-bash"><code class="language-bash">ldconfig -p <span class="token operator">|</span><span class="token function">grep</span> opencv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507221600067.png" alt="image-20220507221600067"></p><p>默认情况下编译opencv4等其他版本如果没有修改CMAKE_PREFIX_PATH中的路径。则都会存在/usr/local/lib目录下。</p><p>于是lib库目录就为：<code>LIBS += /usr/local/lib/libopencv*</code></p><p><code>usr即（Unix system resources</code>）下。<br>终端执行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /etc/ld.so.conf.d/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">vi</span> opencv.conf <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 将/usr/local/lib ，/usr/lib编辑写入。ESC 后wq保存退出即可。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507221751575.png" alt="image-20220507221751575"></p><h3 id="如何确定ubuntu下想用的OpenCV版本Inlcude路径？"><a href="#如何确定ubuntu下想用的OpenCV版本Inlcude路径？" class="headerlink" title="如何确定ubuntu下想用的OpenCV版本Inlcude路径？"></a><strong>如何确定ubuntu下想用的OpenCV版本Inlcude路径？</strong></h3><blockquote><p>在比较新的opencv版本中一般只包括一个头文件#include&lt;opencv2/opencv.hpp&gt;就能实现大多数功能。这是因为在新的版本中一些core等模块的头文件都给统一进去了。</p></blockquote><p>终端打开: </p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">vi</span> /etc/ld.so.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加:</p><pre class="line-numbers language-bash"><code class="language-bash">include /usr/local/includeinclude /usr/local/include/opencv4include /usr/local/include/opencv4/opencv2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编辑后保存。</p><p>将自己编译的opencv4头文件路径添加进去。</p><p>更新并保存配置：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> ldconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意：如果找不到/usr/local路径，就要去看一下路径在不在环境变量内：没有的话添加如下图内容即可。</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">vi</span> /etc/bash.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/20191206105729813.png" alt="img"></p><p>验证, 终端输入</p><pre class="line-numbers language-bash"><code class="language-bash">pkg-config --modversion opencv4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现版本号即成功:</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507222159389.png" alt="image-20220507222159389"></p><hr><h2 id="四-配置IDE"><a href="#四-配置IDE" class="headerlink" title="四. 配置IDE"></a>四. 配置IDE</h2><h3 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h3><p>1.打开QT Creator，新建一个项目名为test，选择Qt Consle Applacation后面一直确定默认就行了，注意一下项目路径。</p><p>2 .pro文件：添加下面内容：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">INCLUDEPATH+</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/include \            /usr/local/include/opencv4 \            /usr/local/include/opencv4/opencv2</span><span class="token attr-name">LIBS</span> <span class="token attr-value">+= /usr/local/lib/libopencv*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>稍微说明一下上面的路径：</p><p>INCLUDEPATH 为自己为Ubuntu电脑所编译的opencv的头文件目录（也可称为include目录）</p><p>LIBS 为Ubuntu电脑内opencv的共享链接库（.so.4.1即版本号），在windows中被称为动态链接库（即.dll文件也是带有版本号的）。</p><p>Ubuntu中opencv的共享链接库为（我编译的是4.1版本因此为）：</p><p>libopencv_xphoto.so.4.1</p><p>libopencv_xfeatures2d.so.4.1等等（许多图像处理可用到的库我就不一一列举）</p><p>因此可以在QT中LIBS += /usr/local/lib/libopencv* 设置*通配符即可，而不用一一都给写上（PS：如果不嫌麻烦也可都写上，效果一样）</p></blockquote><p>main.cpp 中测试</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;QCoreApplication></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;opencv2/opencv.hpp></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Mat src<span class="token punctuation">;</span>    src<span class="token operator">=</span><span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"/home/roranrui/图片/roranrui.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">namedWindow</span><span class="token punctuation">(</span><span class="token string">"src"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"src"</span><span class="token punctuation">,</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果:</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507222454837.png" alt="image-20220507222454837"></p><hr><h3 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h3><p>CMakeLists.txt 文件添加:</p><pre class="line-numbers language-cmake"><code class="language-cmake">find_package(OpenCV REQUIRED)message(STATUS "OpenCV library status:")message(STATUS "version: ${OpenCV_VERSION}")message(STATUS "libraries: ${OpenCV_LIBS}")message(STATUS "    include path: ${OpenCV_INCLUDE_DIRS}")add_executable(My_Learning main.cpp)target_link_libraries(My_Learning ${OpenCV_LIBS})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中, target_link_libraries()处需要与你的可执行程序同名</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507224548996.png" alt="编译成功提示"></p><p><strong>测试程序</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/opencv.hpp></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Mat img <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"/home/roranrui/图片/roranrui.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, World!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507222454837.png" alt="image-20220507222454837"></p><p>成功</p><hr><h2 id="五-其他问题"><a href="#五-其他问题" class="headerlink" title="五. 其他问题"></a>五. 其他问题</h2><p>提示出现: <strong>Failed to load module canberra-gtk-module</strong></p><p>解决: </p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libcanberra-gtk-module<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu下配置OpenCV的环境&quot;&gt;&lt;a href=&quot;#Ubuntu下配置OpenCV的环境&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu下配置OpenCV的环境&quot;&gt;&lt;/a&gt;Ubuntu下配置OpenCV的环境&lt;/h1&gt;&lt;blockquo</summary>
      
    
    
    
    <category term="环境配置" scheme="https://roranrui.cn/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="环境配置" scheme="https://roranrui.cn/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Scrcpy-实现手机电脑多屏幕协同</title>
    <link href="https://roranrui.cn/posts/607cae0/"/>
    <id>https://roranrui.cn/posts/607cae0/</id>
    <published>2022-05-07T06:57:14.000Z</published>
    <updated>2022-05-07T09:12:00.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scrcpy-实现手机电脑多屏幕协同"><a href="#Scrcpy-实现手机电脑多屏幕协同" class="headerlink" title="Scrcpy-实现手机电脑多屏幕协同"></a>Scrcpy-实现手机电脑多屏幕协同</h1><blockquote><p>  多屏协同，是原一碰传功能的升级版本，一碰传重点在传输，而升级后的多屏协同，它不仅仅是平板/电脑和手机之间文件互传，更是利用平板/电脑的运算能力和专业系统能力，实现平板/电脑和手机的无缝协同，键盘、鼠标成为手机的外设，在一个大屏设备上完成两个设备的任务，回微信、回邮件等，同时也利用平板/电脑更专业的应用生态</p></blockquote><h2 id="一-什么是Scrcpy"><a href="#一-什么是Scrcpy" class="headerlink" title="一. 什么是Scrcpy"></a>一. 什么是Scrcpy</h2><p>​简单地来说，scrcpy就是通过adb调试的方式来将手机屏幕投到电脑上，并可以通过电脑控制您的Android设备。它可以通过USB连接，也可以通过Wifi连接（类似于隔空投屏），而且不需要任何root权限，不需要在手机里安装任何程序。scrcpy同时适用于GNU / Linux，Windows和macOS。</p><p><strong>特性：</strong></p><ul><li>亮度（原生，仅显示设备屏幕）</li><li>性能（30~60fps）</li><li>质量（1920×1080或以上）</li><li>低延迟（35~70ms）</li><li>启动时间短（显示第一张图像约1秒）</li><li>非侵入性（设备上没有安装任何东西）</li></ul><h3 id="使用scrcpy的要求"><a href="#使用scrcpy的要求" class="headerlink" title="使用scrcpy的要求"></a>使用scrcpy的要求</h3><ol><li>Android设备至少需要API 21（Android 5.0以上版本）;</li><li>确保在您的设备上启用了adb调试</li><li>在某些设备上，您还需要启用其他选项以使用键盘和鼠标控制它。</li></ol><blockquote><p>  adb的全称为Android Debug Bridge，就是起到调试桥的作用。通过adb我们可以在<a href="https://baike.baidu.com/item/Eclipse">Eclipse</a>中方便通过DDMS来调试Android程序，说白了就是<a href="https://baike.baidu.com/item/debug">debug</a>工具。—百度百科</p></blockquote><h4 id="如何开启adb调试"><a href="#如何开启adb调试" class="headerlink" title="如何开启adb调试"></a>如何开启adb调试</h4><p><strong>以笔者的手机为例(红米K40 MIUI版本13.0.2)</strong></p><h5 id="①进入开发者模式"><a href="#①进入开发者模式" class="headerlink" title="①进入开发者模式"></a>①进入开发者模式</h5><p>依次进入: 设置-&gt;我的设备-&gt;全部参数   点击MIUI版本多次, 就可以开启开发者模式</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507150849001.png" alt="image-20220507150849001"></p><h5 id="②开启usb调试"><a href="#②开启usb调试" class="headerlink" title="②开启usb调试"></a>②开启usb调试</h5><p>依次进入: 设置-&gt;更多设置-&gt;开发者选项 开启<strong>USB调试</strong>, <strong>USB调试(安全设置)</strong></p><blockquote><p>  开发者选项中含有其他可能会影响系统运行的选项, 请勿随意开启任何功能</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507151311210.png" alt="image-20220507151311210"></p><h3 id="下载与配置Scrcpy"><a href="#下载与配置Scrcpy" class="headerlink" title="下载与配置Scrcpy"></a>下载与配置Scrcpy</h3><p>Github地址：<a href="https://github.com/Genymobile/scrcpy">Genymobile/scrcpy: Display and control your Android device</a></p><p>进入release发行</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507151447381.png" alt="image-20220507151447381"></p><p>根据自己的需求下载对应版本的文件即可</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507151534779.png" alt="image-20220507151534779"></p><p>解压的目录:</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507151637282.png" alt="image-20220507151637282"></p><p>接下来需要将该目录加入系统环境变量</p><p>在WINDOWS10下, 依次进入: 设置-&gt;系统-&gt;关于</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507151813267.png" alt="image-20220507151813267"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507151826437.png" alt="选择环境变量"></p><p>在系统变量处点击编辑 将解压目录的地址添加进去 就可以在cmd中直接操作了!</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507151954837.png" alt="image-20220507151954837"></p><hr><p><code>win + R</code>打开cmd输入<code>adb version</code>验证是否配置成功</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507171159024.png" alt="image-20220507171159024"></p><h2 id="二-实现多屏协同"><a href="#二-实现多屏协同" class="headerlink" title="二. 实现多屏协同"></a>二. 实现多屏协同</h2><h3 id="方案一-使用USB进行连接"><a href="#方案一-使用USB进行连接" class="headerlink" title="方案一: 使用USB进行连接"></a>方案一: 使用USB进行连接</h3><ol><li>手机通过USB连接到PC上，首次连接会弹出是否信任该电脑，点击始终信任即可。</li><li>命令行运行<code>adb usb</code>查看是否连接成功</li></ol><pre class="line-numbers language-bash"><code class="language-bash">adb usb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507152533354.png" alt="image-20220507152533354"></p><p>同时手机会显示已连接到usb调试</p><p>第一次连接:</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507152728600.png" alt="image-20220507152728600"></p><p>此时连接成功后, 直接运行<code>scrcpy</code>即可</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507152845362.png" alt="image-20220507152845362"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507152838116.png" alt="image-20220507152838116"></p><h3 id="方案二-使用无线连接"><a href="#方案二-使用无线连接" class="headerlink" title="方案二: 使用无线连接"></a>方案二: 使用无线连接</h3><blockquote><p>  此连接方式更加方便快捷，若宽带速率高，使用效果更佳，使用方法也非常简单。</p><p>  为保证传输速率和质量, 建议使用手机连接电脑端热点</p></blockquote><ol><li>确保PC和手机在同一Wifi中</li><li><strong>手机先通过USB与PC相连</strong></li><li>在PC上运行 adb tcpip 服务端口，如端口为5555</li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507153208942.png" alt="image-20220507153208942"></p><ol start="4"><li><p>拔下你的设备，断开USB连接</p></li><li><p>在PC上运行 adb connect 手机IP:服务端口(手机IP可通过手机的<code>状态信息</code>, 或wifi网络详情查看)，或者登录路由器查看，一般以192.168开头）</p></li></ol><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507153315694.png" alt="image-20220507153315694"></p><ol start="6"><li>运行<code>scrcpy</code> 即可实现无线同屏</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>投屏运行成功后, cmd窗口不可关闭, 因为此时该窗口相当于一个<code>进程</code>, 如果关闭, 投屏也将关闭</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507154117089.png" alt="image-20220507154117089"></p><hr><h2 id="三-其他操作"><a href="#三-其他操作" class="headerlink" title="三. 其他操作"></a>三. 其他操作</h2><h3 id="比特率修改"><a href="#比特率修改" class="headerlink" title="比特率修改"></a>比特率修改</h3><p>无线投屏, 可能传输速率会导致性能变慢, 默认的scrcpy比特率是8Mbps，这对于Wi-Fi连接来说可能太多了。根据使用情况，降低比特率和分辨率可能是一个很好的折中方案。</p><pre class="line-numbers language-bash"><code class="language-bash">scrcpy --bit-rate 2M <span class="token comment" spellcheck="true"># 或者简写</span>scrcpy -b2M -m800<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="降低分辨率"><a href="#降低分辨率" class="headerlink" title="降低分辨率"></a>降低分辨率</h3><p>有时候，可以通过降低镜像的分辨率来提高性能。</p><p>要同时限制宽度和高度到某个值 (例如 1024)：</p><pre class="line-numbers language-cpp"><code class="language-cpp">scrcpy <span class="token operator">--</span>max<span class="token operator">-</span>size <span class="token number">1024</span>scrcpy <span class="token operator">-</span>m <span class="token number">1024</span>  # 简写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="限制帧率"><a href="#限制帧率" class="headerlink" title="限制帧率"></a>限制帧率</h3><p>要限制采集的帧率：</p><pre class="line-numbers language-cpp"><code class="language-cpp">scrcpy <span class="token operator">--</span>max<span class="token operator">-</span>fps <span class="token number">15</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="启动时关闭设备屏幕"><a href="#启动时关闭设备屏幕" class="headerlink" title="启动时关闭设备屏幕"></a>启动时关闭设备屏幕</h3><p>使用命令行选项在启动时镜像时可以关闭设备屏幕，这一点也挺实用：</p><pre class="line-numbers language-bash"><code class="language-bash">scrcpy --turn-screen-offscrcpy -S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>窗口的标题默认为设备型号。可以通过如下命令修改：</p><pre class="line-numbers language-bash"><code class="language-bash">scrcpy --window-title <span class="token string">'My device'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="无边框"><a href="#无边框" class="headerlink" title="无边框"></a>无边框</h3><p>禁用窗口边框：</p><pre class="line-numbers language-bash"><code class="language-bash">scrcpy --window-borderless<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>可以通过以下命令旋转窗口：</p><pre class="line-numbers language-bash"><code class="language-bash">scrcpy --rotation 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可选的值有：</p><ul><li><code>0</code>: 无旋转</li><li><code>1</code>: 逆时针旋转 90°</li><li><code>2</code>: 旋转 180°</li><li><code>3</code>: 顺时针旋转 90°</li></ul><p>也可以使用 Ctrl+← <em>(左箭头)</em> 和 Ctrl+→ <em>(右箭头)</em> 随时更改。</p><h3 id="查看设备信息"><a href="#查看设备信息" class="headerlink" title="查看设备信息"></a>查看设备信息</h3><pre class="line-numbers language-bash"><code class="language-bash">adb devices<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><table><thead><tr><th>操作</th><th>快捷键</th></tr></thead><tbody><tr><td>切换全屏模式</td><td>Ctrl+f</td></tr><tr><td>向左旋转显示屏</td><td>Ctrl+← <em>（左）</em></td></tr><tr><td>向右旋转显示屏</td><td>Ctrl+→ <em>（右）</em></td></tr><tr><td>将窗口大小调整为 1：1（像素完美）</td><td>Ctrl+g</td></tr><tr><td>调整窗口大小以删除黑色边框</td><td>Ctrl+w|<em>双击¹</em></td></tr><tr><td>点击<code>HOME</code></td><td>Ctrl+h|<em>中键单击</em></td></tr><tr><td>点击<code>BACK</code></td><td>Ctrl+b|<em>右键单击²</em></td></tr><tr><td>点击<code>APP_SWITCH</code></td><td>Ctrl+s|<em>第四次点击³</em></td></tr><tr><td>点击（解锁屏幕）⁴<code>MENU</code></td><td>Ctrl+m</td></tr></tbody></table><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Scrcpy-实现手机电脑多屏幕协同&quot;&gt;&lt;a href=&quot;#Scrcpy-实现手机电脑多屏幕协同&quot; class=&quot;headerlink&quot; title=&quot;Scrcpy-实现手机电脑多屏幕协同&quot;&gt;&lt;/a&gt;Scrcpy-实现手机电脑多屏幕协同&lt;/h1&gt;&lt;blockquo</summary>
      
    
    
    
    <category term="软件插件分享" scheme="https://roranrui.cn/categories/%E8%BD%AF%E4%BB%B6%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    
    
    <category term="经验分享" scheme="https://roranrui.cn/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>第十四天_搜索与回溯(中等)</title>
    <link href="https://roranrui.cn/posts/4c30a2e3/"/>
    <id>https://roranrui.cn/posts/4c30a2e3/</id>
    <published>2022-05-07T04:56:40.000Z</published>
    <updated>2022-05-07T09:25:51.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四天-搜索与回溯-中等"><a href="#第十四天-搜索与回溯-中等" class="headerlink" title="第十四天_搜索与回溯(中等)"></a>第十四天_搜索与回溯(中等)</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a><strong>剪枝</strong></h3><p>一：剪枝策略的寻找的方法</p><p>微观方法：从问题本身出发，发现剪枝条件</p><p>宏观方法：从整体出发，发现剪枝条件。</p><p>注意提高效率，这是关键，最重要的。</p><blockquote><p>   总之，剪枝策略，属于算法优化范畴；通常应用在DFS 和 BFS 搜索算法中；剪枝策略就是寻找过滤条件，提前减少不必要的搜索路径。</p></blockquote><p>二：剪枝算法(算法优化)</p><ol><li><p>简介</p><p> 在搜索算法中优化中，剪枝，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是剪去了搜索树中的某些“枝条”，故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法，即确定哪些枝条应当舍弃，哪些枝条应当保留的方法。</p></li><li><p>剪枝优化三原则: 正确、准确、高效.原则</p><p>搜索算法,绝大部分需要用到剪枝.然而,不是所有的枝条都可以剪掉,这就需要通过设计出合理的判断方法,以决定某一分支的取舍. 在设计判断方法的时候,需要遵循一定的原则.</p><ul><li><p>剪枝的原则</p><ul><li><pre><code>正确性</code></pre></li></ul><p>正如上文所述,枝条不是爱剪就能剪的. 如果随便剪枝,把带有最优解的那一分支也剪掉了的话,剪枝也就失去了意义. 所以,剪枝的前提是一定要保证不丢失正确的结果.</p><ul><li><p>准确性</p><p>在保证了正确性的基础上,我们应该根据具体问题具体分析,采用合适的判断手段,使不包含最优解的枝条尽可能多的被剪去,以达到程序“最优化”的目的. 可以说,剪枝的准确性,是衡量一个优化算法好坏的标准.</p></li><li><p>高效性</p><p>设计优化程序的根本目的,是要减少搜索的次数,使程序运行的时间减少. 但为了使搜索次数尽可能的减少,我们又必须花工夫设计出一个准确性较高的优化算法,而当算法的准确性升高,其判断的次数必定增多,从而又导致耗时的增多,这便引出了矛盾. 因此,如何在优化与效率之间寻找一个平衡点,使得程序的时间复杂度尽可能降低,同样是非常重要的. 倘若一个剪枝的判断效果非常好,但是它却需要耗费大量的时间来判断、比较,结果整个程序运行起来也跟没有优化过的没什么区别,这样就太得不偿失了.</p></li></ul></li></ul></li><li><p>分类</p><p> 剪枝算法按照其判断思路可大致分成两类:可行性剪枝及最优性剪枝.</p><ul><li><p>可行性剪枝 —— 该方法判断继续搜索能否得出答案，如果不能直接回溯。</p></li><li><p>最优性剪枝——又称为上下界剪枝，是一种重要的搜索剪枝策略。它记录当前得到的最优值，如果当前结点已经无法产生比当前最优解更优的解时，可以提前回溯。</p></li></ul></li></ol><hr><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-矩阵中的路径"><a href="#1-矩阵中的路径" class="headerlink" title="1. 矩阵中的路径"></a>1. 矩阵中的路径</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507130945157.png" alt="img "></p><p><strong>解题思路：</strong><br>本问题是典型的矩阵搜索问题，可使用 <strong>深度优先搜索（DFS）</strong>+ <strong>剪枝</strong> 解决。</p><p>深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。<br>剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/1604944042-glmqJO-Picture0.png" alt="Picture0.png"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507131414911.png" alt="img"></p><p><strong>实现:</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">exist</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> string word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        rows <span class="token operator">=</span> board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cols <span class="token operator">=</span> board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rows<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cols<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> word<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> rows<span class="token punctuation">,</span> cols<span class="token punctuation">;</span>    <span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> string word<span class="token punctuation">,</span> <span class="token keyword">int</span> i <span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/// 越界处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> rows <span class="token operator">||</span> j <span class="token operator">>=</span> cols <span class="token operator">||</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> word<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// index == 0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> word<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 将匹配的标记为空字符 防止重复访问</span>        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 在相邻区域寻找匹配的 </span>        <span class="token keyword">bool</span> res <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> word<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> word<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span>         <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> word<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span> word<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> word<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507134821863.png" alt="img"></p><hr><h3 id="2-机器人的运动范围"><a href="#2-机器人的运动范围" class="headerlink" title="2. 机器人的运动范围"></a>2. 机器人的运动范围</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507140210236.png" alt="image-20220507140210236"></p><p><strong>解题思路:</strong></p><h4 id="数位之和计算"><a href="#数位之和计算" class="headerlink" title="数位之和计算"></a>数位之和计算</h4><p><strong>封装函数:</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">sums</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        s <span class="token operator">+</span><span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> x <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507141046291.png" alt="image-20220507141046291"></p><h4 id="可达解分析"><a href="#可达解分析" class="headerlink" title="可达解分析"></a>可达解分析</h4><blockquote><p>  根据数位和增量公式得知，数位和每逢 进位 突变一次。根据此特点，矩阵中 满足数位和的解 构成的几何形状形如多个 等腰直角三角形 ，每个三角形的直角顶点位于 0, 10, 20, …等数位和突变的矩阵索引处 。</p><p>  三角形内的解虽然都满足数位和要求，但由于机器人每步只能走一个单元格，而三角形间不一定是连通的，因此机器人不一定能到达，称之为 不可达解 ；同理，可到达的解称为 可达解 （本题求此解） 。</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/1603026306-OdpwLi-Picture1.png" alt="1"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/1603026306-daxIuh-Picture4.png" alt="2"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507141819402.png" alt="image-20220507141819402"></p><p>1.深度优先遍历 DFS<br>深度优先搜索： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。<br>剪枝： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 。</p><blockquote><p>  <img src="C:/Users/13993/AppData/Roaming/Typora/typora-user-images/image-20220507142324877.png" alt="image-20220507142324877"></p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507142120913.png" alt="image-20220507142120913"></p><p><strong>实现:</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">movingCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">>></span> <span class="token function">visited</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> visited<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j <span class="token punctuation">,</span> <span class="token keyword">int</span> si<span class="token punctuation">,</span> <span class="token keyword">int</span> sj<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">>></span> <span class="token operator">&amp;</span>visited<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/// 越界处理 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> m <span class="token operator">||</span> j <span class="token operator">>=</span> n <span class="token operator">||</span> k <span class="token operator">&lt;</span> si <span class="token operator">+</span> sj <span class="token operator">||</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// visited[i][j]代表当前元素已访问过</span>        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 向右下方搜索</span>        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">?</span> si <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> si <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">,</span> sj<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">+</span>         <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> si<span class="token punctuation">,</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">?</span> sj <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> sj <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">,</span> visited<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507143549919.png" alt="image-20220507143549919"></p><p>2.广度优先遍历 BFS</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507143613569.png" alt="image-20220507143613569"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507143620435.png" alt="image-20220507143620435"></p><p><strong>实现:</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">movingCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">>></span> <span class="token function">visited</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/// 弹出队首元素作为搜索单元格</span>            vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tmp <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> tmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> j <span class="token operator">=</span> tmp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> si <span class="token operator">=</span> tmp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> sj <span class="token operator">=</span> tmp<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/// 越界处理 </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> m <span class="token operator">||</span> j <span class="token operator">>=</span> n <span class="token operator">||</span> k <span class="token operator">&lt;</span> si <span class="token operator">+</span> sj <span class="token operator">||</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            res<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/// 向右下方搜索</span>            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">?</span> si <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> si <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">,</span> sj<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> si<span class="token punctuation">,</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">?</span> sj <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> sj <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220507144808324.png" alt="image-20220507144808324"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十四天-搜索与回溯-中等&quot;&gt;&lt;a href=&quot;#第十四天-搜索与回溯-中等&quot; class=&quot;headerlink&quot; title=&quot;第十四天_搜索与回溯(中等)&quot;&gt;&lt;/a&gt;第十四天_搜索与回溯(中等)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程进阶三</title>
    <link href="https://roranrui.cn/posts/64bc088f/"/>
    <id>https://roranrui.cn/posts/64bc088f/</id>
    <published>2022-05-06T11:12:07.000Z</published>
    <updated>2022-05-06T15:53:42.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程进阶-三"><a href="#多线程进阶-三" class="headerlink" title="多线程进阶(三)"></a>多线程进阶(三)</h1><blockquote><p>  本篇内容比较抽象, 了解即可</p></blockquote><h2 id="一-WINDOWS临界区"><a href="#一-WINDOWS临界区" class="headerlink" title="一. WINDOWS临界区"></a>一. WINDOWS临界区</h2><blockquote><p>  临界区又称关键代码段，指的是一小段代码在代码执行前，它需要独占一些资源。</p></blockquote><p><strong>初始化</strong></p><p>程序中通常将多线程同时访问的某个资源作为临界区，需要定义一个CRITICAL_SECTION类型的变量，然后调用InitializeCriticalSection函数对变量进行初始化；</p><p><strong>函数原型</strong>：<code>VOID InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection );</code><br>参数说明：lpCriticalSection：一个CRITICAL_SECTION结构指针，表示用于初始化的临界区；<br>InitializeCriticalSection函数在内部设置了CRITICAL_SECTION结构的某些成员变量，所以它不会失败。</p><p><strong>定义临界区</strong><br>为了将某一段代码定义为临界区，需要调用EnterCriticalSection函数；<br><strong>函数原型</strong>：<code>VOID WINAPI EnterCriticalSection(__inout LPCRITICAL_SECTION lpCriticalSection);</code></p><p>该函数的作用是判断是否有线程访问临界区资源：</p><p>如果没有，就改变CRITICAL_SECTION结构的成员变量的值，赋予当前线程访问权，函数立即返回；<br>如果有线程正在访问资源，则进入等待状态，直到没有线程访问。</p><p><strong>释放资源</strong><br>函数原型：<code>void WINAPI LeaveCriticalSection( _Inout_LPCRITICAL_SECTION lpCriticalSection);</code></p><p><strong>释放CRITICAL_SECTION结构指针</strong><br>函数原型：<code>void WINAPI DeleteCriticalSection(_Inout_ LPCRITICAL_SECTION lpCriticalSection)</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;Windows.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> __WINDOWSJQ_</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 把收到的消息传入队列</span>    <span class="token keyword">void</span> <span class="token function">inMsgRecvQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"收到消息，并放入队列 "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">ifdef</span>  __WINDOWSJQ_</span>            <span class="token function">EnterCriticalSection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_winsec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//进入临界区</span>            <span class="token comment" spellcheck="true">//EnterCriticalSection(&amp;my_winsec);//可以再次进入临界区,程序不会出错</span>            msgRecvQueue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">LeaveCriticalSection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_winsec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//离开临界区</span>            <span class="token comment" spellcheck="true">//LeaveCriticalSection(&amp;my_winsec);//如果进入两次，必须离开两次不会报错</span><span class="token macro property">#<span class="token directive keyword">elif</span></span>            my_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            msgRecvQueue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            my_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">//  __WINDOWSJQ_</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"消息入队结束"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 从队列中取出消息</span>    <span class="token keyword">void</span> <span class="token function">outMsgRecvQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">ifdef</span>  __WINDOWSJQ_</span>            <span class="token function">EnterCriticalSection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_winsec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//进入临界区</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 队列不为空</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"从消息队列中取出 "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 消息队列为空</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"消息队列为空 "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">LeaveCriticalSection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_winsec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//离开临界区</span><span class="token macro property">#<span class="token directive keyword">elif</span></span>            my_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 队列不为空</span>                <span class="token keyword">int</span> num <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"从消息队列中取出 "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                my_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 消息队列为空</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"消息队列为空 "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                my_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">//  __WINDOWSJQ_</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"消息出队结束"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __WINDOWSJQ_</span>        <span class="token function">InitializeCriticalSection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_winsec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用临界区之前要初始化</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// __WINDOWSJQ_</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> msgRecvQueue<span class="token punctuation">;</span>    mutex my_mutex<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">ifdef</span> __WINDOWSJQ_</span>    CRITICAL_SECTION my_winsec<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//windows中的临界区，非常类似C++11中的mutex</span><span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment" spellcheck="true">// __WINDOWSJQ_</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    A myobj<span class="token punctuation">;</span>    thread<span class="token function">myInMsgObj</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>outMsgRecvQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>myobj<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token function">myOutMsgObj</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>inMsgRecvQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>myobj<span class="token punctuation">)</span><span class="token punctuation">;</span>    myInMsgObj<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    myOutMsgObj<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  Windows临界区，同一个线程是可以重复进入的，但是进入的次数与离开的次数必须相等。<br>  C++互斥量则不允许同一个线程重复加锁。</p><p>  windows临界区是在windows编程中的内容，了解一下即可，效果几乎可以等同于c++11的mutex</p><p>  #include &lt;windows.h&gt;<br>  windows中的临界区同mutex一样，可以保护一个代码段。</p><p>  但windows的临界区可以进入多次，离开多次，但是进入的次数与离开的次数必须相等，不会引起程序报异常出错。</p></blockquote><hr><h2 id="二-自动析构"><a href="#二-自动析构" class="headerlink" title="二. 自动析构"></a>二. 自动析构</h2><blockquote><p>  C++：lock_guard防止忘了释放信号量，自动释放<br>  windows：可以写个类自动释放临界区：</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CWinLock</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">CWinLock</span><span class="token punctuation">(</span>CRITICAL_SECTION <span class="token operator">*</span>pCritmp<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        my_winsec <span class="token operator">=</span>pCritmp<span class="token punctuation">;</span>        <span class="token function">EnterCriticalSection</span><span class="token punctuation">(</span>my_winsec<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">CWinLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">LeaveCriticalSection</span><span class="token punctuation">(</span>my_winsec<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    CRITICAL_SECTION <span class="token operator">*</span>my_winsec<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="三-其他mutex互斥量"><a href="#三-其他mutex互斥量" class="headerlink" title="三. 其他mutex互斥量"></a>三. 其他mutex互斥量</h2><h3 id="1-std-recursive-mutex"><a href="#1-std-recursive-mutex" class="headerlink" title="1.  std::recursive_mutex"></a>1.  std::recursive_mutex</h3><ul><li>std::mutex 独占式互斥量</li><li>std::recursive_mutex：递归独占互斥量, 允许在同一个线程中同一个互斥量多次被 lock() ，（但是递归加锁的次数是有限制的，太多可能会报异常），效率要比mutex低。</li></ul><p>如果真的用了 recursive_mutex 要考虑代码是否有优化空间，如果能调用一次 lock()就不要调用多次。</p><h3 id="2-std-timed-mutex"><a href="#2-std-timed-mutex" class="headerlink" title="2. std::timed_mutex"></a>2. std::timed_mutex</h3><p>std::timed_mutex：是待超时的独占互斥量</p><ul><li><strong>try_lock_for()：</strong></li></ul><p>等待一段时间，如果拿到了锁，或者超时了未拿到锁，就继续执行（有选择执行）如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>my_mymutex<span class="token punctuation">.</span><span class="token function">try_lock_for</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//......拿到锁返回ture</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">sleeptime</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>sleeptime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>try_lock_until()：</strong></li></ul><p>是一个未来的时间点，在这个未来的时间没到的时间内，如果拿到了锁就往下走；如果时间到了，没拿到锁程序流程也往下走。</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>my_mymutex<span class="token punctuation">.</span><span class="token function">try_lock_until</span><span class="token punctuation">(</span>chrono<span class="token operator">::</span>steady_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//......拿到锁返回ture</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">sleeptime</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>sleeptime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>   两者的区别就是一个参数是时间段，一个参数是时间点</p></blockquote><p><strong>其他:</strong></p><p>std::recursive_timed_mutex：是待超时的递归独占互斥量</p><hr><h2 id="四-线程池概念"><a href="#四-线程池概念" class="headerlink" title="四. 线程池概念"></a>四. 线程池概念</h2><blockquote><p>  场景设想：服务器程序， 每来一个客户端，就创建一个新线程为这个客户提供服务。</p></blockquote><p>问题：</p><p>1、2万个玩家，不可能给每个玩家创建一个新线程，此程序写法在这种场景下不通。</p><p>2、程序稳定性问题：编写代码中，“时不时地<strong>突然</strong>”创建一个线程，这种写法，一般情况下不会出错，但是不稳定的；</p><p>线程池：把一堆线程弄到一起，统一管理。这种统一管理调度，循环利用的方式，就叫做线程池。</p><p>实现方式：程序启动时，一次性创建好一定数量的线程。这种方式让人更放心，觉得程序代码更稳定。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220506201905184.png" alt="WIN10下的线程池"></p><p><strong>线程创建数量：</strong></p><ol><li><p>线程创建的数量极限的问题</p><p>一般来讲，2000个线程基本就是极限；再创建就会崩溃。</p></li><li><p>线程创建数量建议</p><ol><li>采用某些计数开发程序提供的建议，遵照建议和指示来确保程序高效执行。</li><li>创建多线程完成业务；考虑可能被阻塞的线程数量，创建多余最大被阻塞线程数量的线程，如100个线程被阻塞再充值业务，开110个线程就是很合适的</li><li>线程创建数量尽量不要超过500个，尽量控制在200个之内；</li></ol></li></ol><h2 id="五-一些补充"><a href="#五-一些补充" class="headerlink" title="五. 一些补充"></a>五. 一些补充</h2><h3 id="1-虚假唤醒"><a href="#1-虚假唤醒" class="headerlink" title="1. 虚假唤醒"></a>1. 虚假唤醒</h3><p>notify_one或者notify_all唤醒wait()后，实际有些线程可能不满足唤醒的条件，就会造成虚假唤醒，可以在wait中再次进行判断解决虚假唤醒。</p><p><strong>解决：</strong></p><p>wait中要有第二个参数（lambda），并且这个lambda中要正确判断所处理的公共数据是否存在。</p><pre class="line-numbers language-cpp"><code class="language-cpp">my_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>ulock1<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-atomic操作"><a href="#2-atomic操作" class="headerlink" title="2. atomic操作"></a>2. atomic操作</h3><p>如:</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">atm</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> atm <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里只有读取atm是原子操作，但是整个这一行代码 <code>cout &lt;&lt; atm &lt;&lt; endl</code>; 并不是原子操作，导致最终显示在屏幕上的值是一个“曾经值”。</p><p>读取内容:</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">atm</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> atm_2 <span class="token operator">=</span> atm<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>应使用: <code>atomic&lt;int&gt; atm2(atm.load());</code>  以原子方式读atomic对象的值。</p><p>写入内容:</p><pre class="line-numbers language-cpp"><code class="language-cpp">atm2<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>  原子操作实质上是：不允许在进行原子对象操作时进行CPU的上下文切换</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程进阶-三&quot;&gt;&lt;a href=&quot;#多线程进阶-三&quot; class=&quot;headerlink&quot; title=&quot;多线程进阶(三)&quot;&gt;&lt;/a&gt;多线程进阶(三)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  本篇内容比较抽象, 了解即可&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="多线程" scheme="https://roranrui.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="多线程编程" scheme="https://roranrui.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>第十三天_双指针(简单)</title>
    <link href="https://roranrui.cn/posts/a2d105e0/"/>
    <id>https://roranrui.cn/posts/a2d105e0/</id>
    <published>2022-05-06T04:50:45.000Z</published>
    <updated>2022-05-06T16:03:45.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十三天-双指针-简单"><a href="#第十三天-双指针-简单" class="headerlink" title="第十三天_双指针(简单)"></a>第十三天_双指针(简单)</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="位运算详解"><a href="#位运算详解" class="headerlink" title="位运算详解"></a>位运算详解</h3><blockquote><p>  计算机中的数在内存中都是以<strong>二进制</strong>形式进行存储的 ，而位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。</p></blockquote><table><thead><tr><th>符号</th><th>描述</th><th><strong>运算规则</strong></th></tr></thead><tbody><tr><td>&amp;</td><td>与</td><td>两个位都为1时，结果才为1。</td></tr><tr><td>|</td><td>或</td><td>两个位都为0时，结果才为0。</td></tr><tr><td>^</td><td>异或</td><td>两个位相同为0，相异为1。</td></tr><tr><td>~</td><td>取反</td><td>0变1，1变0。</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td>各二进位全部左移若干位，高位丢弃，低位补0。</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，右移补1 11。</td></tr></tbody></table><blockquote><p>  对于运算符优先级, 个人认为没有必要记, 按自己的需求添加括号保证顺序即可</p></blockquote><h4 id="负数的位运算"><a href="#负数的位运算" class="headerlink" title="负数的位运算"></a>负数的位运算</h4><p>首先，我们要知道，在计算机中，运算是使用的二进制补码，而正数的补码是它本身，负数的补码则是符号位不变，其余按位取反，最后再+ 1 +1+1得到的， 例如：</p><ul><li><p>15 ,原码:00001111 补码:00001111</p></li><li><p>− 15 ,原码:10001111  补码:11110001</p></li></ul><p>​那么对于负数的位运算而言，它们的操作都是建立在补码上的，得到的运算结果是补码，最后将补码结果转化成一个普通的十进制数结果。但需要注意的是，符号位是需要参与运算的，而在左移右移操作中，负数右移补1 ，左移右边补0 。例如对于− 15 ，其补码为11110001 , 右移一位( − 15 &gt; &gt; 1 ) 得到的是11111000 ，即− 8 ，其他的同理。</p><p><strong>关于负数位运算的运用:</strong></p><ul><li>快速判断是否为− 1</li></ul><p>​在链式前向星中，我们初始化head数组为- 1,最后判断是否遍历完u的所有边时，即判断是否为- -1, 我们直接用~即可。原因就在于- 1的补码是11111111,按位取反就变为00000000，这实际上就是0。</p><ul><li><strong>取最低位的1 ，lowbit函数</strong></li></ul><p>也就是:x&amp;(- x), 这在树状数组中起着巨大作用，我们来证明一下，这里取x= 15,对于15&amp;(-15), 我们知道,在补码上进行运算得到的00000001要注意元运算的符号位我们需要进行运算。</p><h3 id="位运算的一些应用"><a href="#位运算的一些应用" class="headerlink" title="位运算的一些应用"></a>位运算的一些应用</h3><ol><li><strong>位运算实现乘除法</strong></li></ol><pre class="line-numbers language-cpp"><code class="language-cpp">a <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">==</span> a <span class="token operator">*</span> <span class="token number">2</span>a <span class="token operator">>></span> <span class="token number">1</span> <span class="token operator">==</span> a <span class="token operator">/</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li><strong>位运算交换两整数</strong></li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>    a <span class="token operator">^</span><span class="token operator">=</span> b<span class="token punctuation">;</span>    b <span class="token operator">^</span><span class="token operator">=</span> a<span class="token punctuation">;</span>    a <span class="token operator">^</span><span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>位运算判断奇偶数</strong></li></ol><blockquote><p>  我们知道,在二进制中,最低位决定了是奇数还是偶数,所以我们可以提取出最低位的值</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">a <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true">// 判断a是不是偶数</span>a <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true">// 判断a是不是奇数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li><strong>位运算改变正负性和求绝对值</strong></li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">~</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-调整数组顺序使奇数位于偶数前面"><a href="#1-调整数组顺序使奇数位于偶数前面" class="headerlink" title="1. 调整数组顺序使奇数位于偶数前面"></a>1. 调整数组顺序使奇数位于偶数前面</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220506125755717.png" alt="image-20220506125755717"></p><p><strong>解题思路：</strong><br>考虑定义双指针 i , j 分列数组左右两端，循环执行：</p><ol><li>指针 i 从左向右寻找偶数；</li><li>指针 j 从右向左寻找奇数；</li><li>将 偶数 nums[i] 和 奇数 nums[j] 交换。</li></ol><p><strong>可始终保证：</strong> 指针 i 左边都是奇数，指针 j 右边都是偶数 。</p><p><strong>实现:</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">exchange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220506130314711.png" alt="image-20220506130314711"></p><hr><h3 id="2-和为-s-的两个数字"><a href="#2-和为-s-的两个数字" class="headerlink" title="2. 和为 s 的两个数字"></a>2. 和为 s 的两个数字</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220506132804781.png" alt="image-20220506132804781"></p><p><strong>解题思路：</strong></p><ul><li>利用 <strong>HashMap</strong> 可以通过遍历数组找到数字组合，时间和空间复杂度均为 O(N)；</li><li>注意本题的 nums 是 排序数组 ，因此可使用 <strong>双指针法</strong> 将空间复杂度降低至 O(1) 。</li></ul><p><strong>算法流程：</strong><br>初始化： 双指针 i, j 分别指向数组 nums 的左右两端 （俗称对撞双指针）。<br>循环搜索： 当双指针相遇时跳出；<br>计算和 s = nums[i] + nums[j]；<br>若 s &gt; target ，则指针 j 向左移动，即执行 j = j - 1；<br>若 s &lt; target ，则指针 i 向右移动，即执行 i = i + 1；<br>若 s = target ，立即返回数组 [nums[i],nums[j]] ；</p><p><strong>实现:</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">!=</span> r<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> target<span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token punctuation">{</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220506133726971.png" alt="image-20220506133726971"></p><hr><h3 id="3-翻转单词顺序"><a href="#3-翻转单词顺序" class="headerlink" title="3. 翻转单词顺序"></a>3. 翻转单词顺序</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220506133951807.png" alt="image-20220506133951807"></p><p><strong>解题思路</strong>:</p><ul><li>倒序遍历字符串 s ，记录单词左右索引边界 i , j ；</li><li>每确定一个单词的边界，则将其添加至单词列表 res ；</li><li>最终，将单词列表拼接为字符串，并返回即可。</li></ul><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string <span class="token function">reverseWords</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/// 去除首尾空格</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> l<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> r<span class="token operator">--</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>string<span class="token operator">></span> dp<span class="token punctuation">;</span>        string tmp<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token string">' '</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token punctuation">{</span>                dp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>                 tmp <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span> tmp <span class="token operator">+</span><span class="token operator">=</span> c<span class="token punctuation">;</span>            l<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        dp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>        string res<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>dp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            res <span class="token operator">+</span><span class="token operator">=</span> dp<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dp<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> res <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220506135746451.png" alt="image-20220506135746451"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十三天-双指针-简单&quot;&gt;&lt;a href=&quot;#第十三天-双指针-简单&quot; class=&quot;headerlink&quot; title=&quot;第十三天_双指针(简单)&quot;&gt;&lt;/a&gt;第十三天_双指针(简单)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href=&quot;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第十二天_双指针(简单)</title>
    <link href="https://roranrui.cn/posts/4ce21c9/"/>
    <id>https://roranrui.cn/posts/4ce21c9/</id>
    <published>2022-05-05T00:05:00.000Z</published>
    <updated>2022-05-06T15:48:24.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十二天-双指针-简单"><a href="#第十二天-双指针-简单" class="headerlink" title="第十二天_双指针(简单)"></a>第十二天_双指针(简单)</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/2.jpg" alt="没什么要学的"></p><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-合并两个排序的链表"><a href="#1-合并两个排序的链表" class="headerlink" title="1. 合并两个排序的链表"></a>1. 合并两个排序的链表</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220505080833945.png" alt="image-20220505080833945"></p><p><strong>解题思路</strong>:</p><p><strong>1.双指针</strong></p><p>根据题目描述， 链表 l_1, l_2是 递增 的，因此容易想到使用双指针 l_1和 l_2遍历两链表，根据 l_1.val</p><p>和 l_2.val 的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。</p><p>引入伪头节点： 由于初始状态合并链表中无节点，因此循环第一轮时无法将节点添加到合并链表中。解决方案：初始化一个辅助节点 dum 作为合并链表的伪头节点，将各节点添加至 dum 之后</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>dum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode <span class="token operator">*</span>cur <span class="token operator">=</span> dum<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">&lt;</span> l2<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>                l1 <span class="token operator">=</span> l1<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>                l2 <span class="token operator">=</span> l2<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            cur <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 合并剩下的尾部</span>        cur<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> l1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">?</span> l1 <span class="token operator">:</span> l2<span class="token punctuation">;</span>        <span class="token keyword">return</span> dum<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220505081837195.png" alt="image-20220505081837195"></p><p><strong>2.递归求解</strong></p><p>此方法较耗时</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">&lt;</span> l2<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            l1<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                     <span class="token keyword">else</span>         <span class="token punctuation">{</span>            l2<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> l2<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220505082252207.png" alt="image-20220505082252207"></p><hr><h3 id="2-两个链表的第一个公共节点"><a href="#2-两个链表的第一个公共节点" class="headerlink" title="2.两个链表的第一个公共节点"></a>2.两个链表的第一个公共节点</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220505082342886.png" alt="image-20220505082342886"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220505082547330.png" alt="image-20220505082547330"></p><p><strong>解题思路</strong>:</p><p>1.差值法：</p><ul><li>先对两条链表进行遍历，分别得到两条链表的长度，并计算差值 d。</li><li>让长度较长的链表先走 d 步，然后两条链表同时走，第一个相同的节点即是节点。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode <span class="token operator">*</span><span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>headA<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode<span class="token operator">*</span> p <span class="token operator">=</span> headA<span class="token punctuation">;</span>        ListNode<span class="token operator">*</span> q <span class="token operator">=</span> headB<span class="token punctuation">;</span>        <span class="token keyword">int</span> la_len <span class="token operator">=</span> <span class="token function">getNodeLength</span><span class="token punctuation">(</span>headA<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> lb_len <span class="token operator">=</span> <span class="token function">getNodeLength</span><span class="token punctuation">(</span>headB<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">abs</span><span class="token punctuation">(</span>la_len <span class="token operator">-</span> lb_len<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>la_len <span class="token operator">-</span> lb_len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>  p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>lb_len <span class="token operator">-</span> la_len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> q <span class="token operator">=</span> q<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">)</span>         <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> p <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            q <span class="token operator">=</span> q<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">getNodeLength</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> anyNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>anyNode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        ListNode <span class="token operator">*</span> p <span class="token operator">=</span> anyNode<span class="token punctuation">;</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> p<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            length <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> length<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220505084816737.png" alt="image-20220505084816737"></p><p>优化解法:</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220505085406152.png" alt="image-20220505085406152"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode <span class="token operator">*</span><span class="token function">getIntersectionNode</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>headA<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>headB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>A <span class="token operator">=</span> headA<span class="token punctuation">,</span> <span class="token operator">*</span>B <span class="token operator">=</span> headB<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>A <span class="token operator">!=</span> B<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            A <span class="token operator">=</span> A <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">?</span> A<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">:</span> headB<span class="token punctuation">;</span>            B <span class="token operator">=</span> B <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">?</span> B<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">:</span> headA<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> A<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220505085541742.png" alt="image-20220505085541742"></p><blockquote><p>  无需考虑链表长度, 当两链表有相交时, <code>A  = headA = headB = B</code>即为交点, 若无交点, 则A, B都指向nullptr</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十二天-双指针-简单&quot;&gt;&lt;a href=&quot;#第十二天-双指针-简单&quot; class=&quot;headerlink&quot; title=&quot;第十二天_双指针(简单)&quot;&gt;&lt;/a&gt;第十二天_双指针(简单)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href=&quot;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程进阶二</title>
    <link href="https://roranrui.cn/posts/351142c7/"/>
    <id>https://roranrui.cn/posts/351142c7/</id>
    <published>2022-05-04T15:03:50.000Z</published>
    <updated>2022-05-06T15:53:06.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程进阶-二"><a href="#多线程进阶-二" class="headerlink" title="多线程进阶(二)"></a>多线程进阶(二)</h1><h2 id="一-原子操作-std-atomic"><a href="#一-原子操作-std-atomic" class="headerlink" title="一. 原子操作 std::atomic"></a>一. 原子操作 std::atomic</h2><h3 id="1-原子操作概念引出范例："><a href="#1-原子操作概念引出范例：" class="headerlink" title="1. 原子操作概念引出范例："></a>1. 原子操作概念引出范例：</h3><blockquote><p>  互斥量：<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&amp;spm=1001.2101.3001.7020">多线程</a>编程中 用于保护共享数据：先锁住， 操作共享数据， 解锁。</p></blockquote><p>有两个线程，对一个变量进行操作，一个线程读这个变量的值，一个线程往这个变量中写值。</p><p>即使是一个简单变量的读取和写入操作，如果不加锁，也有可能会导致读写值混乱（一条C语句会被拆成3、4条汇编语句来执行，所以仍然有可能混乱）</p><h3 id="2-基本的std-atomic用法范例"><a href="#2-基本的std-atomic用法范例" class="headerlink" title="2. 基本的std::atomic用法范例"></a>2. 基本的std::atomic用法范例</h3><blockquote><p>  可以把原子操作理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。</p></blockquote><p><strong>原子操作：在多线程中不会被打断的程序执行片段。</strong></p><p>从效率上来说，原子操作要比互斥量的方式效率要高。</p><p>互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量。</p><p>原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，不可能出现半完成状态。</p><p>std::atomic来代表原子操作，是个类模板。其实std::atomic是用来封装某个类型的值的</p><p>需要添加<code>#include &lt;atomic&gt;</code></p><p><strong>未使用原子操作:</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;future></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  * @brief 线程入口函数  * @param 无  * @retval 无  */</span><span class="token keyword">void</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main thread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t2</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"理论结果: 2000000"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"实际结果: "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504231352549.png" alt="image-20220504231352549"></p><p>可以看到程序不稳定, 可使用mutex来解决:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        my_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        my_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是使用mutex效率低…</p><p>所以, 引出新的操作:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  * @brief 线程入口函数  * @param 无  * @retval 无  */</span><span class="token keyword">void</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> count<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main thread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t2</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"理论结果: 2000000"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\t实际结果: "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504231832324.png" alt="image-20220504231832324"></p><p>注意: </p><p><strong>原子操作一般用于操作单个变量, 而涉及多个变量的, 还是要使用互斥量</strong></p><blockquote><p>  <strong>原子操作一般是指不可分割的操作, 这种操作没用中间状态, 只有完成和没完成状态</strong></p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;atomic></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">g_ifEnd</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//封装了一个类型为bool的 对象（值）</span><span class="token keyword">void</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>g_ifEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id = "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"运行中"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread id = "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"运行结束"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>    g_ifEnd <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"程序执行完毕"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  上述程序中, 如果count++ 换成 count = count + 1, 则结果仍会出现错误</p></blockquote><p>一般atomic原子操作，针对<code>++，--，+=，-=，&amp;=，|=，^=</code>是支持的，其他操作不一定支持。</p><hr><h2 id="二-std-async深入理解"><a href="#二-std-async深入理解" class="headerlink" title="二. std::async深入理解"></a>二. std::async深入理解</h2><h3 id="1-std-async参数详述"><a href="#1-std-async参数详述" class="headerlink" title="1. std::async参数详述"></a>1. std::async参数详述</h3><p>async 用来创建一个<strong>异步任务</strong></p><ul><li>std::launch::deferred【延迟调用】</li><li>std::launch::async【强制创建一个线程】</li></ul><blockquote><p>  std::async()我们一般不叫创建线程（他能够创建线程），我们一般叫它创建一个异步任务。</p><p>  std::async和std::thread最明显的不同，就是 async 有时候并不创建新线程。</p></blockquote><h4 id="①如果用std-launch-deferred-来调用async"><a href="#①如果用std-launch-deferred-来调用async" class="headerlink" title="①如果用std::launch::deferred 来调用async"></a>①如果用std::launch::deferred 来调用async</h4><p>延迟到调用 get() 或者 wait() 时执行，如果不调用就不会执行</p><h4 id="②如果用std-launch-async来调用async"><a href="#②如果用std-launch-async来调用async" class="headerlink" title="②如果用std::launch::async来调用async"></a>②如果用std::launch::async来调用async</h4><p><strong>强制</strong>这个异步任务在新线程上执行，这意味着，系统必须要创建出新线程来运行入口函数。</p><h4 id="③如果同时用-std-launch-async-std-launch-deferred"><a href="#③如果同时用-std-launch-async-std-launch-deferred" class="headerlink" title="③如果同时用 std::launch::async | std::launch::deferred"></a>③如果同时用 std::launch::async | std::launch::deferred</h4><p>这里这个 | 意味着async的行为可能是 std::launch::async 创建新线程立即执行， 也可能是 std::launch::deferred 没有创建新线程并且延迟到调用get()执行，由<strong>系统根据实际情况来决定</strong>采取哪种方案</p><h4 id="④不带额外参数-std-async-mythread"><a href="#④不带额外参数-std-async-mythread" class="headerlink" title="④不带额外参数 std::async(mythread)"></a>④不带额外参数 std::async(mythread)</h4><p>只给async 一个入口函数名，此时的系统给的默认值是 std::launch::async | std::launch::deferred 和 ③ 一样，有系统自行决定<strong>异步</strong>还是<strong>同步</strong>运行。</p><hr><h3 id="2-std-async和std-thread-区别"><a href="#2-std-async和std-thread-区别" class="headerlink" title="2. std::async和std::thread()区别"></a>2. std::async和std::thread()区别</h3><blockquote><ul><li>std::thread()如果系统资源紧张可能出现创建线程失败的情况，如果创建线程失败那么程序就可能崩溃，而且不容易拿到函数返回值（不是拿不到）</li><li>std::async()创建异步任务。可能创建线程也可能不创建线程，并且容易拿到线程入口函数的返回值；</li></ul></blockquote><p>由于系统资源限制：</p><ul><li>①如果用std::thread创建的线程太多，则可能创建失败，系统报告异常，崩溃。</li><li>②如果用std::async，一般就不会报异常，因为如果系统资源紧张，无法创建新线程的时候，async不加额外参数的调用方式就不会创建新线程。而是在后续调用get()请求结果时执行在这个调用get()的线程上。</li></ul><blockquote><p>  如果你强制async一定要创建新线程就要使用 std::launch::async 标记。承受的代价是，系统资源紧张时可能崩溃。</p></blockquote><ul><li>③根据经验，一个程序中线程数量 不宜超过100~200 。</li></ul><hr><h3 id="3-async不确定性问题的解决"><a href="#3-async不确定性问题的解决" class="headerlink" title="3. async不确定性问题的解决"></a>3. async不确定性问题的解决</h3><blockquote><p>  不加额外参数的async调用时让系统自行决定，是否创建新线程。</p></blockquote><p><code>std::future&lt;int&gt; result = std::async(mythread);</code><br>问题焦点在于这个写法，任务到底有没有被推迟执行。</p><p>通过wait_for返回状态来判断：</p><pre class="line-numbers language-cpp"><code class="language-cpp">std<span class="token operator">::</span>future_status status <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/// std::future_status status = result.wait_for(6s);</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//超时：表示线程还没有执行完</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"超时了，线程还没有执行完"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//表示线程成功放回</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程执行成功，返回"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>deferred<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程延迟执行"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程进阶-二&quot;&gt;&lt;a href=&quot;#多线程进阶-二&quot; class=&quot;headerlink&quot; title=&quot;多线程进阶(二)&quot;&gt;&lt;/a&gt;多线程进阶(二)&lt;/h1&gt;&lt;h2 id=&quot;一-原子操作-std-atomic&quot;&gt;&lt;a href=&quot;#一-原子操作-std-ato</summary>
      
    
    
    
    <category term="多线程" scheme="https://roranrui.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="多线程编程" scheme="https://roranrui.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>视频拍摄频闪解决方案</title>
    <link href="https://roranrui.cn/posts/9c58482b/"/>
    <id>https://roranrui.cn/posts/9c58482b/</id>
    <published>2022-05-04T13:58:06.000Z</published>
    <updated>2022-05-07T15:11:06.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视频频闪的快速解决方案"><a href="#视频频闪的快速解决方案" class="headerlink" title="视频频闪的快速解决方案"></a>视频频闪的快速解决方案</h1><blockquote><p>  文章转载自: <a href="https://extremeer.github.io/media/ff2c776f/">Extremeer 极振科技传媒工作室</a></p><p>  作者: Marzzz 已授权</p></blockquote><hr><blockquote><p>  在拍摄视频时，有时镜头前的灯光或屏幕录制下来后会有相应频闪，灯光忽明忽暗。频闪与帧率、快门速度、用电频率的关系息息相关。本文所指频闪只是由于交流电频率导致的频闪，LED与屏幕刷新率等频闪不在此考虑范畴内。</p></blockquote><h2 id="1-小白方案"><a href="#1-小白方案" class="headerlink" title="1. 小白方案"></a>1. 小白方案</h2><p>对于不想深入了解的同学，可以直接套用下列方案来规避大部分频闪。</p><table><thead><tr><th>所在地区</th><th>设置帧率</th><th>快门速度（可选）</th></tr></thead><tbody><tr><td>中国及欧亚的大多数地区</td><td>25fps；50fps</td><td>1/50；1/100</td></tr><tr><td>北美、日本、韩国等地区</td><td>30fps；60fps</td><td>1/60；1/120</td></tr></tbody></table><hr><h2 id="2-高阶方案"><a href="#2-高阶方案" class="headerlink" title="2. 高阶方案"></a>2. 高阶方案</h2><h3 id="①-用电频率"><a href="#①-用电频率" class="headerlink" title="① 用电频率"></a>① 用电频率</h3><p>交流电的频率和性质决定了灯光会一明一暗的进行交变脉冲，Hz表示每秒交变几次。交流电频率50Hz，周期0.02s，在电流整流后电路将后半个周期电流反向，从而使灯光脉冲频率为100Hz，周期为0.01s。</p><p>不同地区的用电频率是不一样的，这也导致出现了不同的视频制式来适应不同的频率。</p><p>地区用电频率视频制式常见帧率<br>欧洲和亚洲的大多数地区50HzPAL25fps; 50fps<br>北美、日本、韩国等地区60HzNTSC30fps; 60fps<br>在人眼前这种脉冲闪烁也许非常微小甚至完全无法感受到，但对于手机及相机来说有时设置不当这种脉冲就会十分明显。</p><h3 id="②-帧率（FPS）"><a href="#②-帧率（FPS）" class="headerlink" title="② 帧率（FPS）"></a>② 帧率（FPS）</h3><blockquote><p>  帧率，用于测量显示帧数的量度。FPS（Frames Per Second）指每秒拍摄的帧数。一般说，帧率影响画面流畅度，帧率越大，画面越流畅；帧率越小，画面越有跳动感。</p></blockquote><p>当快门速度一定且与光闪烁频率无整除关系时：</p><ul><li>帧率与光闪烁频率若有倍数关系，每一帧的起始采样点就相同，那么在相同快门的情况下每一帧的亮度就相同。</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504220941910.png" alt="image-20220504220941910"></p><p>​红色面积的横轴代表快门速度，红色面积代表每一帧的进光量<br>​数字位置代表每一帧的开始，两个数字的间隔代表每一帧<br>​<strong>可以看到每一帧的亮度是相同的</strong></p><ul><li>反之，帧率与光闪烁频率若无倍数关系，每一帧的起始采样点就不同，每一帧的亮度就不同而造成频闪。</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504221251359.png" alt="image-20220504221251359"></p><p>​红色面积的横轴代表快门速度，红色面积代表每一帧的进光量<br>​数字位置代表每一帧的开始，两个数字的间隔代表每一帧<br>​<strong>可以看到每一帧的亮度是不同的</strong><br>​而在规避频闪的方法中，匹配帧率通常是最简单的。</p><p><strong>帧率方案：设置帧率，让光源闪烁频率被这个帧率整除。</strong></p><blockquote><p>   假设在中国PAL制式下拍摄视频，因为用电频率是50Hz，光闪烁频率为100Hz，则大多数时候只需要设置25或者50fps，就能在多数情况下避免频闪。</p><p>  如果在如北美NTSC制式下拍摄视频，就相应选择30或者60fps。</p></blockquote><h3 id="③-快门速度（不推荐）"><a href="#③-快门速度（不推荐）" class="headerlink" title="③ 快门速度（不推荐）"></a>③ 快门速度（不推荐）</h3><blockquote><p>  快门速度，指的是相机快门进行一次开启到闭合的时间。</p></blockquote><p>当帧率一定且与光闪烁频率无整除关系时：</p><ul><li>若快门速度与光闪烁频率有倍数关系，那么每一帧曝光的时候进光量就会固定等于一周期的量从而稳定无频闪。</li></ul><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504221314818.png" alt="image-20220504221314818"></p><ul><li>反之，若快门速度与光闪烁频率无倍数关系，那么每一帧曝光的时候进光量就会受光闪烁的不同时刻影响导致每一帧亮度不同从而造成频闪。</li></ul><p>​<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504221415493.png" alt="image-20220504221415493"><br><strong>快门方案：设置快门速度，让光源闪烁频率被这个快门速度整除。</strong></p><p>如：中国供电频率50Hz，光闪烁频率为100Hz，将快门速度设定为1/50或1/100即可解决。</p><p>这个选项通常不好确定。在调整快门速度的同时，你也要避免慢速快门而导致运动模糊的产生。</p><h3 id="④-帧率与快门速度的混合运用"><a href="#④-帧率与快门速度的混合运用" class="headerlink" title="④ 帧率与快门速度的混合运用"></a>④ 帧率与快门速度的混合运用</h3><ol><li>通常，在中国使用PAL制（即fps调整到25或50），无论多少快门速度都不会产生频闪。原因是相机的采样间隔是和灯光的周期是同步的，例如50帧的时候采样周期是20ms，是灯光周期10ms的整数倍，在每一个周期内，采样的起始点是一样的。所以无论多少快门速度，每一帧的亮度都是相同的。</li><li>而在中国使用NTSC制（即fps调整到30或60），假如视频帧率为60帧，意味着每次采样的时间点是在这个周期中的不同地方，这时只有快门速度等于光闪频率的倍数的时候才不会有频闪。</li><li>实际上，以部分索尼相机为例，在人造光源下，索尼相机的快门速度最高到1/100，如果超过1/100，如1/2500，虽然也是50Hz的整数倍，但在NTSC制下，仍然会出现频闪，甚至1/125都会。</li><li>PAL制下也并不能为所欲为，过高的快门速度，画面上会出现不明显的明暗条带，从上至下规律移动，且随着快门升高，画面上会出现细小的横纹。</li></ol><hr><h2 id="3-插件方案"><a href="#3-插件方案" class="headerlink" title="3.插件方案"></a>3.插件方案</h2><p>如果素材已经拍摄，则可以使用相关插件进行后期补救。</p><ul><li>如果使用Adobe Premiere Pro或Adobe After Effects，则可以使用插件DEFlicker进行消除。（需要下载）。</li><li>如果使用达芬奇Davinci Resolve在版本14以上可以使用自带效果去闪烁。</li></ul><p><strong>但请注意一切后期都不如前期做好准备。</strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;视频频闪的快速解决方案&quot;&gt;&lt;a href=&quot;#视频频闪的快速解决方案&quot; class=&quot;headerlink&quot; title=&quot;视频频闪的快速解决方案&quot;&gt;&lt;/a&gt;视频频闪的快速解决方案&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  文章转载自: &lt;a href=&quot;htt</summary>
      
    
    
    
    <category term="视频相关" scheme="https://roranrui.cn/categories/%E8%A7%86%E9%A2%91%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="经验分享" scheme="https://roranrui.cn/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    <category term="视频制作" scheme="https://roranrui.cn/tags/%E8%A7%86%E9%A2%91%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>第十一天_双指针(简单)</title>
    <link href="https://roranrui.cn/posts/cba4720/"/>
    <id>https://roranrui.cn/posts/cba4720/</id>
    <published>2022-05-04T09:56:45.000Z</published>
    <updated>2022-05-06T16:03:45.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一天-双指针-简单"><a href="#第十一天-双指针-简单" class="headerlink" title="第十一天_双指针(简单)"></a>第十一天_双指针(简单)</h1><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><p>严格的来说，双指针只能说是是算法中的一种技巧。</p><blockquote><p>  双指针指的是在<a href="https://so.csdn.net/so/search?q=%E9%81%8D%E5%8E%86&amp;spm=1001.2101.3001.7020">遍历</a>对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（<strong>快慢指针</strong>）或者相反方向（<strong>对撞指针</strong>）的指针进行扫描，从而达到相应的目的。</p></blockquote><h3 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h3><p><strong>对撞指针</strong>是指在数组中，将指向最左侧的索引定义为<code>左指针（left）</code>，最右侧的定义为<code>右指针（right）</code>，然后从两头向中间进行数组遍历。快速排序就是典型的双指针问题。</p><p>我们假设数组名字为 nums，数组长度为 n，数组首元素对应的位置为 0。</p><p><strong>细节:</strong></p><ul><li>指针初始位置<ul><li>左指针（left)一般指向数组的第一个元素。即 left = 0。</li><li>右指针（right)一般指向数组的第一个元素。即 right = n-1。</li></ul></li></ul><p>​</p><ul><li><p><strong>指针移动方法</strong></p><ul><li>左指针(left）向右边👉移动，一般每次移动一个位置，即 left++。</li><li>右指针(right）向左边👈移动，一般每次移动一个位置，即 right–。</li></ul></li><li><p><strong>结束条件</strong></p><ul><li>左指针（left）位置和右指针（right）位置逆序。</li></ul></li></ul><p>从上面的描述可知，开始的时候，right &gt;= left。因此结束的条件就是 right &lt; left。</p><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>快慢指针是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如快指针（fast）每次增长两个，慢指针（slow）每次增长一个。</p><p>一般来说，快慢指针常用于判断链表等数据结构中是否有环。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/aHR0cHM6Ly9hc3NldHMubGVldGNvZGUtY24uY29tL2FsaXl1bi1sYy11cGxvYWQvdXBsb2Fkcy8yMDE4LzEyLzA3L2NpcmN1bGFybGlua2VkbGlzdC5wbmc" alt="img"></p><p><strong>细节</strong>:</p><ul><li><p>指针初始位置</p><ul><li>慢指针（slow）一般指向数组的第一个元素。即 slow = 0。</li><li>快指针（fast）一般指向数组的第一个元素。即 fast = 1。</li></ul></li><li><p>指针移动方法</p><ul><li><p>慢指针（slow）向右边👉移动，一般每次移动一个位置，即 slow++。</p></li><li><p>快指针（fast）向右边👉移动，一般每次移动两个个位置，即 fast += 2。</p></li></ul></li><li><p>结束条件</p><ul><li>慢指针（slow）位置和快指针（fast）位置重合；快指针（fast）达到数组的最后一个元素。</li></ul></li></ul><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-删除链表的节点"><a href="#1-删除链表的节点" class="headerlink" title="1. 删除链表的节点"></a>1. 删除链表的节点</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504180845519.png" alt="image-20220504180845519"></p><p><strong>解题思路:</strong></p><p>本题删除值为 val 的节点分需为两步：定位节点、修改引用。</p><p>定位节点： 遍历链表，直到 head.val == val 时跳出，即可定位目标节点。<br>修改引用： 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；则执行 pre.next = cur.next ，即可实现删除 cur 节点。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/1613757478-NBOvjn-Picture1.png" alt="Picture1.png"></p><blockquote><p>  算法流程：<br>  特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。<br>  初始化： pre = head , cur = head.next 。<br>  定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。<br>  保存当前节点索引，即 pre = cur 。<br>  遍历下一节点，即 cur = cur.next 。<br>  删除节点： 若 cur 指向某节点，则执行 pre.next = cur.next ；若 cur 指向 null ，代表链表中不包含值为 val 的节点。<br>  返回值： 返回链表头部节点 head 即可。</p></blockquote><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>pre <span class="token operator">=</span> head<span class="token punctuation">,</span> <span class="token operator">*</span>cur <span class="token operator">=</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">!=</span> val<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> pre<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504181829187.png" alt="image-20220504181829187"></p><hr><h3 id="2-链表中倒数第-k-个节点"><a href="#2-链表中倒数第-k-个节点" class="headerlink" title="2. 链表中倒数第 k 个节点"></a>2. 链表中倒数第 k 个节点</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504181656331.png" alt="image-20220504181656331"></p><p><strong>解题思路：</strong></p><p>先遍历统计链表长度，记为 n ；<br>设置一个指针走 (n-k)步，即可找到链表倒数第 k 个节点；<br>使用双指针则可以不用统计链表长度。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/1600794523-AAMvoP-Picture1.png" alt="Picture1.png"></p><p><strong>算法流程简单, 略</strong></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>former<span class="token punctuation">,</span> <span class="token operator">*</span>latter<span class="token punctuation">;</span>        former <span class="token operator">=</span> latter <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            former <span class="token operator">=</span> former<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>former <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            former <span class="token operator">=</span> former<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            latter <span class="token operator">=</span> latter<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> latter<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504181816417.png" alt="image-20220504181816417"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十一天-双指针-简单&quot;&gt;&lt;a href=&quot;#第十一天-双指针-简单&quot; class=&quot;headerlink&quot; title=&quot;第十一天_双指针(简单)&quot;&gt;&lt;/a&gt;第十一天_双指针(简单)&lt;/h1&gt;&lt;h2 id=&quot;一-知识学习&quot;&gt;&lt;a href=&quot;#一-知识学习&quot; c</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记一</title>
    <link href="https://roranrui.cn/posts/44e644ae/"/>
    <id>https://roranrui.cn/posts/44e644ae/</id>
    <published>2022-05-03T14:48:29.000Z</published>
    <updated>2022-05-06T15:46:16.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCV学习笔记"><a href="#OpenCV学习笔记" class="headerlink" title="OpenCV学习笔记"></a>OpenCV学习笔记</h1><blockquote><p>  基于OpenCV 4.5.4</p><p>  参考自: 《OpenCV3编程入门——毛星云》</p></blockquote><h2 id="一-OpenCV基础"><a href="#一-OpenCV基础" class="headerlink" title="一. OpenCV基础"></a>一. OpenCV基础</h2><h3 id="1-基础图像容器Mat"><a href="#1-基础图像容器Mat" class="headerlink" title="1. 基础图像容器Mat"></a>1. 基础图像容器Mat</h3><blockquote><p>  Mat 是一个类，有两个数据部分组成，矩阵头（包含矩阵尺寸、存储方法、存储地址等信息）和一个指向所有存储像素值的矩阵。</p></blockquote><p>拷贝构造函数和赋值运算符只复制信息头，与原对象共用一个矩阵，若改一个，则都受影响。<br>使用函数<code>clone()</code>或<code>copyTo()</code>可以复制矩阵。</p><p><strong>使用Mat创建图像</strong><br><code>Mat M = (2, 2, CV_8UC3, Scalar(0, 0, 255));</code></p><p>参数解释:</p><ul><li>2，2为二维矩阵的大小</li><li>CV_[位数][带符号与否][类型前缀]C[通道数]</li><li>Scalar(a,b,c,d)四个参数，是一个类。表示颜色</li><li>在RGB中，前三个依次为B,G,R，最后一个可不写。</li></ul><h3 id="2-常用数据结构"><a href="#2-常用数据结构" class="headerlink" title="2. 常用数据结构"></a>2. 常用数据结构</h3><h4 id="Point类"><a href="#Point类" class="headerlink" title="Point类"></a>Point类</h4><blockquote><p>  用于表示一个点</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">Point point<span class="token punctuation">;</span>point<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>point<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>Point <span class="token function">point</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Scalar类"><a href="#Scalar类" class="headerlink" title="Scalar类"></a>Scalar类</h4><blockquote><p>  颜色表示</p></blockquote><p><code>Scalar（0，0，255）</code> 依次是B, G, R的值(OpenCV存储RGB的顺序是BGR)</p><h4 id="Size类"><a href="#Size类" class="headerlink" title="Size类"></a>Size类</h4><blockquote><p>  用于表示图像的宽和高</p></blockquote><p><code>Size（5，5）</code>表示宽高都为5</p><h4 id="Rect类"><a href="#Rect类" class="headerlink" title="Rect类"></a>Rect类</h4><p>Rect类的成员变量有下:</p><ul><li><strong>x, y, width, height, 分别为左上角点的坐标和矩形的宽和高。</strong></li></ul><p>常用的成员函数有：</p><ul><li>Size()返回值为Size();</li><li>area()返回矩形的面积。</li><li>Constrins(Point)判断点是否在矩形内；</li><li>inside（Rect）函数判断矩形是否在矩形内；</li><li>tl()返回左上角点的坐标；</li><li>br()返回右下角点的坐标。还可对矩形进行交集、并集、平移和缩放操作。</li></ul><h4 id="RotateRect类"><a href="#RotateRect类" class="headerlink" title="RotateRect类*"></a>RotateRect类*</h4><blockquote><p>  RotatedRect是一个存储旋转矩形的类，通常用来存储最小外包矩形函数minAreaRect( )和椭圆拟合函数fitEllipse( )返回的结果。存储的值，完全取决在于函数的返回</p></blockquote><p><strong>类的声明:</strong>              </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">RotatedRect</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span><span class="token operator">:</span>                    <span class="token function">RotatedRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//构造函数</span>        <span class="token function">RotatedRect</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point2f<span class="token operator">&amp;</span> center<span class="token punctuation">,</span> <span class="token keyword">const</span> Size2f<span class="token operator">&amp;</span> size<span class="token punctuation">,</span> <span class="token keyword">float</span> angle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">RotatedRect</span><span class="token punctuation">(</span><span class="token keyword">const</span> CvBox2D<span class="token operator">&amp;</span> box<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token keyword">void</span> <span class="token function">points</span><span class="token punctuation">(</span>Point2f pts<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//返回矩形的4个顶点      </span>        Rect <span class="token function">boundingRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//返回包含旋转矩形的最小矩形     </span>        <span class="token keyword">operator</span> <span class="token function">CvBox2D</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//转换到旧式的cvbox2d结构</span>            <span class="token keyword">float</span> angle<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//旋转角度，当角度为0、90、180、270等时，矩形就成了一个直立的矩形  </span>        Point2f center<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//矩形的质心      </span>        Size2f size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//矩形的边长      </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OpenCV中，坐标的原点在左上角，与x轴平行的方向为角度为0，逆时针旋转角度为负，顺时针旋转角度为正 </p><h5 id="minAreaRect"><a href="#minAreaRect" class="headerlink" title="minAreaRect( )"></a>minAreaRect( )</h5><p>函数返回的参数，请看下图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/20170712170137455" alt="img"></p><p>角度参数angle 是矩形最下面的点（y坐标最大）P[0]发出的平行于x轴的射线，逆时针旋转，与碰到的第一个边的夹角（这个边的边长就作为width），取值范围[-90~0]。</p><h5 id="points-Point2f-pts"><a href="#points-Point2f-pts" class="headerlink" title="points(Point2f pts[])"></a>points(Point2f pts[])</h5><p>可以计算出矩形的四个角点。 计算出来的角点是 固定的顺序 ，如图所示。</p><blockquote><p>  在利用minAreaRect函数去求一个外接矩形时，函数对于矩形长和宽的选择取决于这个外接矩形的边与水平轴的角度距离，即将水平轴逆时针旋转，最先与其平行的边的长度作为宽度width，另外一条边则为height，而角度则直接取该边与水平轴的夹角。应该意识到，在minAreaRect函数中，RotatedRect的width和height的选取跟矩形的尺寸无关，并非长的就是height，短的就是width。</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OpenCV学习笔记&quot;&gt;&lt;a href=&quot;#OpenCV学习笔记&quot; class=&quot;headerlink&quot; title=&quot;OpenCV学习笔记&quot;&gt;&lt;/a&gt;OpenCV学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  基于OpenCV 4.5.4&lt;/p&gt;
&lt;p&gt; </summary>
      
    
    
    
    <category term="OpenCV学习笔记" scheme="https://roranrui.cn/categories/OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="OpenCv" scheme="https://roranrui.cn/tags/OpenCv/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记一</title>
    <link href="https://roranrui.cn/posts/832cf3b9/"/>
    <id>https://roranrui.cn/posts/832cf3b9/</id>
    <published>2022-05-03T13:25:30.000Z</published>
    <updated>2022-05-06T16:03:45.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS学习笔记一"><a href="#CSS学习笔记一" class="headerlink" title="CSS学习笔记一"></a>CSS学习笔记一</h1><blockquote><p>  文章转载至: MurphyChen’s Notes(<a href="https://docs.mphy.top/)%E4%BB%85%E4%BE%9B%E5%AD%A6%E4%B9%A0%E4%BA%A4%E6%B5%81%E4%BD%BF%E7%94%A8">https://docs.mphy.top/)仅供学习交流使用</a></p><p>  如有侵权, 请立即联系我删除!</p></blockquote><h2 id="1-CSS-简介"><a href="#1-CSS-简介" class="headerlink" title="1. CSS 简介"></a>1. CSS 简介</h2><h3 id="1-1-HTML-的局限性"><a href="#1-1-HTML-的局限性" class="headerlink" title="1.1 HTML 的局限性"></a>1.1 HTML 的局限性</h3><p>HTML 是网友的骨架，只关注内容的语义。例如<code>&lt;h1&gt;</code>表示大标题，<code>&lt;p&gt;</code>表示段落。</p><p>早期的时候，HTML 只能做一些简单的样式，网页非常丑，而且使 HTML 代码臃肿。</p><h3 id="1-2-CSS-网页的美容师"><a href="#1-2-CSS-网页的美容师" class="headerlink" title="1.2 CSS-网页的美容师"></a>1.2 CSS-网页的美容师</h3><p>CSS 是 层叠样式表（Cascading Style Sheets）的简称。</p><p>CSS 也是一种标记语言。</p><p>CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。</p><p>HTML 呈现结构，CSS 决定样式，结构与样式分离。</p><h3 id="1-2-CSS-语法规范"><a href="#1-2-CSS-语法规范" class="headerlink" title="1.2 CSS 语法规范"></a>1.2 CSS 语法规范</h3><p>CSS 规则由两个部分组成：选择器和一条或多条声明。</p><h3 id="1-3-CSS-代码风格"><a href="#1-3-CSS-代码风格" class="headerlink" title="1.3 CSS 代码风格"></a>1.3 CSS 代码风格</h3><ul><li>展开式</li><li>选择器，属性名，属性关键字全部小写</li><li>空格规范</li></ul><h2 id="2-CSS-基础选择器"><a href="#2-CSS-基础选择器" class="headerlink" title="2. CSS 基础选择器"></a>2. CSS 基础选择器</h2><h3 id="2-1-选择器的作用"><a href="#2-1-选择器的作用" class="headerlink" title="2.1 选择器的作用"></a>2.1 选择器的作用</h3><p>选择器就是根据不同需求把不同标签选择出来。</p><h3 id="2-2-选择器分类"><a href="#2-2-选择器分类" class="headerlink" title="2.2 选择器分类"></a>2.2 选择器分类</h3><p>选择器分为基础选择器和复合选择器两大类。</p><ul><li>基础选择器由单个选择器组成</li><li>基础选择器包括：标签选择器、类选择器、id 选择器和通配符选择器</li></ul><h3 id="2-3-标签选择器"><a href="#2-3-标签选择器" class="headerlink" title="2.3 标签选择器"></a>2.3 标签选择器</h3><p>直接用 HTML 标签名作为选择器，按标签名称分类，<strong>为页面某一类标签指定统一的 CSS 样式。</strong></p><p>语法</p><pre class="line-numbers language-HTML"><code class="language-HTML">标签名 {    属性1： 属性值1;    属性2： 属性值2;    属性3： 属性值3;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点 标签选择器可以把某一标签全部选择出来，快速为同类型标签设置统一样式。</p><p>缺点 不能设置差异化样式，只能选择全部当前标签。</p><h3 id="2-4-类选择器"><a href="#2-4-类选择器" class="headerlink" title="2.4 类选择器"></a>2.4 类选择器</h3><p>差异化选择不同标签，单独选一个或者某个标签。</p><p>语法</p><p>使用 <code>class</code> 属性来调用 class 类，样式点定义，结构类调用，一个或多个，开发最常用。</p><p>类选择器用 <code>.</code> 号显示。</p><p>注意</p><ol><li>类选择器用 <code>.</code> 标识，紧跟类名。</li><li>小写，使用 <code>-</code> 连接单词。</li><li>不要用纯数字、中文。</li><li>命名有意义。</li></ol><h3 id="2-4-1-类选择器-多类名"><a href="#2-4-1-类选择器-多类名" class="headerlink" title="2.4.1 类选择器-多类名"></a>2.4.1 类选择器-多类名</h3><p>类名间用空格分开</p><pre class="line-numbers language-HTML"><code class="language-HTML"><p class="class-name1 class-name2"></p><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-5-id-选择器"><a href="#2-5-id-选择器" class="headerlink" title="2.5 id 选择器"></a>2.5 id 选择器</h3><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p><p>HTML 元素以 id 属性来设置 id 选择器，用 <code>#</code> 来定义。</p><pre class="line-numbers language-HTML"><code class="language-HTML">#id名 {    属性1: 属性值1;    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>样式 <code>#</code> 定义，结构 id 调用，别人切勿使用。</p><p>id 选择器与类选择器的区别</p><ol><li>类选择器可以被多个元素调用。</li><li>id 选择器只能允许一个标签调用。</li><li>类选择器使用的较多，id 选择器用于唯一特性的标签。</li></ol><h3 id="2-6-通配符选择器"><a href="#2-6-通配符选择器" class="headerlink" title="2.6 通配符选择器"></a>2.6 通配符选择器</h3><p>语法</p><pre class="line-numbers language-HTML"><code class="language-HTML">* {    属性1: 属性值1;    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用 <code>*</code> 定义通配符选择器，选取页面中所有标签。</li><li>不需要调用，自动给所有标签。</li><li>特殊情况使用</li></ul><pre class="line-numbers language-HTML"><code class="language-HTML">* {    margin: 0;    padding: 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-基础选择器总结"><a href="#2-7-基础选择器总结" class="headerlink" title="2.7 基础选择器总结"></a>2.7 基础选择器总结</h3><table><thead><tr><th>基础选择器</th><th>作用</th><th>特点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>选中所有相同标签</td><td>不能差异化选择</td><td>较多</td><td><code>p{color:red;}</code></td></tr><tr><td>类选择器</td><td>选出一个或多个标签</td><td>可以根据需求选择</td><td>较多</td><td><code>.nav {color: red;}</code></td></tr><tr><td>id 选择器</td><td>一次只能选出一个标签</td><td>一个 id 属性在页面中只能出现一次</td><td>一般配合 js 使用</td><td><code>#nav {color: red;}</code></td></tr><tr><td>通配符选择器</td><td>选择所有标签元素</td><td>选择的太多，有部分不需要</td><td>特殊情况使用</td><td><code>* {color: red; }</code></td></tr></tbody></table><ul><li>每个选择器都有自己的使用场景，都要掌握。</li><li>如果是修改样式，类选择器是使用最多的。</li></ul><h2 id="3-CSS-字体属性"><a href="#3-CSS-字体属性" class="headerlink" title="3. CSS 字体属性"></a>3. CSS 字体属性</h2><h3 id="3-1-字体系列"><a href="#3-1-字体系列" class="headerlink" title="3.1 字体系列"></a>3.1 字体系列</h3><p>CSS 使用 <code>font-family</code> 属性定义文本字体系列。 尽量使用默认字体，保证不同浏览器的兼容性。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">body </span><span class="token punctuation">{</span>  <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">"微软雅黑"</span>, Arial, Helvetica, sans-serif<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-2-字体大小"><a href="#3-2-字体大小" class="headerlink" title="3.2 字体大小"></a>3.2 字体大小</h3><p>CSS 使用 <code>font-size</code> 属性定义字体大小。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">body </span><span class="token punctuation">{</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">16</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>px</code> 大小是我们网页常用单位</li><li>谷歌浏览器默认是 <code>16px</code></li><li>可以给 <code>body</code> 指定整个页面文字大小</li></ul><h3 id="3-3-字体粗细"><a href="#3-3-字体粗细" class="headerlink" title="3.3 字体粗细"></a>3.3 字体粗细</h3><p>CSS 使用 <code>font-weight</code> 属性设置字体粗细</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">p </span><span class="token punctuation">{</span>  <span class="token property">font-weight</span><span class="token punctuation">:</span> <span class="token number">700</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实际开发中，更常用数字来表示加粗或变细。<code>400</code>为<code>normal</code>，<code>700</code> 为 <code>bold</code>。 |属性值|描述| |-|-| |normal|默认值| |bold|定义粗体| |100-900|400 等价于 normal，700 等价于 bold，无单位|</p><h3 id="3-4-文字样式"><a href="#3-4-文字样式" class="headerlink" title="3.4 文字样式"></a>3.4 文字样式</h3><p>CSS 使用 <code>font-style</code> 属性设置文本风格。</p><pre class="line-numbers language-html"><code class="language-html">p { font-style: italic; }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>正常显示</td></tr><tr><td>italic</td><td><em>斜体</em></td></tr></tbody></table><p>注意：平常很少给字体加斜体，而是给斜体标签（em,i）给位不倾斜字体。</p><h3 id="3-5-字体复合属性写法"><a href="#3-5-字体复合属性写法" class="headerlink" title="3.5 字体复合属性写法"></a>3.5 字体复合属性写法</h3><p>将各种字体属性写在同一选择器下，节约代码。</p><p>规则</p><p>严格遵守顺序，且 <code>font-sieze</code> 和 <code>font-family</code> 必须有。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">body </span><span class="token punctuation">{</span>  <span class="token property">font</span><span class="token punctuation">:</span> font-style font-weight font-size/line-hight font-family<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-6-字体属性总结"><a href="#3-6-字体属性总结" class="headerlink" title="3.6 字体属性总结"></a>3.6 字体属性总结</h3><table><thead><tr><th>字体属性</th><th>表示</th><th>注意</th></tr></thead><tbody><tr><td>font-size</td><td>字号</td><td>单位是 <code>px</code></td></tr><tr><td>font-family</td><td>字体</td><td>按照团队约定来写</td></tr><tr><td>font-weight</td><td>字体粗细</td><td>400=normal，700=bold</td></tr><tr><td>font-style</td><td>字体样式</td><td>italic，normal，常用 normal</td></tr><tr><td>font</td><td>属性连写</td><td>顺序不能变，字体和字号属性必须有</td></tr></tbody></table><h2 id="4-CSS-文本属性"><a href="#4-CSS-文本属性" class="headerlink" title="4. CSS 文本属性"></a>4. CSS 文本属性</h2><p>CSS Text（文本）属性定义文本外观，比如颜色、对齐、装饰、缩进、行间距等。</p><h3 id="4-1-文本颜色"><a href="#4-1-文本颜色" class="headerlink" title="4.1 文本颜色"></a>4.1 文本颜色</h3><p><code>color</code> 属性定义文本颜色。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div </span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>属性值 |表示颜色|属性值| |-|-| |预定义的颜色值|red,green,pink| |十六进制|#FF0000，#FF6600| |RGB 代码|rgb(255,0,0)|</p><p>实际开发中，最常用的是十六进制。</p><h3 id="4-2-对齐文本"><a href="#4-2-对齐文本" class="headerlink" title="4.2 对齐文本"></a>4.2 对齐文本</h3><p><code>text-align</code> 属性用于设置元素文本内容的对齐方式。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div </span><span class="token punctuation">{</span>  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>属性值</th><th>解释</th></tr></thead><tbody><tr><td>left</td><td>左对齐（默认）</td></tr><tr><td>right</td><td>右对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr></tbody></table><h3 id="4-3-装饰文本"><a href="#4-3-装饰文本" class="headerlink" title="4.3 装饰文本"></a>4.3 装饰文本</h3><p><code>text-decoration</code> 属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token property">text-decoration</span><span class="token punctuation">:</span> underline<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认，无装饰（最常用）</td></tr><tr><td>underline</td><td>下划线，a 标签自带（常用）</td></tr><tr><td>overline</td><td>上划线。（几乎不用）</td></tr><tr><td>line-through</td><td>删除线。（不常用）</td></tr></tbody></table><h3 id="4-4-文本缩进"><a href="#4-4-文本缩进" class="headerlink" title="4.4 文本缩进"></a>4.4 文本缩进</h3><p><code>text-indent</code>定义段落首行缩进。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">p </span><span class="token punctuation">{</span>  <span class="token property">text-indet</span><span class="token punctuation">:</span> <span class="token number">5</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>em</code> 是一个相对单位，<code>1em</code> 就是一个字符所占大小。当 <code>text-indent=2em</code>，则恰好缩进两个文字。</p><h3 id="4-5-行间距"><a href="#4-5-行间距" class="headerlink" title="4.5 行间距"></a>4.5 行间距</h3><p><code>line-height</code> 设置行间的距离，行间距=文本高度+上间距+下间距</p><h3 id="4-6-文本属性总结"><a href="#4-6-文本属性总结" class="headerlink" title="4.6 文本属性总结"></a>4.6 文本属性总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意</th></tr></thead><tbody><tr><td>color</td><td>文本颜色</td><td>通常十六进制缩写</td></tr><tr><td>text-align</td><td>文本对齐</td><td></td></tr><tr><td>text-indent</td><td>文本缩进</td><td>记住 <code>text-indent: 2em;</code></td></tr><tr><td>text-decoration</td><td>文本装饰</td><td>记住下划线和去除下划线</td></tr><tr><td>line-height</td><td>行高</td><td></td></tr></tbody></table><h2 id="5-CSS-引用方式"><a href="#5-CSS-引用方式" class="headerlink" title="5. CSS 引用方式"></a>5. CSS 引用方式</h2><p>按照 CSS 书写的位置不同，CSS 样式表可以分为三大类：</p><ol><li>行内样式表（行内式）</li><li>内部样式表（嵌入式）</li><li>外部样式表（链接式）</li></ol><h3 id="5-1-内部样式表"><a href="#5-1-内部样式表" class="headerlink" title="5.1 内部样式表"></a>5.1 内部样式表</h3><p>将 CSS 代码写在 HTML 页面内部，单独放在一个 <code>&lt;style&gt;</code> 标签中。</p><ul><li><code>&lt;style&gt;</code> 理论上可以放在 HTML 文档中任何一个地方，一般放在 <code>&lt;head&gt;</code> 标签中。</li><li>方便控制整个页面中的元素样式。</li></ul><p>练习时使用，实际开发不用。</p><h3 id="5-2-行内样式表"><a href="#5-2-行内样式表" class="headerlink" title="5.2 行内样式表"></a>5.2 行内样式表</h3><p>行内样式表（内联样式表）是在元素标签内部的 <code>style</code> 属性中设定 CSS 样式，适合修改简单样式。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span> <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">12</span>px</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>行内样式表<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>设置当前标签样式</li><li>书写繁琐，不推荐大量使用。</li></ul><h3 id="5-3-外部样式表"><a href="#5-3-外部样式表" class="headerlink" title="5.3 外部样式表"></a>5.3 外部样式表</h3><p>实际开发中都是外部样式表，适用于样式比较多的情况。 核心：样式单独写到 CSS 文件中，再将 CSS 文件引入到 HTML 页面中。</p><p>引入格式</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>css文件路径<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS学习笔记一&quot;&gt;&lt;a href=&quot;#CSS学习笔记一&quot; class=&quot;headerlink&quot; title=&quot;CSS学习笔记一&quot;&gt;&lt;/a&gt;CSS学习笔记一&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  文章转载至: MurphyChen’s Notes(&lt;a hr</summary>
      
    
    
    
    <category term="前端学习" scheme="https://roranrui.cn/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="css" scheme="https://roranrui.cn/tags/css/"/>
    
    <category term="前端" scheme="https://roranrui.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git简单使用教程</title>
    <link href="https://roranrui.cn/posts/31939754/"/>
    <id>https://roranrui.cn/posts/31939754/</id>
    <published>2022-05-03T07:43:22.000Z</published>
    <updated>2022-05-06T16:03:45.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git简单使用教程"><a href="#Git简单使用教程" class="headerlink" title="Git简单使用教程"></a>Git简单使用教程</h1><h2 id="1-Git的安装"><a href="#1-Git的安装" class="headerlink" title="1. Git的安装"></a>1. Git的安装</h2><ul><li><p><a href="https://git-scm.com/">git安装网址</a></p></li><li><p><a href="https://git-scm.com/book/zh/v2">git官方参考手册</a></p></li><li><p>Ubuntu下安装：<code>sudo apt-get install git</code></p></li></ul><hr><h2 id="2-Git搭建本地仓库"><a href="#2-Git搭建本地仓库" class="headerlink" title="2. Git搭建本地仓库"></a>2. Git搭建本地仓库</h2><p>​选择你要搭建仓库的文件夹, <code>git bush here</code>, 出现输入终端:</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220503151044126.png" alt="image-20220503151044126"></p><p>此时, 如果是第一次使用, 应该设置一下名字和邮箱, 命令如下:</p><pre class="line-numbers language-git"><code class="language-git">git config --global user.name <span class="token string">"xxxx"</span>git config --global user.email <span class="token string">"xxxx.@xxx.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>建立仓库:</strong></p><p>先初始化仓库</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入上面的命令后, 就会出现一个文件夹<code>.git</code></p><p><strong>接下来添加文件:</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> add <span class="token keyword">.</span>  <span class="token punctuation">(</span>不要忘记后面这点<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>  这个命令是将仓库中的除了<code>.gitignore</code>中排除的其他文件都添加到缓存区</p></blockquote><p><strong>增加到版本库中:</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> commit -m <span class="token string">'备注信息'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除暂存区:</strong></p><ul><li>保证当前工作区中没有<code>add</code>过的文件</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> fileName --cached<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看版本:</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> log --oneline<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>回退版本:</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> reset --hard 后面加版本号<span class="token function">git</span> log  回滚最近的一个版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至此, 一个本地仓库就搭建完成了, 可以在本地对代码进行版本控制</p><hr><h2 id="3-本地仓库关联到远程仓库"><a href="#3-本地仓库关联到远程仓库" class="headerlink" title="3. 本地仓库关联到远程仓库"></a>3. 本地仓库关联到远程仓库</h2><p><strong>连接远程仓库</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript">git remote add origin 仓库的地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看远程仓库</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript">git remote <span class="token operator">-</span>v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除远程仓库</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript">git remote rm origin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>本地库的改动提交到远程库：</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>更新本地库至远程库的最新改动:</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> pull<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><h3 id="与查询有关的："><a href="#与查询有关的：" class="headerlink" title="与查询有关的："></a>与查询有关的：</h3><ul><li><p>查询仓库状态：<code>git status</code> </p></li><li><p>查询远程仓库状态: <code>git remote -v</code></p></li><li><p>比较文件差异（请在git add之前使用）：<code>git diff 文件名</code> </p></li><li><p>查看仓库历史记录(详细)：<code>git log</code> </p></li><li><p>查看仓库历史记录(单行)：<code>git log --pretty=online</code> 或 <code>git log --online</code> </p></li><li><p>查看所有版本的commit ID：<code>git reflog</code></p></li></ul><h3 id="与撤销有关的："><a href="#与撤销有关的：" class="headerlink" title="与撤销有关的："></a>与撤销有关的：</h3><ul><li>撤销工作区的修改：<code>git checkout -- 文件名</code> </li><li>撤销暂存区的修改：<code>git reset HEAD 文件名</code> </li><li>回退到历史版本：<code>git reset --hard 该版本ID</code> </li><li>回退到上个版本：<code>git reset --hard HEAD^</code> 上上版本是<code>HEAD^^</code>，也可用<code>HEAD~2</code>表示，以此类推</li></ul><h3 id="与标签有关的："><a href="#与标签有关的：" class="headerlink" title="与标签有关的："></a>与标签有关的：</h3><ul><li>为当前版本打标签：<code>git tag 标签名</code> </li><li>为历史版本打标签：<code>git tag 标签名 该版本ID</code> </li><li>指定标签说明：<code>git tag –a 标签名 –m "标签说明" [可选：版本ID]</code> </li><li>查看所有标签：<code>git tag</code> </li><li>查看某一标签：<code>git show 标签名</code> </li><li>删除某一标签：<code>git tag –d 标签名</code></li></ul><h3 id="与添加有关的："><a href="#与添加有关的：" class="headerlink" title="与添加有关的："></a>与添加有关的：</h3><ul><li>将当前目录变为仓库：<code>git init</code></li><li>将文件添加到暂存区：<code>git add 文件名 [可选：另一个文件名]</code></li><li>将暂存区提交到仓库：<code>git commit –m "描述"</code></li></ul><h2 id="4-分支管理"><a href="#4-分支管理" class="headerlink" title="4. 分支管理"></a>4. 分支管理</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre class="line-numbers language-javascript"><code class="language-javascript">git branch dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><pre class="line-numbers language-javascript"><code class="language-javascript">git checkout dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建分支并切换分支"><a href="#创建分支并切换分支" class="headerlink" title="创建分支并切换分支"></a>创建分支并切换分支</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> branch -d dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="上提交新的版本"><a href="#上提交新的版本" class="headerlink" title="上提交新的版本"></a>上提交新的版本</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> commit -a -m <span class="token string">'dev1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> merge dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="分支的合并后显示log"><a href="#分支的合并后显示log" class="headerlink" title="分支的合并后显示log"></a>分支的合并后显示log</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> log --oneline --graph --decorate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="在分支开发的过程中遇到其他问题需要切换其他分支"><a href="#在分支开发的过程中遇到其他问题需要切换其他分支" class="headerlink" title="在分支开发的过程中遇到其他问题需要切换其他分支"></a>在分支开发的过程中遇到其他问题需要切换其他分支</h3><ul><li>保留写好的内容在切换到主干</li><li>保留内容 <code>git stash</code></li></ul><hr><h2 id="仓库地址选择-HTTPS-or-SSH"><a href="#仓库地址选择-HTTPS-or-SSH" class="headerlink" title="仓库地址选择(HTTPS or SSH)"></a>仓库地址选择(HTTPS or SSH)</h2><p>如果选择SSH协议，必须将本地的公钥添加到相应代码托管平台上(以github为例)。</p><p><strong>SSH Key</strong></p><p>生成SSH Key：<code>ssh-keygen –t rsa –C "你的邮箱@xx.com"</code> 生成Key时弹出选项，回车选择默认即可。 Key保存位置：<code>/root/.ssh</code> 登陆GitHub，创建new SSH key，其内容为<code>/root/.ssh/id_rsa.pub</code>中文本</p><h2 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h2><h3 id="rejected"><a href="#rejected" class="headerlink" title="! [rejected]"></a>! [rejected]</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/2018072410120456" alt="img"></p><p>执行命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> pull origin master --allow-unrelated-histories<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="拓展-git-submodules"><a href="#拓展-git-submodules" class="headerlink" title="拓展: git submodules"></a>拓展: git submodules</h2><h3 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git简单使用教程&quot;&gt;&lt;a href=&quot;#Git简单使用教程&quot; class=&quot;headerlink&quot; title=&quot;Git简单使用教程&quot;&gt;&lt;/a&gt;Git简单使用教程&lt;/h1&gt;&lt;h2 id=&quot;1-Git的安装&quot;&gt;&lt;a href=&quot;#1-Git的安装&quot; class=&quot;</summary>
      
    
    
    
    <category term="Git" scheme="https://roranrui.cn/categories/Git/"/>
    
    
    <category term="Git" scheme="https://roranrui.cn/tags/Git/"/>
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>第十天_动态规划(中等)</title>
    <link href="https://roranrui.cn/posts/b5849224/"/>
    <id>https://roranrui.cn/posts/b5849224/</id>
    <published>2022-05-03T00:01:37.000Z</published>
    <updated>2022-05-06T16:03:45.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十天-动态规划-中等"><a href="#第十天-动态规划-中等" class="headerlink" title="第十天_动态规划(中等)"></a>第十天_动态规划(中等)</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="lt-algorithm-gt-中的最大值最小值"><a href="#lt-algorithm-gt-中的最大值最小值" class="headerlink" title="<algorithm>中的最大值最小值"></a>&lt;algorithm&gt;中的最大值最小值</h3><ul><li>max() : 返回最大值</li><li>min(): 返回最小值</li><li>max_element()返回最大值的地址, 对容器就是<code>iterator</code></li><li>min_element()返回最小值的地址, 对容器就是<code>iterator</code></li></ul><h3 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h3><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回   0</p><p>&gt; 返回   1 </p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li><li><code>int compare(const char *s) const;</code>      //与字符串s比较</li></ul><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-把数字翻译成字符串"><a href="#1-把数字翻译成字符串" class="headerlink" title="1. 把数字翻译成字符串"></a>1. 把数字翻译成字符串</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503080557064.png" alt="image-20220503080557064"></p><p>解题思路:</p><p><strong>1.动态规划</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1603462412-iUcKzA-Picture1.png" alt="Picture1.png"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1603461843-qyOiIi-Picture8.png" alt="img"></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">translateNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            string tmp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"25"</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503082321077.png" alt="image-20220503082321077"></p><p><strong>空间优化版本</strong></p><p>由于 dp[i] 只与 dp[i - 1] 有关，因此可使用两个变量 a, b 分别记录 dp[i] , dp[i - 1]，两变量交替前进即可。此方法可省去 dp 列表使用的 O(N) 的额外空间。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">translateNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            string tmp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> tmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"25"</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">+</span> b <span class="token operator">:</span> a<span class="token punctuation">;</span>            b <span class="token operator">=</span> a<span class="token punctuation">;</span>            a <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.数字求余</strong></p><blockquote><p>  上述方法虽然已经节省了 dp列表的空间占用，但字符串 s仍使用了 O(N)大小的额外空间。</p><p>  <strong>空间复杂度优化：</strong><br>  利用求余运算 num%10 和求整运算 num // 10 ，可获取数字 num 的各位数字（获取顺序为个位、十位、百位…）。<br>  运用 求余 和 求整 运算实现，可实现 从右向左 的动态规划计算。而根据上述动态规划 “对称性” ，可知从右向左计算是正确的。<br>  自此，字符串 s 的空间占用也被省去，空间复杂度从 O(N)降至 O(1) 。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">translateNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y <span class="token operator">=</span> num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            num <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            x <span class="token operator">=</span> num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>tmp <span class="token operator">>=</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> tmp <span class="token operator">&lt;=</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token operator">+</span> b <span class="token operator">:</span> a<span class="token punctuation">;</span>            b <span class="token operator">=</span> a<span class="token punctuation">;</span>            a <span class="token operator">=</span> c<span class="token punctuation">;</span>            y <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-最长不含重复字符的子字符串"><a href="#2-最长不含重复字符的子字符串" class="headerlink" title="2. 最长不含重复字符的子字符串"></a>2. 最长不含重复字符的子字符串</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503083055523.png" alt="image-20220503083055523"></p><p><strong>解题思路</strong>:</p><p>1.动态规划</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503083340522.png" alt="image-20220503083340522"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599287290-mTdFye-Picture1.png" alt="Picture1.png"></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> i<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> j <span class="token operator">-</span> i <span class="token operator">?</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">max_element</span><span class="token punctuation">(</span>dp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503085923960.png" alt="image-20220503085923960"></p><p>2.结合Hashmap</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> dic<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> dic<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 未找到相同元素 </span>            <span class="token keyword">else</span> i <span class="token operator">=</span> dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> second<span class="token punctuation">;</span>            dic<span class="token punctuation">[</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> j <span class="token operator">-</span> i <span class="token operator">?</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">max_element</span><span class="token punctuation">(</span>dp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503091249798.png" alt="image-20220503091249798"></p><blockquote><p>  我们学习这些东西的目的并不是，要把他们都用到实际开发中。</p><blockquote><blockquote><p>  相反，如果我们能够用最少的东西写出一个稳定的，高效的多线程程序，更值得赞赏。</p></blockquote><blockquote><blockquote><p>   我们为了成长必须阅读一些高手写的代码，从而实现自己代码的积累；</p></blockquote></blockquote></blockquote></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十天-动态规划-中等&quot;&gt;&lt;a href=&quot;#第十天-动态规划-中等&quot; class=&quot;headerlink&quot; title=&quot;第十天_动态规划(中等)&quot;&gt;&lt;/a&gt;第十天_动态规划(中等)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href=&quot;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第九天_动态规划(中等)</title>
    <link href="https://roranrui.cn/posts/5bba0a50/"/>
    <id>https://roranrui.cn/posts/5bba0a50/</id>
    <published>2022-05-02T06:33:07.000Z</published>
    <updated>2022-05-06T16:03:45.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九天-动态规划-中等"><a href="#第九天-动态规划-中等" class="headerlink" title="第九天_动态规划(中等)"></a>第九天_动态规划(中等)</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/Diana.png" alt="没什么要学的"></p><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-连续子数组的最大和"><a href="#1-连续子数组的最大和" class="headerlink" title="1. 连续子数组的最大和"></a>1. 连续子数组的最大和</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502150950334.png" alt="image-20220502150950334"></p><p><strong>解题思路:</strong></p><p>动态规划是本题的最优解法，以下按照标准流程解题。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502151330317.png" alt="解题流程"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/77d1aa6a444743d3c8606ac951cd7fc38faf68a62064fd2639df517cd666a4d0-Picture1.png" alt="Picture1.png"></p><p>实现</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dp<span class="token punctuation">;</span>        dp<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                res <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502153026571.png" alt="image-20220502153026571"></p><p><strong>空间内存优化版本:</strong></p><p>空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> res<span class="token punctuation">)</span> res <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502153702191.png" alt="image-20220502153702191"></p><hr><h3 id="2-礼物的最大价值"><a href="#2-礼物的最大价值" class="headerlink" title="2. 礼物的最大价值"></a>2. 礼物的最大价值</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1662cdf7aafd8c9ed6e1eadc41bfc9adf58ea808e11f1a3dd2e8ba4632b9d1ac-Picture1.png" alt="Picture1.png"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502154533328.png" alt="image-20220502154533328"></p><p>实现: </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxValue</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> i <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">==</span> j<span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> grid<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502164846692.png" alt="image-20220502164846692"></p><p>使dp数组比grid数组多一行一列，初始化为0，这样既可避免判断是不是在边界的问题:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxValue</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                         <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502165012493.png" alt="image-20220502165012493"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第九天-动态规划-中等&quot;&gt;&lt;a href=&quot;#第九天-动态规划-中等&quot; class=&quot;headerlink&quot; title=&quot;第九天_动态规划(中等)&quot;&gt;&lt;/a&gt;第九天_动态规划(中等)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href=&quot;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu美化教程</title>
    <link href="https://roranrui.cn/posts/2b81f8a1/"/>
    <id>https://roranrui.cn/posts/2b81f8a1/</id>
    <published>2022-05-01T13:26:36.000Z</published>
    <updated>2022-05-06T16:16:06.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu美化教程"><a href="#Ubuntu美化教程" class="headerlink" title="Ubuntu美化教程"></a>Ubuntu美化教程</h1><blockquote><p>  基于Ubuntu20.04.4LTS</p></blockquote><h2 id="一-壁纸美化"><a href="#一-壁纸美化" class="headerlink" title="一. 壁纸美化"></a>一. 壁纸美化</h2><h3 id="壁纸设置"><a href="#壁纸设置" class="headerlink" title="壁纸设置:"></a>壁纸设置:</h3><p>右键桌面-&gt;设置壁纸即可</p><p>效果: </p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/dsad.png" alt="dsad"></p><h3 id="登录背景修改"><a href="#登录背景修改" class="headerlink" title="登录背景修改"></a>登录背景修改</h3><p><strong>到这个网址下载一个包</strong>: <strong><a href="https://github.com/thiggy01/gdm-background">https://github.com/thiggy01/gdm-background</a></strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116230551731.png" alt="在这里插入图片描述"></p><p>解压</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/2021011623071684.png" alt="在这里插入图片描述"></p><p><strong>点击打开这个文件夹有以下文件 , 会看到有以下文件 :</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116230909852.png" alt="在这里插入图片描述"></p><p>终端中打开这个文件夹</p><p>安装编译包:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> <span class="token function">make</span> gcc libgtk-3-dev libpolkit-gobject-1-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116231935597.png" alt="在这里插入图片描述"></p><p>输入:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查版本</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116232037877.png" alt="在这里插入图片描述"></p><p>编译之前下载好的包:</p><pre class="line-numbers language-bash"><code class="language-bash"> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后就能找到<strong>GDM Background 这个软件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501224321364.png" alt="image-20220501224321364"></p><p><strong>然后将你喜欢的背景图片拖入到这个窗口里:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116232737497.png" alt="在这里插入图片描述"></p><p>之后就替换成功;</p><p>效果:</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/2022-05-02_18-37.png" alt="2022-05-02_18-37"></p><hr><h2 id="二-终端美化"><a href="#二-终端美化" class="headerlink" title="二. 终端美化"></a>二. 终端美化</h2><h3 id="配置安装oh-my-zsh"><a href="#配置安装oh-my-zsh" class="headerlink" title="配置安装oh-my-zsh"></a>配置安装oh-my-zsh</h3><blockquote><p>  人生苦短，我用zsh…<br>  zsh完全兼容bash，并且<a href="https://so.csdn.net/so/search?q=oh-my-zsh&amp;spm=1001.2101.3001.7020">oh-my-zsh</a>的功能比bash强大很多，赶紧来试试！</p></blockquote><p><strong>下载安装oh-my-zsh</strong></p><pre class="line-numbers language-bash"><code class="language-bash">sh -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">wget</span> -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh<span class="token variable">)</span></span>"</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若提示无法建立SSL连接，末尾再加上<code>--no-check-certificate</code>。原因是wget在使用HTTPS协议时，默认会去验证网站的证书，而这个证书验证经常会失败。加上该选项，就表示不检查。</p><p><strong>bash切换为zsh</strong><br>把默认bash更换为默认zsh，输入<code>chsh -s /bin/zsh</code>，不会立即生效，需要重启系统</p><p><strong>oh-my-zsh插件配置</strong><br>下载的插件都放在.oh-my-zsh/plugins/目录下，下面是几个常用的非常不错的插件。</p><p>autojump: <code>apt-get install autojump</code></p><p>autosuggestions: <code>git clone git://github.com/zsh-users/zsh-autosuggestions</code></p><p>自动语法高亮：<a href="https://github.com/zsh-users/zsh-syntax-highlighting">https://github.com/zsh-users/zsh-syntax-highlighting</a><br>自动输入建议：<a href="https://github.com/zsh-users/zsh-autosuggestions">https://github.com/zsh-users/zsh-autosuggestions</a><br>打开远程仓库：<a href="https://github.com/paulirish/git-open">https://github.com/paulirish/git-open</a></p><p>下载到指定目录后，编辑.zshrc文件如下，找到plugins字段：</p><pre class="line-numbers language-bash"><code class="language-bash">plugins<span class="token operator">=</span><span class="token punctuation">(</span>其他的插件 zsh-syntax-highlighting zsh-autosuggestions git-open autojump zsh-syntax-highlighting zsh-autosuggestions<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再<code>source ~/.zshrc</code>使配置生效</p><h3 id="安装xfce4"><a href="#安装xfce4" class="headerlink" title="安装xfce4"></a>安装xfce4</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update <span class="token comment" spellcheck="true">#更新软件源</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> xfce4-terminal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>配置</p><ul><li>在右下角的dash菜单栏中找到Xfce4终端；打开</li><li>在“编辑”—&gt;“首选项”—-&gt;“外观”—-&gt;”背景图片”选择你想设置的图片；</li><li>更多终端设置，自行探索；</li></ul><blockquote><p>  设置快捷键<br>  正常使用是我们按ctr(常用^表示)+Alt+T打开我们使用的终端；现在我们设置新终端的快捷方式；</p></blockquote><ul><li>在右上角–&gt;有线连接—-&gt;有线设置—-&gt;设备—&gt;键盘 将其选中</li><li>在键盘的最下面有个”+”加号；点击</li><li>然后输入：<br>名称：你想对快捷键设置的名字<br>命令：xfce4-terminal</li></ul><p>效果:</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502181409943.png" alt="image-20220502181409943"></p><hr><h2 id="三-软件生态"><a href="#三-软件生态" class="headerlink" title="三. 软件生态"></a>三. 软件生态</h2><h3 id="星火商店"><a href="#星火商店" class="headerlink" title="星火商店"></a>星火商店</h3><p>首先我们到官网下载星火商店以及依赖(20.04)：<a href="https://spark-app.store/">https://spark-app.store/</a></p><p>先安装依赖</p><p>然后再安装包</p><h3 id="deepin-wine"><a href="#deepin-wine" class="headerlink" title="deepin-wine"></a>deepin-wine</h3><p>可在星火商店下载</p><hr><h2 id="四-Dock栏优化"><a href="#四-Dock栏优化" class="headerlink" title="四. Dock栏优化"></a>四. Dock栏优化</h2><p>安装</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> dconf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>依次打开:</p><pre><code>/org/gnome/shell/extensions/dash-to-dock/</code></pre><p>个人配置:</p><pre class="line-numbers language-bash"><code class="language-bash">background-opacity 0  // 透明custom-background-color <span class="token boolean">true</span>customize-alphas <span class="token boolean">true</span>dock-fixed <span class="token boolean">true</span>dock-position <span class="token string">'BOTTOM'</span>extend-height <span class="token boolean">false</span>show-apps-at-top <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果:</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502182034386.png" alt="image-20220502182034386"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu美化教程&quot;&gt;&lt;a href=&quot;#Ubuntu美化教程&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu美化教程&quot;&gt;&lt;/a&gt;Ubuntu美化教程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  基于Ubuntu20.04.4LTS&lt;/p&gt;
</summary>
      
    
    
    
    <category term="美化教程" scheme="https://roranrui.cn/categories/%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="经验分享" scheme="https://roranrui.cn/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    <category term="桌面美化" scheme="https://roranrui.cn/tags/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于jetbrainsIDE的设置</title>
    <link href="https://roranrui.cn/posts/4a81cec7/"/>
    <id>https://roranrui.cn/posts/4a81cec7/</id>
    <published>2022-05-01T06:36:22.000Z</published>
    <updated>2022-05-06T16:03:45.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jetbrains-IDE设置"><a href="#jetbrains-IDE设置" class="headerlink" title="jetbrains IDE设置"></a>jetbrains IDE设置</h1><h2 id="一-美化"><a href="#一-美化" class="headerlink" title="一. 美化"></a>一. 美化</h2><h3 id="背景图像美化"><a href="#背景图像美化" class="headerlink" title="背景图像美化"></a>背景图像美化</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501143718297.png" alt="外观->背景图像"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501143841490.png" alt="效果"></p><h3 id="字体配色方案"><a href="#字体配色方案" class="headerlink" title="字体配色方案"></a>字体配色方案</h3><p><a href="https://github.com/topics/jetbrains-theme">指路</a></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501144625849.png" alt="编辑器->配色方案"></p><hr><h2 id="二-高效设置"><a href="#二-高效设置" class="headerlink" title="二. 高效设置"></a>二. 高效设置</h2><h3 id="调整窗口字体显示大小"><a href="#调整窗口字体显示大小" class="headerlink" title="调整窗口字体显示大小"></a>调整窗口字体显示大小</h3><p>巨好用的一个功能！强烈安利！</p><p>勾选上 <em>Preferences / Settings | Editor | General</em> 下的 <em>Change font size with Command + Mouse Wheel</em> 选项之后，我们就可以直接使用 <code>Ctrl+鼠标滚轮</code>(Windows&amp;Linux)来更改窗口字体的大小</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501145041883.png" alt="image-20220501145041883"></p><p>开启更改所有选项卡的字体大小功能</p><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>修改 <em>Preferences / Settings | Editor | Font</em> 选项下的字体设置，字体推荐使用 JetBrains Mono ，字体大小建议 16/18，根据个人需要选择是否需要开启连字。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501145148929.png" alt="image-20220501145148929"></p><h3 id="配置类注释模板"><a href="#配置类注释模板" class="headerlink" title="配置类注释模板"></a>配置类注释模板</h3><p>修改 <em>Preferences / Settings | Editor | File adn Code Templates</em> 下的 <code>Class</code> 和 <code>Enum</code> 的模板。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501150659503.png" alt="image-20220501150659503"></p><p>你可以根据自己的习惯对 IDEA 自带的编码模板进行修改，并且，你还可以添加新的编码模板来提高编码速度。非常实用！</p><h3 id="显示方法分割线"><a href="#显示方法分割线" class="headerlink" title="显示方法分割线"></a>显示方法分割线</h3><p>勾选上 <em>Preferences / Settings | Editor | General | Appearance</em> 下的 Show method separators 选项之后，方法分割线就有了，这会小幅提高代码的可读性。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501151302639.png" alt="image-20220501151302639"></p><hr><h2 id="三-插件推荐"><a href="#三-插件推荐" class="headerlink" title="三. 插件推荐"></a>三. 插件推荐</h2><p>在此仅推荐两个</p><h3 id="Tabnine：基于-AI-的代码提示"><a href="#Tabnine：基于-AI-的代码提示" class="headerlink" title="Tabnine：基于 AI 的代码提示"></a>Tabnine：基于 AI 的代码提示</h3><p>Tabnine 这个插件用于智能代码补全，它基于数百万 Java 程序，能够根据程序上下文提示补全代码。Tabnine 和 IDEA 自带的智能提示两者互补。</p><h3 id="Rainbow-Brackets-彩虹括号"><a href="#Rainbow-Brackets-彩虹括号" class="headerlink" title="Rainbow Brackets : 彩虹括号"></a>Rainbow Brackets : 彩虹括号</h3><p>使用各种鲜明的颜色来展示你的括号，效果图如下。可以看出代码层级变得更加清晰了，可以说非常实用友好了！</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jetbrains-IDE设置&quot;&gt;&lt;a href=&quot;#jetbrains-IDE设置&quot; class=&quot;headerlink&quot; title=&quot;jetbrains IDE设置&quot;&gt;&lt;/a&gt;jetbrains IDE设置&lt;/h1&gt;&lt;h2 id=&quot;一-美化&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="美化教程" scheme="https://roranrui.cn/categories/%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="经验分享" scheme="https://roranrui.cn/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    <category term="IDE美化" scheme="https://roranrui.cn/tags/IDE%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程进阶一</title>
    <link href="https://roranrui.cn/posts/e916c6e/"/>
    <id>https://roranrui.cn/posts/e916c6e/</id>
    <published>2022-05-01T05:24:50.000Z</published>
    <updated>2022-05-06T15:53:09.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程进阶-一"><a href="#多线程进阶-一" class="headerlink" title="多线程进阶(一)"></a>多线程进阶(一)</h1><h2 id="一-条件变量"><a href="#一-条件变量" class="headerlink" title="一. 条件变量"></a>一. 条件变量</h2><blockquote><p>  重复加锁, 影响效率, 可通过双重锁定的方式, 减少加锁, 提升效率</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">IsoutMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 双重锁定, 提升效率</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">ulock1</span><span class="token punctuation">(</span>mtx1<span class="token punctuation">)</span><span class="token punctuation">;</span>        unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">ulock2</span><span class="token punctuation">(</span>mtx2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"删除元素 "</span> <span class="token operator">&lt;&lt;</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mtx1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            mtx2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本方法仍不够完美, 以下给出更优的解决办法</p><h3 id="1-condition-variable"><a href="#1-condition-variable" class="headerlink" title="1. condition_variable"></a>1. condition_variable</h3><blockquote><p>  std::condition_variable实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">outMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> command <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">ulock1</span><span class="token punctuation">(</span>mtx1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果第二个参数lambda表达式返回值是false, 那么wait()将解锁互斥量, 并堵塞本行</span>        <span class="token comment" spellcheck="true">// 直到其他线程调用notify_one()为止</span>        my_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>ulock1<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span>                     <span class="token punctuation">{</span>                         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                         <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        command <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ulock1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"删除元素 "</span> <span class="token operator">&lt;&lt;</span> command <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"END"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>wait()用来等一个东西</p><p>如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行<br>如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行。</p><p>阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止；</p><p>如果没有第二个参数，那么效果跟第二个参数lambda表达式返回false效果一样</p><p>wait()将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用notify_one()成员函数为止。</p><p>当其他线程用<code>notify_one()</code>将本线程wait()唤醒后，这个wait恢复后</p><ol><li><p>wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待获取，如果获取到了，那么wait()就继续执行，获取到了锁</p></li><li><p>如果wait有第二个参数就判断这个lambda表达式。</p><p>a)如果表达式为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify_one()唤醒<br>b)如果lambda表达式为true，则wait返回，流程可以继续执行（此时互斥量已被锁住）。</p></li><li><p>如果wait没有第二个参数，则wait返回，流程走下去。</p></li></ol><blockquote><p>  <strong>流程只要走到了wait()下面则互斥量一定被锁住了。</strong></p></blockquote><p>完整代码:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Msg "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" got."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">myGuard</span><span class="token punctuation">(</span>mtx1<span class="token punctuation">,</span> adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//            lock(mtx1, mtx2);</span>            msgRecvQueue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            my_cond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//            mtx1.unlock();</span><span class="token comment" spellcheck="true">//            mtx2.unlock();</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">outMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> command <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">ulock1</span><span class="token punctuation">(</span>mtx1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果第二个参数lambda表达式返回值是false, 那么wait()将解锁互斥量, 并堵塞本行</span>            <span class="token comment" spellcheck="true">// 直到其他线程调用notify_one()为止</span>            my_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>ulock1<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            command <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ulock1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"删除元素 "</span> <span class="token operator">&lt;&lt;</span> command <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"END"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> msgRecvQueue<span class="token punctuation">;</span>    mutex mtx1<span class="token punctuation">;</span>    mutex mtx2<span class="token punctuation">;</span>    condition_variable my_cond<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 生成一个条件变量对象</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    A my_a<span class="token punctuation">;</span>    thread <span class="token function">ts1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>outMsg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>my_a<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">ts2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>getMsg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>my_a<span class="token punctuation">)</span><span class="token punctuation">;</span>    ts1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ts2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、深入思考</p><p>上面的代码可能导致出现一种情况：<br>因为outMsg()与getMsg()并不是一对一执行的，所以当程序循环执行很多次以后，可能在msgRecvQueue 中已经有了很多消息，但是，outMsg()还是被唤醒一次只处理一条数据。这时可以考虑把outMsg()多执行几次，或者对getMsg()进行限流。</p><h4 id="notify-all"><a href="#notify-all" class="headerlink" title="notify_all()"></a>notify_all()</h4><blockquote><p>  notify_one()：通知一个线程的wait()</p><p>  notify_all()：通知所有线程的wait()</p></blockquote><h2 id="二-创建后台任务并返回值–future类"><a href="#二-创建后台任务并返回值–future类" class="headerlink" title="二. 创建后台任务并返回值–future类"></a>二. 创建后台任务并返回值–future类</h2><h3 id="std-asyncstd-future"><a href="#std-asyncstd-future" class="headerlink" title="std::asyncstd::future"></a>std::asyncstd::future</h3><p><strong>std::async</strong>是一个函数模板，用来启动一个异步任务，启动起来一个异步任务之后，它返回一个<strong>std::future</strong>对象，这个对象是个类模板。</p><p>异步任务的定义:</p><blockquote><p>  启动一个异步任务就是自动创建一个线程，并开始 执行对应的线程入口函数，它返回一个std::future对象，这个std::future对象中就含有线程入口函数所返回的结果，我们可以通过调用future对象的成员函数get()来获取结果。</p></blockquote><p>“future”将来的意思，也有人称呼std::future提供了一种访问异步操作结果的机制，就是说这个结果你可能没办法马上拿到，但是在不久的将来，这个线程执行完毕的时候，你就能够拿到结果了，所以，大家这么理解：future中保存着一个值，这个值是在将来的某个时刻能够拿到。</p><ul><li><p>std::future对象的get()成员函数会等待线程执行结束并返回结果，拿不到结果它就会一直等待，感觉有点像join()。但是，它是可以获取结果的。</p></li><li><p>std::future对象的wait()成员函数，用于等待线程返回，本身并不返回结果，这个效果和 std::thread 的join()更像。</p></li></ul><p>使用get()返回:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;future></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5s</span>    this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread finished"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main thread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// get()获取返回值</span>    cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  get()只能调用一次!!!!</p><p>  因为get()函数的设计是一个移动语义，相当于将result中的值移动到了a中，再次get就报告了异常。</p></blockquote><hr><h3 id="std-launch类型（枚举类型）"><a href="#std-launch类型（枚举类型）" class="headerlink" title="std::launch类型（枚举类型）"></a>std::launch类型（枚举类型）</h3><p>我们通过向std::async()传递一个参数，该参数是std::launch类型（枚举类型），来达到一些特殊的目的：</p><ol><li><strong>std::lunch::deferred：</strong><br>（defer推迟，延期）表示线程入口函数的调用会被延迟，一直到std::future的wait()或者get()函数被调用时（由主线程调用）才会执行；如果wait()或者get()没有被调用，则不会执行。<br>实际上根本就没有创建新线程。std::launch::deferred意思时延迟调用，并没有创建新线程，是在主线程中调用的线程入口函数。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp">main thread startedthread id<span class="token operator">:</span> <span class="token number">1</span>num<span class="token operator">:</span> <span class="token number">230</span>mythread startedthread id<span class="token operator">:</span> <span class="token number">1</span>mythread finishedthread id<span class="token operator">:</span> <span class="token number">1</span><span class="token number">5</span><span class="token keyword">continue</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p><strong>std::launch::async</strong>:</p><p>在调用async函数的时候就开始创建新线程。</p></li></ol><pre class="line-numbers language-cpp"><code class="language-cpp">main thread startedthread id<span class="token operator">:</span> <span class="token number">1</span><span class="token keyword">continue</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>num<span class="token operator">:</span> <span class="token number">230</span>mythread startedthread id<span class="token operator">:</span> <span class="token number">2</span>mythread finishedthread id<span class="token operator">:</span> <span class="token number">2</span><span class="token number">5</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h3><blockquote><p>  <strong>std::packaged_task：打包任务，把任务包装起来。</strong></p></blockquote><p>类模板，它的模板参数是各种可调用对象，通过packaged_task把各种可调用对象包装起来，方便将来作为线程入口函数来调用。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">230</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main thread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">mypt</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token function">ref</span><span class="token punctuation">(</span>mypt<span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// res 保存mypt将要返回的值</span>    future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res <span class="token operator">=</span> mypt<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"continue..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// get()获取返回值</span>    cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// wait()不返回结果</span><span class="token comment" spellcheck="true">//    res.wait();</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  packaged_task包装起来的可调用对象还可以直接调用，从这个角度来讲，packaged_task对象也是一个可调用对象</p></blockquote><p><strong>lambda的直接调用:</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">230</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main thread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">mypt</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5s</span>        this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread finished"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token function">ref</span><span class="token punctuation">(</span>mypt<span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// res 保存mypt将要返回的值</span>    future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res <span class="token operator">=</span> mypt<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"continue..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// get()获取返回值</span>    cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// wait()不返回结果</span><span class="token comment" spellcheck="true">//    res.wait();</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a>std::promise</h3><blockquote><p>  <em>std::promise，类模板</em><br>  我们能够在某个线程中给它赋值，然后我们可以在其他线程中，把这个值取出来</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;future></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">mythread</span><span class="token punctuation">(</span>std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">,</span> <span class="token keyword">int</span> clac<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread() start"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"threadid = "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread() end"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"threadid = "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> clac<span class="token punctuation">;</span>    tmp<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//结果保存到了tmp这个对象中</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span> vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span> task_vec<span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> myprom<span class="token punctuation">;</span>    std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>mythread<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>myprom<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在这里线程已经执行完了</span>    std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> fu1 <span class="token operator">=</span> myprom<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//promise和future绑定，用于获取线程返回值</span>    <span class="token keyword">auto</span> result <span class="token operator">=</span> fu1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"result = "</span> <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="三-std-future-深入理解"><a href="#三-std-future-深入理解" class="headerlink" title="三. std::future 深入理解"></a>三. std::future 深入理解</h2><h3 id="future其他成员函数"><a href="#future其他成员函数" class="headerlink" title="future其他成员函数"></a>future其他成员函数</h3><ol><li><code>std::future_status status = result.wait_for(std::chrono::seconds(几秒))</code>;</li></ol><blockquote><p>  卡住当前流程，等待<code>std::async()</code>的异步任务运行一段时间，然后返回其状态<code>std::future_status</code>。</p></blockquote><ul><li>如果<code>std::async()</code>的参数是<code>std::launch::deferred</code>（延迟执行），则不会卡住主流程。</li><li><code>std::future_status</code>是枚举类型，表示异步任务的执行状态。类型的取值有:<ul><li><code>std::future_status::timeout</code></li><li><code>std::future_status::ready</code></li><li><code>std::future_status::deferred</code></li></ul></li></ul><p>代码示例:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;future></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  * @brief 线程入口函数  * @param int类型 num 数字  * @retval 5  */</span><span class="token keyword">int</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5s</span>    this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread finished"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">230</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main thread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">/*launch::deferred,*/</span> mythread<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"continue..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// 枚举类型</span>    future_status status <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> future_status<span class="token operator">::</span>timeout<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/// 超时了</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"timeout!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> future_status<span class="token operator">::</span>ready<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/// 成功返回</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程成功执行!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> future_status<span class="token operator">::</span>deferred<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/// 延迟执行</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程延迟执行!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="std-shared-future"><a href="#std-shared-future" class="headerlink" title="std::shared_future"></a>std::shared_future</h3><blockquote><ul><li><p>std::future的 get() 成员函数是转移数据</p></li><li><p>std::shared_future 的 get()成员函数是复制数据</p></li></ul></blockquote><p>即<code>shared_future</code>的<code>get()</code>可以重复调用</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;future></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/**  * @brief 线程入口函数  * @param int类型 num 数字  * @retval 5  */</span><span class="token keyword">int</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5s</span>    this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread finished"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main thread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">mypt</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token function">ref</span><span class="token punctuation">(</span>mypt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res_1 <span class="token operator">=</span> mypt<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// 判断future中的值是不是一个有效值</span>    <span class="token keyword">bool</span> flag_get <span class="token operator">=</span> res_1<span class="token punctuation">.</span><span class="token function">valid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">///执行完毕后result_s里有值，而result里空了</span>    <span class="token comment" spellcheck="true">///std::shared_future&lt;int> result_s(std::move(result));</span>    <span class="token comment" spellcheck="true">///通过get_future返回值直接构造一个shared_future对象</span>    <span class="token comment" spellcheck="true">///std::shared_future&lt;int> result_s(mypt.get_future());</span>    shared_future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">result_s</span><span class="token punctuation">(</span>res_1<span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> myres1 <span class="token operator">=</span> result_s<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> myres2 <span class="token operator">=</span> result_s<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"myres1 = "</span> <span class="token operator">&lt;&lt;</span> myres1 <span class="token operator">&lt;&lt;</span> <span class="token string">" myres2 = "</span> <span class="token operator">&lt;&lt;</span> myres2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程进阶-一&quot;&gt;&lt;a href=&quot;#多线程进阶-一&quot; class=&quot;headerlink&quot; title=&quot;多线程进阶(一)&quot;&gt;&lt;/a&gt;多线程进阶(一)&lt;/h1&gt;&lt;h2 id=&quot;一-条件变量&quot;&gt;&lt;a href=&quot;#一-条件变量&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="多线程" scheme="https://roranrui.cn/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="多线程编程" scheme="https://roranrui.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
