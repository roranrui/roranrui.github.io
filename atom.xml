<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>若然无亦的Blog</title>
  
  <subtitle>长日终有时, 长梦终有逝</subtitle>
  <link href="https://roranrui.cn/atom.xml" rel="self"/>
  
  <link href="https://roranrui.cn/"/>
  <updated>2022-05-03T01:22:12.916Z</updated>
  <id>https://roranrui.cn/</id>
  
  <author>
    <name>若然无亦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第十天_动态规划(中等)</title>
    <link href="https://roranrui.cn/2022/05/03/shua-ti-bi-ji-shi/"/>
    <id>https://roranrui.cn/2022/05/03/shua-ti-bi-ji-shi/</id>
    <published>2022-05-03T00:01:37.000Z</published>
    <updated>2022-05-03T01:22:12.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十天-动态规划-中等"><a href="#第十天-动态规划-中等" class="headerlink" title="第十天_动态规划(中等)"></a>第十天_动态规划(中等)</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="lt-algorithm-gt-中的最大值最小值"><a href="#lt-algorithm-gt-中的最大值最小值" class="headerlink" title="<algorithm>中的最大值最小值"></a>&lt;algorithm&gt;中的最大值最小值</h3><ul><li>max() : 返回最大值</li><li>min(): 返回最小值</li><li>max_element()返回最大值的地址, 对容器就是<code>iterator</code></li><li>min_element()返回最小值的地址, 对容器就是<code>iterator</code></li></ul><h3 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h3><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回   0</p><p>&gt; 返回   1 </p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li><li><code>int compare(const char *s) const;</code>      //与字符串s比较</li></ul><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-把数字翻译成字符串"><a href="#1-把数字翻译成字符串" class="headerlink" title="1. 把数字翻译成字符串"></a>1. 把数字翻译成字符串</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503080557064.png" alt="image-20220503080557064"></p><p>解题思路:</p><p><strong>1.动态规划</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1603462412-iUcKzA-Picture1.png" alt="Picture1.png"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1603461843-qyOiIi-Picture8.png" alt="img"></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">translateNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            string tmp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"25"</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503082321077.png" alt="image-20220503082321077"></p><p><strong>空间优化版本</strong></p><p>由于 dp[i] 只与 dp[i - 1] 有关，因此可使用两个变量 a, b 分别记录 dp[i] , dp[i - 1]，两变量交替前进即可。此方法可省去 dp 列表使用的 O(N) 的额外空间。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">translateNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            string tmp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> tmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"25"</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">+</span> b <span class="token operator">:</span> a<span class="token punctuation">;</span>            b <span class="token operator">=</span> a<span class="token punctuation">;</span>            a <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.数字求余</strong></p><blockquote><p>  上述方法虽然已经节省了 dp列表的空间占用，但字符串 s仍使用了 O(N)大小的额外空间。</p><p>  <strong>空间复杂度优化：</strong><br>  利用求余运算 num%10 和求整运算 num // 10 ，可获取数字 num 的各位数字（获取顺序为个位、十位、百位…）。<br>  运用 求余 和 求整 运算实现，可实现 从右向左 的动态规划计算。而根据上述动态规划 “对称性” ，可知从右向左计算是正确的。<br>  自此，字符串 s 的空间占用也被省去，空间复杂度从 O(N)降至 O(1) 。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">translateNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y <span class="token operator">=</span> num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            num <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            x <span class="token operator">=</span> num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>tmp <span class="token operator">>=</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> tmp <span class="token operator">&lt;=</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token operator">+</span> b <span class="token operator">:</span> a<span class="token punctuation">;</span>            b <span class="token operator">=</span> a<span class="token punctuation">;</span>            a <span class="token operator">=</span> c<span class="token punctuation">;</span>            y <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-最长不含重复字符的子字符串"><a href="#2-最长不含重复字符的子字符串" class="headerlink" title="2. 最长不含重复字符的子字符串"></a>2. 最长不含重复字符的子字符串</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503083055523.png" alt="image-20220503083055523"></p><p><strong>解题思路</strong>:</p><p>1.动态规划</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503083340522.png" alt="image-20220503083340522"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599287290-mTdFye-Picture1.png" alt="Picture1.png"></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> i<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> j <span class="token operator">-</span> i <span class="token operator">?</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">max_element</span><span class="token punctuation">(</span>dp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503085923960.png" alt="image-20220503085923960"></p><p>2.结合Hashmap</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> dic<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> dic<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> i <span class="token operator">=</span> dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> second<span class="token punctuation">;</span>            dic<span class="token punctuation">[</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> j <span class="token operator">-</span> i <span class="token operator">?</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">max_element</span><span class="token punctuation">(</span>dp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503091249798.png" alt="image-20220503091249798"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十天-动态规划-中等&quot;&gt;&lt;a href=&quot;#第十天-动态规划-中等&quot; class=&quot;headerlink&quot; title=&quot;第十天_动态规划(中等)&quot;&gt;&lt;/a&gt;第十天_动态规划(中等)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href=&quot;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第九天_动态规划(中等)</title>
    <link href="https://roranrui.cn/2022/05/02/shua-ti-bi-ji-jiu/"/>
    <id>https://roranrui.cn/2022/05/02/shua-ti-bi-ji-jiu/</id>
    <published>2022-05-02T06:33:07.000Z</published>
    <updated>2022-05-02T10:43:54.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九天-动态规划-中等"><a href="#第九天-动态规划-中等" class="headerlink" title="第九天_动态规划(中等)"></a>第九天_动态规划(中等)</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-连续子数组的最大和"><a href="#1-连续子数组的最大和" class="headerlink" title="1. 连续子数组的最大和"></a>1. 连续子数组的最大和</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502150950334.png" alt="image-20220502150950334"></p><p><strong>解题思路:</strong></p><p>动态规划是本题的最优解法，以下按照标准流程解题。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502151330317.png" alt="解题流程"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/77d1aa6a444743d3c8606ac951cd7fc38faf68a62064fd2639df517cd666a4d0-Picture1.png" alt="Picture1.png"></p><p>实现</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dp<span class="token punctuation">;</span>        dp<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                res <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502153026571.png" alt="image-20220502153026571"></p><p><strong>空间内存优化版本:</strong></p><p>空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> res<span class="token punctuation">)</span> res <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502153702191.png" alt="image-20220502153702191"></p><hr><h3 id="2-礼物的最大价值"><a href="#2-礼物的最大价值" class="headerlink" title="2. 礼物的最大价值"></a>2. 礼物的最大价值</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1662cdf7aafd8c9ed6e1eadc41bfc9adf58ea808e11f1a3dd2e8ba4632b9d1ac-Picture1.png" alt="Picture1.png"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502154533328.png" alt="image-20220502154533328"></p><p>实现: </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxValue</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> i <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">==</span> j<span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> grid<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502164846692.png" alt="image-20220502164846692"></p><p>使dp数组比grid数组多一行一列，初始化为0，这样既可避免判断是不是在边界的问题:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxValue</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                         <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502165012493.png" alt="image-20220502165012493"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第九天-动态规划-中等&quot;&gt;&lt;a href=&quot;#第九天-动态规划-中等&quot; class=&quot;headerlink&quot; title=&quot;第九天_动态规划(中等)&quot;&gt;&lt;/a&gt;第九天_动态规划(中等)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href=&quot;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu美化教程</title>
    <link href="https://roranrui.cn/2022/05/01/ubuntu-mei-hua-jiao-cheng/"/>
    <id>https://roranrui.cn/2022/05/01/ubuntu-mei-hua-jiao-cheng/</id>
    <published>2022-05-01T13:26:36.000Z</published>
    <updated>2022-05-02T10:39:32.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu美化教程"><a href="#Ubuntu美化教程" class="headerlink" title="Ubuntu美化教程"></a>Ubuntu美化教程</h1><blockquote><p>  基于Ubuntu20.04.4LTS</p></blockquote><h2 id="一-壁纸美化"><a href="#一-壁纸美化" class="headerlink" title="一. 壁纸美化"></a>一. 壁纸美化</h2><h3 id="壁纸设置"><a href="#壁纸设置" class="headerlink" title="壁纸设置:"></a>壁纸设置:</h3><p>右键桌面-&gt;设置壁纸即可</p><p>效果: </p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/dsad.png" alt="dsad"></p><h3 id="登录背景修改"><a href="#登录背景修改" class="headerlink" title="登录背景修改"></a>登录背景修改</h3><p><strong>到这个网址下载一个包</strong>: <strong><a href="https://github.com/thiggy01/gdm-background">https://github.com/thiggy01/gdm-background</a></strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116230551731.png" alt="在这里插入图片描述"></p><p>解压</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/2021011623071684.png" alt="在这里插入图片描述"></p><p><strong>点击打开这个文件夹有以下文件 , 会看到有以下文件 :</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116230909852.png" alt="在这里插入图片描述"></p><p>终端中打开这个文件夹</p><p>安装编译包:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> <span class="token function">make</span> gcc libgtk-3-dev libpolkit-gobject-1-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116231935597.png" alt="在这里插入图片描述"></p><p>输入:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查版本</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116232037877.png" alt="在这里插入图片描述"></p><p>编译之前下载好的包:</p><pre class="line-numbers language-bash"><code class="language-bash"> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后就能找到<strong>GDM Background 这个软件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501224321364.png" alt="image-20220501224321364"></p><p><strong>然后将你喜欢的背景图片拖入到这个窗口里:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116232737497.png" alt="在这里插入图片描述"></p><p>之后就替换成功;</p><p>效果:</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/2022-05-02_18-37.png" alt="2022-05-02_18-37"></p><hr><h2 id="二-终端美化"><a href="#二-终端美化" class="headerlink" title="二. 终端美化"></a>二. 终端美化</h2><h3 id="配置安装oh-my-zsh"><a href="#配置安装oh-my-zsh" class="headerlink" title="配置安装oh-my-zsh"></a>配置安装oh-my-zsh</h3><blockquote><p>  人生苦短，我用zsh…<br>  zsh完全兼容bash，并且<a href="https://so.csdn.net/so/search?q=oh-my-zsh&amp;spm=1001.2101.3001.7020">oh-my-zsh</a>的功能比bash强大很多，赶紧来试试！</p></blockquote><p><strong>下载安装oh-my-zsh</strong></p><pre class="line-numbers language-bash"><code class="language-bash">sh -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">wget</span> -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh<span class="token variable">)</span></span>"</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若提示无法建立SSL连接，末尾再加上<code>--no-check-certificate</code>。原因是wget在使用HTTPS协议时，默认会去验证网站的证书，而这个证书验证经常会失败。加上该选项，就表示不检查。</p><p><strong>bash切换为zsh</strong><br>把默认bash更换为默认zsh，输入<code>chsh -s /bin/zsh</code>，不会立即生效，需要重启系统</p><p><strong>oh-my-zsh插件配置</strong><br>下载的插件都放在.oh-my-zsh/plugins/目录下，下面是几个常用的非常不错的插件。</p><p>autojump: <code>apt-get install autojump</code></p><p>autosuggestions: <code>git clone git://github.com/zsh-users/zsh-autosuggestions</code></p><p>自动语法高亮：<a href="https://github.com/zsh-users/zsh-syntax-highlighting">https://github.com/zsh-users/zsh-syntax-highlighting</a><br>自动输入建议：<a href="https://github.com/zsh-users/zsh-autosuggestions">https://github.com/zsh-users/zsh-autosuggestions</a><br>打开远程仓库：<a href="https://github.com/paulirish/git-open">https://github.com/paulirish/git-open</a></p><p>下载到指定目录后，编辑.zshrc文件如下，找到plugins字段：</p><pre class="line-numbers language-bash"><code class="language-bash">plugins<span class="token operator">=</span><span class="token punctuation">(</span>其他的插件 zsh-syntax-highlighting zsh-autosuggestions git-open autojump zsh-syntax-highlighting zsh-autosuggestions<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再<code>source ~/.zshrc</code>使配置生效</p><h3 id="安装xfce4"><a href="#安装xfce4" class="headerlink" title="安装xfce4"></a>安装xfce4</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update <span class="token comment" spellcheck="true">#更新软件源</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> xfce4-terminal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>配置</p><ul><li>在右下角的dash菜单栏中找到Xfce4终端；打开</li><li>在“编辑”—&gt;“首选项”—-&gt;“外观”—-&gt;”背景图片”选择你想设置的图片；</li><li>更多终端设置，自行探索；</li></ul><blockquote><p>  设置快捷键<br>  正常使用是我们按ctr(常用^表示)+Alt+T打开我们使用的终端；现在我们设置新终端的快捷方式；</p></blockquote><ul><li>在右上角–&gt;有线连接—-&gt;有线设置—-&gt;设备—&gt;键盘 将其选中</li><li>在键盘的最下面有个”+”加号；点击</li><li>然后输入：<br>名称：你想对快捷键设置的名字<br>命令：xfce4-terminal</li></ul><p>效果:</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502181409943.png" alt="image-20220502181409943"></p><hr><h2 id="三-软件生态"><a href="#三-软件生态" class="headerlink" title="三. 软件生态"></a>三. 软件生态</h2><h3 id="星火商店"><a href="#星火商店" class="headerlink" title="星火商店"></a>星火商店</h3><p>首先我们到官网下载星火商店以及依赖(20.04)：<a href="https://spark-app.store/">https://spark-app.store/</a></p><p>先安装依赖</p><p>然后再安装包</p><h3 id="deepin-wine"><a href="#deepin-wine" class="headerlink" title="deepin-wine"></a>deepin-wine</h3><p>可在星火商店下载</p><hr><h2 id="四-Dock栏优化"><a href="#四-Dock栏优化" class="headerlink" title="四. Dock栏优化"></a>四. Dock栏优化</h2><p>安装</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> dconf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>依次打开:</p><pre><code>/org/gnome/shell/extensions/dash-to-dock/</code></pre><p>个人配置:</p><pre class="line-numbers language-bash"><code class="language-bash">background-opacity 0  // 透明custom-background-color <span class="token boolean">true</span>customize-alphas <span class="token boolean">true</span>dock-fixed <span class="token boolean">true</span>dock-position <span class="token string">'BOTTOM'</span>extend-height <span class="token boolean">false</span>show-apps-at-top <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果:</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502182034386.png" alt="image-20220502182034386"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu美化教程&quot;&gt;&lt;a href=&quot;#Ubuntu美化教程&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu美化教程&quot;&gt;&lt;/a&gt;Ubuntu美化教程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  基于Ubuntu20.04.4LTS&lt;/p&gt;
</summary>
      
    
    
    
    <category term="美化教程" scheme="https://roranrui.cn/categories/%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="桌面美化" scheme="https://roranrui.cn/tags/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"/>
    
    <category term="经验分享" scheme="https://roranrui.cn/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>关于jetbrainsIDE的设置</title>
    <link href="https://roranrui.cn/2022/05/01/guan-yu-jetbrainside-de-gao-xiao-she-zhi/"/>
    <id>https://roranrui.cn/2022/05/01/guan-yu-jetbrainside-de-gao-xiao-she-zhi/</id>
    <published>2022-05-01T06:36:22.000Z</published>
    <updated>2022-05-01T13:33:42.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jetbrains-IDE设置"><a href="#jetbrains-IDE设置" class="headerlink" title="jetbrains IDE设置"></a>jetbrains IDE设置</h1><h2 id="一-美化"><a href="#一-美化" class="headerlink" title="一. 美化"></a>一. 美化</h2><h3 id="背景图像美化"><a href="#背景图像美化" class="headerlink" title="背景图像美化"></a>背景图像美化</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501143718297.png" alt="外观->背景图像"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501143841490.png" alt="效果"></p><h3 id="字体配色方案"><a href="#字体配色方案" class="headerlink" title="字体配色方案"></a>字体配色方案</h3><p><a href="https://github.com/topics/jetbrains-theme">指路</a></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501144625849.png" alt="编辑器->配色方案"></p><hr><h2 id="二-高效设置"><a href="#二-高效设置" class="headerlink" title="二. 高效设置"></a>二. 高效设置</h2><h3 id="调整窗口字体显示大小"><a href="#调整窗口字体显示大小" class="headerlink" title="调整窗口字体显示大小"></a>调整窗口字体显示大小</h3><p>巨好用的一个功能！强烈安利！</p><p>勾选上 <em>Preferences / Settings | Editor | General</em> 下的 <em>Change font size with Command + Mouse Wheel</em> 选项之后，我们就可以直接使用 <code>Ctrl+鼠标滚轮</code>(Windows&amp;Linux)来更改窗口字体的大小</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501145041883.png" alt="image-20220501145041883"></p><p>开启更改所有选项卡的字体大小功能</p><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>修改 <em>Preferences / Settings | Editor | Font</em> 选项下的字体设置，字体推荐使用 JetBrains Mono ，字体大小建议 16/18，根据个人需要选择是否需要开启连字。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501145148929.png" alt="image-20220501145148929"></p><h3 id="配置类注释模板"><a href="#配置类注释模板" class="headerlink" title="配置类注释模板"></a>配置类注释模板</h3><p>修改 <em>Preferences / Settings | Editor | File adn Code Templates</em> 下的 <code>Class</code> 和 <code>Enum</code> 的模板。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501150659503.png" alt="image-20220501150659503"></p><p>你可以根据自己的习惯对 IDEA 自带的编码模板进行修改，并且，你还可以添加新的编码模板来提高编码速度。非常实用！</p><h3 id="显示方法分割线"><a href="#显示方法分割线" class="headerlink" title="显示方法分割线"></a>显示方法分割线</h3><p>勾选上 <em>Preferences / Settings | Editor | General | Appearance</em> 下的 Show method separators 选项之后，方法分割线就有了，这会小幅提高代码的可读性。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501151302639.png" alt="image-20220501151302639"></p><hr><h2 id="三-插件推荐"><a href="#三-插件推荐" class="headerlink" title="三. 插件推荐"></a>三. 插件推荐</h2><p>在此仅推荐两个</p><h3 id="Tabnine：基于-AI-的代码提示"><a href="#Tabnine：基于-AI-的代码提示" class="headerlink" title="Tabnine：基于 AI 的代码提示"></a>Tabnine：基于 AI 的代码提示</h3><p>Tabnine 这个插件用于智能代码补全，它基于数百万 Java 程序，能够根据程序上下文提示补全代码。Tabnine 和 IDEA 自带的智能提示两者互补。</p><h3 id="Rainbow-Brackets-彩虹括号"><a href="#Rainbow-Brackets-彩虹括号" class="headerlink" title="Rainbow Brackets : 彩虹括号"></a>Rainbow Brackets : 彩虹括号</h3><p>使用各种鲜明的颜色来展示你的括号，效果图如下。可以看出代码层级变得更加清晰了，可以说非常实用友好了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jetbrains-IDE设置&quot;&gt;&lt;a href=&quot;#jetbrains-IDE设置&quot; class=&quot;headerlink&quot; title=&quot;jetbrains IDE设置&quot;&gt;&lt;/a&gt;jetbrains IDE设置&lt;/h1&gt;&lt;h2 id=&quot;一-美化&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="美化教程" scheme="https://roranrui.cn/categories/%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="经验分享" scheme="https://roranrui.cn/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    <category term="IDE美化" scheme="https://roranrui.cn/tags/IDE%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程进阶</title>
    <link href="https://roranrui.cn/2022/05/01/cpp-duo-xian-cheng-jin-jie/"/>
    <id>https://roranrui.cn/2022/05/01/cpp-duo-xian-cheng-jin-jie/</id>
    <published>2022-05-01T05:24:50.000Z</published>
    <updated>2022-05-01T06:16:50.907Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程进阶"><a href="#多线程进阶" class="headerlink" title="多线程进阶"></a>多线程进阶</h1><h2 id="一-条件变量"><a href="#一-条件变量" class="headerlink" title="一. 条件变量"></a>一. 条件变量</h2><blockquote><p>  重复加锁, 影响效率, 可通过双重锁定的方式, 减少加锁, 提升效率</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">IsoutMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 双重锁定, 提升效率</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">ulock1</span><span class="token punctuation">(</span>mtx1<span class="token punctuation">)</span><span class="token punctuation">;</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">ulock2</span><span class="token punctuation">(</span>mtx2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"删除元素 "</span> <span class="token operator">&lt;&lt;</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                mtx1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                mtx2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本方法仍不够完美, 以下给出更优的解决办法</p><h3 id="1-condition-variable"><a href="#1-condition-variable" class="headerlink" title="1. condition_variable"></a>1. condition_variable</h3><blockquote><p>  std::condition_variable实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">outMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> command <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">ulock1</span><span class="token punctuation">(</span>mtx1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果第二个参数lambda表达式返回值是false, 那么wait()将解锁互斥量, 并堵塞本行</span>            <span class="token comment" spellcheck="true">// 直到其他线程调用notify_one()为止</span>            my_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>ulock1<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            command <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ulock1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"删除元素 "</span> <span class="token operator">&lt;&lt;</span> command <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"END"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>wait()用来等一个东西</p><p>如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行<br>如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行。</p><p>阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止；</p><p>如果没有第二个参数，那么效果跟第二个参数lambda表达式返回false效果一样</p><p>wait()将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用notify_one()成员函数为止。</p><p>当其他线程用<code>notify_one()</code>将本线程wait()唤醒后，这个wait恢复后</p><ol><li><p>wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待获取，如果获取到了，那么wait()就继续执行，获取到了锁</p></li><li><p>如果wait有第二个参数就判断这个lambda表达式。</p><p>a)如果表达式为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify_one()唤醒<br>b)如果lambda表达式为true，则wait返回，流程可以继续执行（此时互斥量已被锁住）。</p></li><li><p>如果wait没有第二个参数，则wait返回，流程走下去。</p></li></ol><blockquote><p>  <strong>流程只要走到了wait()下面则互斥量一定被锁住了。</strong></p></blockquote><p>完整代码:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Msg "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" got."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">myGuard</span><span class="token punctuation">(</span>mtx1<span class="token punctuation">,</span> adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//            lock(mtx1, mtx2);</span>            msgRecvQueue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            my_cond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//            mtx1.unlock();</span><span class="token comment" spellcheck="true">//            mtx2.unlock();</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">outMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> command <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">ulock1</span><span class="token punctuation">(</span>mtx1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果第二个参数lambda表达式返回值是false, 那么wait()将解锁互斥量, 并堵塞本行</span>            <span class="token comment" spellcheck="true">// 直到其他线程调用notify_one()为止</span>            my_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>ulock1<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            command <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ulock1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"删除元素 "</span> <span class="token operator">&lt;&lt;</span> command <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"END"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> msgRecvQueue<span class="token punctuation">;</span>    mutex mtx1<span class="token punctuation">;</span>    mutex mtx2<span class="token punctuation">;</span>    condition_variable my_cond<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 生成一个条件变量对象</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    A my_a<span class="token punctuation">;</span>    thread <span class="token function">ts1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>outMsg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>my_a<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">ts2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>getMsg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>my_a<span class="token punctuation">)</span><span class="token punctuation">;</span>    ts1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ts2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、深入思考</p><p>上面的代码可能导致出现一种情况：<br>因为outMsg()与getMsg()并不是一对一执行的，所以当程序循环执行很多次以后，可能在msgRecvQueue 中已经有了很多消息，但是，outMsg()还是被唤醒一次只处理一条数据。这时可以考虑把outMsg()多执行几次，或者对getMsg()进行限流。</p><h4 id="notify-all"><a href="#notify-all" class="headerlink" title="notify_all()"></a>notify_all()</h4><blockquote><p>  notify_one()：通知一个线程的wait()</p><p>  notify_all()：通知所有线程的wait()</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程进阶&quot;&gt;&lt;a href=&quot;#多线程进阶&quot; class=&quot;headerlink&quot; title=&quot;多线程进阶&quot;&gt;&lt;/a&gt;多线程进阶&lt;/h1&gt;&lt;h2 id=&quot;一-条件变量&quot;&gt;&lt;a href=&quot;#一-条件变量&quot; class=&quot;headerlink&quot; title=&quot;一</summary>
      
    
    
    
    <category term="语言学习" scheme="https://roranrui.cn/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>第八天_动态规划（简单）</title>
    <link href="https://roranrui.cn/2022/05/01/shua-ti-bi-ji-ba/"/>
    <id>https://roranrui.cn/2022/05/01/shua-ti-bi-ji-ba/</id>
    <published>2022-05-01T02:14:35.000Z</published>
    <updated>2022-05-01T03:50:09.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八天-动态规划（简单）"><a href="#第八天-动态规划（简单）" class="headerlink" title="第八天_动态规划（简单）"></a>第八天_动态规划（简单）</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote><p>  动态规划是算法与数据结构的重难点之一，其包含了「分治思想」、「空间换时间」、「最优解」等多种基石算法思想</p></blockquote><p><strong>动态规划特点</strong><br>「分治」是算法中的一种基本思想，其通过将<strong>原问题分解为子问题</strong>，不断递归地将子问题分解为更小的子问题，并通过<strong>组合子问题的解</strong>来得到原问题的解。</p><p>类似于分治算法，「动态规划」也通过组合子问题的解得到原问题的解。不同的是，适合用动态规划解决的问题具有「重叠子问题」和「最优子结构」两大特性。</p><p><strong>重叠子问题</strong><br>动态规划的子问题是有重叠的，即各个子问题中包含重复的更小子问题。若使用暴力法穷举，求解这些相同子问题会产生大量的重复计算，效率低下。</p><h4 id="重叠子问题示例：斐波那契数列"><a href="#重叠子问题示例：斐波那契数列" class="headerlink" title="重叠子问题示例：斐波那契数列"></a><strong>重叠子问题示例：斐波那契数列</strong></h4><blockquote><p>  斐波那契数形成的数列为 [0,1,1,2,3,5,8,13,⋯] ，数学定义如下：</p><p>  F_0 = 0  </p><p>  F_1 = 1 </p><p>  F_n = F{n-1} + F{n-2} </p></blockquote><p><strong>解题思路:</strong></p><p><strong>1.暴力递归</strong></p><p>设斐波那契数列第 n 个数字为 f(n) 。根据数列定义，可得 f(n) = f(n - 1) + f(n - 2)，且第 0 , 1 个斐波那契数分别为 f(0) = 0, f(1) = 1 。</p><p>我们很容易联想到使用分治思想来求取 f(n)f(n) ，即将求原问题 f(n) 分解为求子问题 f(n-1)和 f(n-2)，向下递归直至已知的 f(0) 和 f(1) ，最终组合这些子问题求取原问题 f(n)</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 f(0)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 f(1)</span>    <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分解为两个子问题求解</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 超时</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1635075778-GADtbi-Picture1.png" alt="Picture1.png"></p><p>如上图所示，为暴力递归求斐波那契数 f(5)形成的二叉树，树中的每个节点代表着执行了一次 fibonacci() 函数，且有：</p><ul><li>执行一次 fibonacci() 函数的时间复杂度为 O(1) ；</li></ul><p>二叉树节点数为指数级 O(2^n)<br>因此，暴力递归的总体时间复杂度为 O(2^n) 。此方法效率低下，随着 nn的增长产生指数级爆炸。</p><p><strong>2.记忆化递归</strong></p><p>观察发现，暴力递归中的子问题多数都是重叠子问题，即：</p><blockquote><p>  f(n)=f(n−1)+f(n−2)<br>  f(n−1)=f(n−2)+f(n−3)<br>  f(n−2)=f(n−3)+f(n−4)<br>  ⋯<br>  以此类推</p></blockquote><p>这些重叠子问题产生了大量的递归树节点，其不应被重复计算。实际上，可以在递归中第一次求解子问题时，就将它们保存；后续递归中再次遇到相同子问题时，直接访问内存赋值即可。</p><pre><code>int fibonacci(int n, vector&lt;int&gt; dp) {    if (n == 0) return 0;           // 返回 f(0)    if (n == 1) return 1;           // 返回 f(1)    if (dp[n] != 0) return dp[n];   // 若 f(n) 以前已经计算过，则直接返回记录的解    dp[n] = fibonacci(n - 1, dp) + fibonacci(n - 2, dp); // 将 f(n) 则记录至 dp    return dp[n];}// 求第 n 个斐波那契数int fibonacciMemorized(int n) {    vector&lt;int&gt; dp(n + 1, 0); // 用于保存 f(0) 至 f(n) 问题的解    return fibonacci(n, dp);}</code></pre><p>如下图所示，应用记忆化递归方法后，递归树中绝大部分节点被剪枝。此时，fibonacci() 函数的调用次数从 O(2^n)指数级别降低至 O(n) 线性级别，时间复杂度大大降低。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1635075778-pJXkPc-Picture2.png" alt="Picture2.png"></p><p>3.动态规划</p><p>递归本质上是基于分治思想的从顶至底的解法。借助记忆化递归思想，可应用动态规划从底至顶求取 f(n)，代码如下所示。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 求第 n 个斐波那契数</span><span class="token keyword">int</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 若求 f(0) 则直接返回 0</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 初始化 dp 列表</span>    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 初始化 f(0), f(1)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 状态转移求取 f(2), f(3), ..., f(n) </span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 返回 f(n)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态规划在第一次求解某子问题时，会将子问题的解保存；后续遇到重叠子问题时，则直接通过查表获取解，保证每个<strong>独立子问题只被计算一次</strong>，从而降低算法的时间复杂度。</p><hr><p><strong>最优子结构</strong><br>如果一个问题的最优解可以由其子问题的最优解组合构成，并且这些子问题可以独立求解，那么称此问题具有最优子结构。</p><p>动态规划从基础问题的解开始，不断迭代<strong>组合、选择子问题的最优解</strong>，最终得到原问题最优解。</p><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1. 斐波那契数列"></a>1. 斐波那契数列</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501102703899.png" alt="image-20220501102703899"></p><p>解题思路:</p><p>采用<strong>动态规划</strong></p><p>循环求余法：<br>大数越界： 随着 n 增大, f(n) 会超过 Int32 甚至 Int64 的取值范围，导致最终的返回值错误。</p><p>求余运算规则： 设正整数 x, y, p，求余符号为⊙ ，则有 (x+y)⊙p=(x⊙p+y⊙p)⊙p 。</p><p>解析： 根据以上规则，可推出f(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙p ，从而可以在循环过程中每次计算 sum=(a+b)⊙1000000007 ，此操作与最终返回前取余等价。</p><p>复杂度分析：</p><p>时间复杂度 O(n) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。<br>空间复杂度 O(N) ： 数组dp使用N的空间;</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 若求 f(0) 则直接返回 0</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 初始化 dp 列表</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 初始化 f(0), f(1)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 状态转移求取 f(2), f(3), ..., f(n) </span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501110203286.png" alt="image-20220501110203286"></p><p><strong>空间内存优化版本:</strong></p><p>空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> sum<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sum <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>            a <span class="token operator">=</span> b<span class="token punctuation">;</span>            b <span class="token operator">=</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501110420369.png" alt="image-20220501110420369"></p><hr><h3 id="2-青蛙跳台阶问题"><a href="#2-青蛙跳台阶问题" class="headerlink" title="2. 青蛙跳台阶问题"></a>2. 青蛙跳台阶问题</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501110605583.png" alt="image-20220501110605583"></p><p><strong>解题思路:</strong><br>设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。</p><p>当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n-1) 种跳法；<br>当为 2 级台阶： 剩 n-2 个台阶，此情况共有 f(n-2)种跳法。</p><p>由此, 可转化为<strong>斐波那契数列问题</strong></p><blockquote><p>  区别:</p><ul><li>青蛙跳台阶问题： f(0)=1 f(1)=1 , f(2)=2 ；</li><li>斐波那契数列问题： f(0)=0 , f(1)=1 , f(2)=1 。</li></ul></blockquote><p>复杂度分析：</p><p>时间复杂度 O(n) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。<br>空间复杂度 O(N) ： 数组dp使用N的空间;</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599883153-UckfTw-Picture1.png" alt="Picture1.png"></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numWays</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501114501605.png" alt="image-20220501114501605"></p><p><strong>空间内存优化版本:</strong></p><p>空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numWays</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> sum<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sum <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>            a <span class="token operator">=</span> b<span class="token punctuation">;</span>            b <span class="token operator">=</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-股票的最大利润"><a href="#3-股票的最大利润" class="headerlink" title="3. 股票的最大利润"></a>3. 股票的最大利润</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501111755367.png" alt="image-20220501111755367"></p><p><strong>解题思路:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501112220955.png" alt="image-20220501112220955"></p><blockquote><p>  动态规划解析：</p><p>  状态定义： 设动态规划列表 dp ，dp[i]代表以 prices[i]为结尾的子数组的最大利润（以下简称为 前 i 日的最大利润 ）。<br>  转移方程： 由于题目限定 “买卖该股票一次” ，因此前 i日最大利润 dp[i]等于前 i - 1日最大利润 dp[i-1] 和第 i日卖出的最大利润中的最大值。<br>  dp[i] = max(dp[i - 1], prices[i] - min(prices[0:i])) </p><p>  前 i 日最大利润 = max(前 (i-1) 日最大利润, 第 i 日价格 - 前 i 日最低价格)</p><p>  初始状态： dp[0] = 0，即首日利润为 0 ；<br>  返回值： dp[n - 1]，其中 n 为 dp列表长度。</p></blockquote><p>复杂度分析：</p><p>时间复杂度 O(n) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。<br>空间复杂度 O(N) ： 数组dp使用N的空间;</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 只有1天怎么买卖?</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dp<span class="token punctuation">;</span>        dp<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cost <span class="token operator">=</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cost <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>cost<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501114517412.png" alt="image-20220501114517412"></p><p><strong>空间内存优化版本:</strong></p><p>空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cost <span class="token operator">=</span> INT_MAX<span class="token punctuation">,</span> profit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> price <span class="token operator">:</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cost <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>cost<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>            profit <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>profit<span class="token punctuation">,</span> price <span class="token operator">-</span> cost<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> profit<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501114529197.png" alt="image-20220501114529197"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第八天-动态规划（简单）&quot;&gt;&lt;a href=&quot;#第八天-动态规划（简单）&quot; class=&quot;headerlink&quot; title=&quot;第八天_动态规划（简单）&quot;&gt;&lt;/a&gt;第八天_动态规划（简单）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第七天_搜索与回溯算法（简单）</title>
    <link href="https://roranrui.cn/2022/04/30/shua-ti-bi-ji-qi/"/>
    <id>https://roranrui.cn/2022/04/30/shua-ti-bi-ji-qi/</id>
    <published>2022-04-30T07:09:52.000Z</published>
    <updated>2022-04-30T09:21:07.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七天-搜索与回溯算法（简单）"><a href="#第七天-搜索与回溯算法（简单）" class="headerlink" title="第七天_搜索与回溯算法（简单）"></a>第七天_搜索与回溯算法（简单）</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><blockquote><p>  <strong>深度优先搜索算法</strong>（Depth First Search，简称<a href="https://so.csdn.net/so/search?q=DFS&amp;spm=1001.2101.3001.7020">DFS</a>）：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况算法时间复杂度为O(N!)。</p><p>  <strong>所谓DFS就是指：优先考虑深度，换句话说就是一条路走到黑，直到无路可走的情况下，才会选择回头，然后重新选择一条路</strong></p></blockquote><p>例子:</p><p>全排列: 输入一个数n，输出n的全排列</p><p>假如有编号为1,2,3的3张扑克牌和编号为1,2,3的3个盒子。将这3张扑克牌分别放入3个盒子一共有几种不同的放法呢？</p><p>约定：每次到一个盒子面前时，都先放1号，2号，最后放3号</p><p><strong>1.第一种：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20200815181435796.png" alt="首先呢，小明手中有3张扑克牌"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20200815181540751.png" alt="先到第1个盒子，将1号扑克牌放在第1个盒子。"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20200815181625696.png" alt="放好后，小明继续向前走一步，来到了2号盒子，按照之前的约定放2号扑克牌。"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20200815181745240.png" alt="放好后，小明又继续向前一步，把3号扑克牌放入3号盒子。此时就已经完成了一种排列。"></p><p>完成第一种后,还没有结束！小明便要回头了，开始重新选择（DFS的思想），这里要注意的，不是把所有的牌都取出来重新放，这样就不符合<strong>DFS</strong>的思想了。</p><p><strong>2.第2种</strong><br>好的！按照上面的逻辑。小明将3号盒子的3号扑克牌取出，但手上仍然只有3号扑克牌。<br>所以小明只好回到2号盒子，收回2号扑克牌，此时手中有2,3号扑克牌。<br>按照之前的约定，往2号盒子放3号扑克牌，然后小明又继续往前走，此时手里只有2号扑克牌，把2号扑克牌放入3号盒子里，此时完成了第二种排序。*<br>按照这种逻辑，我们不难求出所有排列“123”，“132”，“213”，“231”，“312”，“321”;</p><blockquote><p>  BFS是按照层来遍历，“ 如果你愿意一层一层一层的剥开我的心”对！就像洋葱，一层层地遍历。那还有其他的遍历方式吗？当然还有，就是<strong>递归遍历</strong></p></blockquote><p><strong>DFS—深度优先遍历</strong><br>二叉树的深度优先遍历方式有三个：</p><ul><li>前序遍历<br>PreOrder(T) = T的根结点+PreOrder（T的左子树）+PreOrder（T的右子树）</li><li>-中序遍历<br>InOrder(T) = InOrder（T的左子树）+ T的根结点 + InOrder（T的右子树）</li><li>-后序遍历<br>PostOrder(T) =PostOrder（T的左子树）+ PostOrder（T的右子树）+ T的根结点</li></ul><p><strong>可见这些遍历的方式都运用了递归的方式。</strong></p><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">LeetCode144. 二叉树的前序遍历链接入口</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">LeetCode94. 二叉树的中序遍历链接入口</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">LeetCode145. 二叉树的后序遍历链接入口</a></p><h3 id="二叉树镜像"><a href="#二叉树镜像" class="headerlink" title="二叉树镜像"></a><strong>二叉树镜像</strong></h3><blockquote><p>  二叉树镜像定义： 对于二叉树中任意节点 root，设其左 / 右子节点分别为 left, right；则在二叉树的镜像中的对应 root节点，其左 / 右子节点分别为 right, left。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20717714d97fa04d509e4f0525a3089efefc2ea02cc08ce92b77978e9b51f15f-Picture1.png" alt="Picture1.png"></p><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><blockquote><p>  <strong>对称二叉树定义：</strong> 对于树中 任意两个对称节点 L 和 R ，一定有：</p><p>  L.val = R.val ：即此两对称节点值相等。<br>  L.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；<br>  L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599398062-PbkpuX-Picture1.png" alt="Picture1.png"></p><hr><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-树的子结构"><a href="#1-树的子结构" class="headerlink" title="1. 树的子结构"></a>1. 树的子结构</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430155705066.png" alt="image-20220430155705066"></p><p><strong>解题思路:</strong></p><p>若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p><p>先序遍历树 A 中的每个节点 n_A；（对应函数 <code>isSubStructure(A, B)</code>）<br>判断树<strong>以 n_A为根节点的子树</strong> 是否包含树 <code>B</code> 。（对应函数 <code>recur(A, B)</code>）</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599290566-VhWsiQ-Picture1.png" alt="Picture1.png"></p><blockquote><p>  <strong>算法流程：</strong></p><p>  recur(A, B) 函数：</p><ol><li>终止条件：<ol><li>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；</li><li>当节点 A 为空：说明已经越过树 A 的叶节点，即匹配失败，返回 false ；</li><li>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li></ol></li><li>返回值：<ol><li>判断 A 和 B 的 左子节点 是否相等，即 recur(A.left, B.left) ；</li><li>判断 A 和 B 的 右子节点 是否相等，即 recur(A.right, B.right) ；</li></ol></li></ol><p>  isSubStructure(A, B) 函数：</p><ol><li>特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false ；</li><li>返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<ol><li>以 节点 A 为根节点的子树 包含树 B ，对应 recur(A, B)；</li><li>树 B 是 树 A 左子树 的子结构，对应 isSubStructure(A.left, B)；</li><li>树 B 是 树 A 右子树 的子结构，对应 isSubStructure(A.right, B)；</li></ol></li></ol><blockquote><p>  以上 2. 3. 实质上是在对树 A 做 先序遍历 。</p></blockquote></blockquote><p><strong>复杂度分析：</strong><br>时间复杂度 O(MN) ： 其中 M, N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N) 。<br>空间复杂度 O(M) ： 当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N时，最差情况为遍历至树 A 的叶节点，此时总递归深度为 M。</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> A<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> B<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>A <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> B <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>A<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>A<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">recur</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> A<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> B<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>B <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>A <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> A<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">!=</span> B<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// return (A->left == B->left &amp;&amp; A->right == B->right) ? true : false;</span>        <span class="token comment" spellcheck="true">// 以下是高级写法</span>        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>A<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> B<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">recur</span><span class="token punctuation">(</span>A<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> B<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430162344187.png" alt="image-20220430162344187"></p><hr><h3 id="2-二叉树的镜像"><a href="#2-二叉树的镜像" class="headerlink" title="2. 二叉树的镜像"></a>2. 二叉树的镜像</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430162543617.png" alt="image-20220430162543617"></p><p><strong>解题思路:</strong></p><p><strong>1.递归法</strong></p><ul><li>根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 / 右子节点，即可生成二叉树的镜像。</li></ul><blockquote><p>  递归解析：</p><ol><li>终止条件： 当节点 root为空时（即越过叶节点），则返回 null；</li><li>递推工作：<ol><li>初始化节点 tmp，用于暂存 root的左子节点；</li><li>开启递归 右子节点 mirrorTree(root.right)，并将返回值作为 root的 左子节点 。</li><li>开启递归 左子节点 mirrorTree(tmp)，并将返回值作为 root的 右子节点 。</li></ol></li><li>返回值： 返回当前节点 root；</li></ol><blockquote><p>  Q： 为何需要暂存 root 的左子节点？<br>  A： 在递归右子节点 “root.left = mirrorTree(root.right);” 执行完毕后， root.left 的值已经发生改变，此时递归左子节点 mirrorTree(root.left)则会出问题。</p></blockquote></blockquote><p>复杂度分析：<br>时间复杂度 O(N)： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N)时间。<br>空间复杂度 O(N)： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(N)大小的栈空间。</p><p><strong>2.辅助栈（或队列）</strong></p><ul><li>利用栈（或队列）遍历树的所有节点 node，并交换每个 node的左 / 右子节点。</li></ul><blockquote><p>  <strong>算法流程：</strong></p><ol><li>特例处理： 当 root 为空时，直接返回 null ；</li><li>初始化： 栈（或队列），本文用栈，并加入根节点 root 。</li><li>循环交换： 当栈 stack 为空时跳出；<ol><li>出栈： 记为 node；</li><li>添加子节点： 将 node 左和右子节点入栈；</li><li>交换： 交换 node 的左 / 右子节点。</li></ol></li><li>返回值： 返回根节点 root 。</li></ol></blockquote><p>复杂度分析：<br>时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。<br>空间复杂度 O(N) ： 如下图所示，最差情况下，栈 stack 最多同时存储 (N+1)/2个节点，占用 O(N)额外空间。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1614450330-bTAcyj-Picture0.png" alt="Picture0.png"></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> temp <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430165722375.png" alt="image-20220430165722375"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span> <span class="token operator">></span> stk<span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> temp <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430170935957.png" alt="image-20220430170935957"></p><hr><h3 id="3-对称的二叉树"><a href="#3-对称的二叉树" class="headerlink" title="3. 对称的二叉树"></a>3. 对称的二叉树</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430171015514.png" alt="image-20220430171015514"></p><p><strong>解题思路:</strong></p><p>根据对称二叉树的规律，考虑从顶至底递归，判断每对左右节点是否对称，从而判断树是否为对称二叉树。</p><blockquote><p>  算法流程：<br>  isSymmetric(root) ：</p><ul><li>特例处理： 若根节点 root 为空，则直接返回 true 。</li><li>返回值： 即 recur(root.left, root.right) ;</li></ul><p>  recur(L, R) ：</p><ul><li>终止条件：<ul><li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li><li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；</li><li>当节点 L 值 != 节点 R 值： 此树不对称，因此返回 false ；</li></ul></li><li>递推工作：<ul><li>判断两节点 L.left 和 R.right 是否对称，即 recur(L.left, R.right) ；</li><li>判断两节点 L.right 和 R.left 是否对称，即 recur(L.right, R.left) ；</li></ul></li><li>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp;&amp; 连接。</li></ul></blockquote><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">recur</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> L<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> R<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> R <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> R <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> L<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">!=</span> R<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>L<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> R<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">recur</span><span class="token punctuation">(</span>L<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> R<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430172100882.png" alt="image-20220430172100882"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第七天-搜索与回溯算法（简单）&quot;&gt;&lt;a href=&quot;#第七天-搜索与回溯算法（简单）&quot; class=&quot;headerlink&quot; title=&quot;第七天_搜索与回溯算法（简单）&quot;&gt;&lt;/a&gt;第七天_搜索与回溯算法（简单）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第六天_搜索与回溯算法（简单）</title>
    <link href="https://roranrui.cn/2022/04/29/shua-ti-bi-ji-liu/"/>
    <id>https://roranrui.cn/2022/04/29/shua-ti-bi-ji-liu/</id>
    <published>2022-04-29T12:11:27.000Z</published>
    <updated>2022-04-30T08:53:15.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六天-搜索与回溯算法（简单）"><a href="#第六天-搜索与回溯算法（简单）" class="headerlink" title="第六天_搜索与回溯算法（简单）"></a>第六天_搜索与回溯算法（简单）</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><blockquote><p>  广度优先搜索算法（Breadth-First Search，BFS）是一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。BFS并不使用经验法则算法。</p></blockquote><p>广度优先搜索让你能够找出两样东西之间的最短距离，不过最短距离的含义有很多！使用广度优先搜索可以：</p><ol><li>编写国际跳棋AI，计算最少走多少步就可获胜；</li><li>编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词，如将READED改为READER需要编辑一个地方；</li><li>根据你的人际关系网络找到关系最近的医生。</li></ol><p>你经常要找出最短路径，这可能是前往朋友家的最短路径，也可能是国际象棋中把对方将死的最少步数。解决最短路径问题的算法被称为<strong>广度优先搜索</strong>。要确定如何从双子峰前往金门大桥，需要两个步骤。</p><ol><li>使用图来建立问题模型。</li><li>使用广度优先搜索解决问题。</li></ol><blockquote><p>  例子:<br>  假设你经营着一个芒果农场，需要寻找芒果销售商，以便将芒果卖给他。在Facebook，你与芒果销售商有联系吗？为此，你可在朋友中查找。</p><p>  <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20190425130541285.png" alt="img"></p><p>  这种查找很简单。首先，创建一个朋友名单。</p><p>  <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20190425130557936.png"></p><p>   然后，依次检查名单中的每个人，看看他是否是芒果销售商。</p><p>  <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20190425130627134.png" alt="img"></p><p>   假设你没有朋友是芒果销售商，那么你就必须在朋友的朋友中查找。</p><p>  <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20190425130708732.png" alt="img"></p><p>   检查名单中的每个人时，你都将其朋友加入名单。</p><p>  <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20190425130746766.png" alt="img"></p><p>   这样一来，你不仅在朋友中查找，还在朋友的朋友中查找。别忘了，你的目标是在你的人际关系网中找到一位芒果销售商。因此，如果Alice不是芒果销售商，就将其朋友也加入到名单中。这意味着你将在她的朋友、朋友的朋友等中查找。使用这种算法将搜遍你的整个人际关系网，直到找到芒果销售商。这就是广度优先搜索算法。</p></blockquote><hr><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-从上到下打印二叉树"><a href="#1-从上到下打印二叉树" class="headerlink" title="1. 从上到下打印二叉树"></a>1. 从上到下打印二叉树</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429203424978.png" alt="image-20220429203424978"></p><p><strong>解题思路</strong>：</p><p>题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。<br>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/a872b50fa42011748437ec9123d8f77a104b3d528880efca8b212f91d115f835-Picture1.png" alt="Picture1.png"></p><blockquote><p>  <strong>算法流程：</strong><br>  特例处理： 当树的根节点为空，则直接返回空列表 [] ；<br>  初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；<br>  BFS 循环： 当队列 queue 为空时跳出；<br>  出队： 队首元素出队，记为 node；<br>  打印： 将 node.val 添加至列表 tmp 尾部；<br>  添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；<br>  返回值： 返回打印结果列表 res 即可。</p></blockquote><p><strong>复杂度分析：</strong><br>时间复杂度 O(N)： N 为二叉树的节点数量，即 BFS 需循环 N次。<br>空间复杂度 O(N) ： 最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N)大小的额外空间。</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429205407937.png" alt="image-20220429205407937"></p><hr><h3 id="2-从上到下打印二叉树-II"><a href="#2-从上到下打印二叉树-II" class="headerlink" title="2. 从上到下打印二叉树 II"></a>2. 从上到下打印二叉树 II</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429205019586.png" alt="image-20220429205019586"></p><p><strong>解题思路:</strong></p><p>本题与上一题仅有微小区别: 即本题需将 <strong>每一层打印到一行</strong> 。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/a58477c74c96779c265ce3028def7625d16042895d2c21f7fb0293df7b213276-Picture1.png" alt="Picture1.png"></p><p><strong>每层打印到一行：</strong> 将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</p><blockquote><p>  算法流程：<br>  特例处理： 当根节点为空，则返回空列表 [] ；<br>  初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；<br>  BFS 循环： 当队列 queue 为空时跳出；<br>  新建一个临时列表 tmp ，用于存储当前层打印结果；<br>  当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）；<br>  出队： 队首元素出队，记为 node；<br>  打印： 将 node.val 添加至 tmp 尾部；<br>  添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；<br>  将当前层结果 tmp 添加入 res 。</p><p>  <strong>返回值：</strong> 返回打印结果列表 <code>res</code> 即可。</p></blockquote><p>复杂度分析：<br>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次。<br>空间复杂度 O(N) ： 最差情况下，即当树为平衡二叉树时，最多有 N/2个树节点同时在 queue 中，使用 O(N)大小的额外空间。</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> temp<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                temp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            temp<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> temp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  如果写成for(int i = 0;i&lt;queue.size();i++),则每次进行for循环时，条件判断都会算一下queue.size()，但是每次for循环后queue长度可能会发生变化（添加左右节点），queue.size()一直在变化；</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429210627203.png" alt="image-20220429210627203"></p><hr><h3 id="3-从上到下打印二叉树-III"><a href="#3-从上到下打印二叉树-III" class="headerlink" title="3. 从上到下打印二叉树 III"></a>3. 从上到下打印二叉树 III</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429210759722.png" alt="image-20220429210759722"></p><p><strong>解题思路:</strong></p><p>本题额外要求 <strong>打印顺序交替变化</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/9513dcb034f5dcdea947a2f667b3d380df4f8732da6397778e00718b77584010-Picture1.png" alt="Picture1.png"></p><p>层序遍历 + 双端队列</p><ul><li>利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列）temp，并规定：<ul><li>奇数层 则添加至 <code>tmp</code> <strong>尾部</strong> ，</li><li>偶数层 则添加至 <code>tmp</code> <strong>头部</strong> 。</li></ul></li></ul><blockquote><p>  算法流程：<br>  特例处理： 当树的根节点为空，则直接返回空列表 [] ；<br>  初始化： 打印结果空列表 res ，包含根节点的双端队列 deque ；<br>  BFS 循环： 当 deque 为空时跳出；<br>  新建列表 tmp ，用于临时存储当前层打印结果；<br>  当前层打印循环： 循环次数为当前层节点数（即 deque 长度）；<br>  出队： 队首元素出队，记为 node；<br>  打印： 若为奇数层，将 node.val 添加至 tmp 尾部；否则，添加至 tmp 头部；<br>  添加子节点： 若 node 的左（右）子节点不为空，则加入 deque ；<br>  将当前层结果 tmp 转化为 list 并添加入 res ；<br>  返回值： 返回打印结果列表 res 即可；</p></blockquote><p><strong>复杂度分析：</strong><br>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) ；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。<br>空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点 同时 在 deque 中，使用 O(N) 大小的额外空间。</p><blockquote><p>  需要判断每个节点的所在层奇偶性，即冗余了 N 次判断。</p><p>  优化: 通过将奇偶层逻辑拆分，可以消除冗余的判断。</p></blockquote><blockquote><p>  <strong>算法流程(优化)：</strong><br>  与方法一对比，仅 BFS 循环不同。</p><p>  BFS 循环： 循环打印奇 / 偶数层，当 deque 为空时跳出；<br>  打印奇数层： 从左向右 打印，先左后右 加入下层节点；<br>  若 deque 为空，说明向下无偶数层，则跳出；<br>  打印偶数层： 从右向左 打印，先右后左 加入下层节点；</p></blockquote><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>        deque <span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> dque<span class="token punctuation">;</span>        vector <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> temp<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            dque<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>dque<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 打印奇数层</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> dque<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 左到y</span>                TreeNode <span class="token operator">*</span> node <span class="token operator">=</span> dque<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dque<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                temp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> dque<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> dque<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dque<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            temp<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 打印偶数层</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> dque<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 右到左</span>                TreeNode <span class="token operator">*</span> node <span class="token operator">=</span> dque<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dque<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                temp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> dque<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> dque<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            temp<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第六天-搜索与回溯算法（简单）&quot;&gt;&lt;a href=&quot;#第六天-搜索与回溯算法（简单）&quot; class=&quot;headerlink&quot; title=&quot;第六天_搜索与回溯算法（简单）&quot;&gt;&lt;/a&gt;第六天_搜索与回溯算法（简单）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第五天_查找算法(中等)</title>
    <link href="https://roranrui.cn/2022/04/29/shua-ti-bi-ji-wu/"/>
    <id>https://roranrui.cn/2022/04/29/shua-ti-bi-ji-wu/</id>
    <published>2022-04-29T05:31:40.000Z</published>
    <updated>2022-04-30T08:41:41.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五天-查找算法-中等"><a href="#第五天-查找算法-中等" class="headerlink" title="第五天_查找算法(中等)"></a>第五天_查找算法(中等)</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><blockquote><p>  树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> TreeNode <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 节点值</span>    TreeNode <span class="token operator">*</span>left<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 左子节点</span>    TreeNode <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 右子节点</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如下图所示，建立此二叉树需要实例化每个节点，并构建各节点的引用指向。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 初始化节点</span>TreeNode <span class="token operator">*</span>n1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 根节点 root</span>TreeNode <span class="token operator">*</span>n2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>TreeNode <span class="token operator">*</span>n3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>TreeNode <span class="token operator">*</span>n4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>TreeNode <span class="token operator">*</span>n5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 构建引用指向</span>n1<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> n2<span class="token punctuation">;</span>n1<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> n3<span class="token punctuation">;</span>n2<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> n4<span class="token punctuation">;</span>n2<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> n5<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599579136-bBARpC-Picture6.png" alt="Picture6.png"></p><h3 id="二叉树查找算法"><a href="#二叉树查找算法" class="headerlink" title="二叉树查找算法"></a>二叉树查找算法</h3><blockquote><p>  ​       二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。</p></blockquote><p>原理：<br>    二叉查找树（BinarySearch Tree，也叫二叉搜索树 BST，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：</p><p> 　1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br> 　2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>　3. 任意节点的左、右子树也分别为二叉查找树；</p><ol start="4"><li>没有键值相等的节点（no duplicate nodes)。</li></ol><p>BST 中实现查找元素：<br>根据BST的特性，对于每个节点：</p><ol><li>如果目标值等于节点的值，则返回节点</li><li>如果目标值小于节点的值，则继续在左子树中搜索</li><li>如果目标值大于节点的值，则继续在右子树中搜索</li></ol><p>在上面的二叉搜索树中搜索目标值为 4 的节点<br><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/bst_search-a1.png" alt="img"></p><hr><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429133221263.png" alt="image-20220429133221263"></p><p><strong>解题思路:</strong></p><p>1.暴力遍历</p><p><strong>时间复杂度: O(NM)</strong></p><p>2.二叉树查找</p><p>如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 <code>target</code> 大的元素就向左，反之向右，即可找到目标值 <code>target</code> 。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="Picture1.png"></p><blockquote><p>  “根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 标志数 ，以 matrix 中的 左下角元素 为标志数 flag ，则有:</p><p>  若 flag &gt; target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。<br>  若 flag &lt; target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。</p></blockquote><blockquote><p>  算法流程：<br>  从矩阵 matrix 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比：<br>  当 matrix[i][j] &gt; target 时，执行 i– ，即消去第 i 行元素；<br>  当 matrix[i][j] &lt; target 时，执行 j++ ，即消去第 j 列元素；<br>  当 matrix[i][j] = target 时，返回 true ，代表找到目标值。</p></blockquote><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429165026207.png" alt="image-20220429165026207"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span> i <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>           <span class="token punctuation">{</span>               j<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span>            <span class="token punctuation">{</span>               i<span class="token operator">--</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:/Users/13993/AppData/Roaming/Typora/typora-user-images/image-20220429165645971.png" alt="image-20220429165645971"></p><hr><h3 id="2-旋转数组的最小数字"><a href="#2-旋转数组的最小数字" class="headerlink" title="2.  旋转数组的最小数字"></a>2.  旋转数组的最小数字</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429170934614.png" alt="image-20220429170934614"></p><p><strong>解题思路</strong>:</p><p>1.暴力查找</p><p><strong>时间复杂度</strong>: O(N)</p><p>2.二分查找</p><p>如下图所示，寻找旋转数组的最小元素即为寻找 <strong>右排序数组</strong> 的首个元素 nums[x] ，称 x 为 <strong>旋转点</strong> 。</p><blockquote><p>  排序数组的查找问题首先考虑使用 <strong>二分法</strong> 解决，其可将 <strong>遍历法</strong> 的 <strong>线性级别</strong> 时间复杂度降低至 <strong>对数级别</strong> 。</p></blockquote><blockquote><p>  算法流程：<br>  初始化： 声明 i, j 双指针分别指向 nums 数组左右两端；<br>  循环二分： 设 m = (i + j) / 2为每次二分的中点（ “/“ 代表向下取整除法，因此恒有 i≤m&lt;j ），可分为以下三种情况：</p><ol><li>当 nums[m] &gt; nums[j] 时： m 一定在 左排序数组 中，即旋转点 x 一定在 [m + 1, j] 闭区间内，因此执行 i=m+1；</li><li>当 nums[m] &lt; nums[j] 时： m 一定在 右排序数组 中，即旋转点 x 一定在[i, m] 闭区间内，因此执行 j=m；</li><li>当 nums[m] = nums[j] 时： 无法判断 m 在哪个排序数组中，即无法判断旋转点 x 在 [i, m] 还是 [m + 1, j]区间中。解决方案： 执行 j = j - 1 缩小判断范围，分析见下文。<br>返回值： 当 i = j时跳出二分循环，并返回 旋转点的值 nums[i]即可。</li></ol></blockquote><p>复杂度分析：<br>时间复杂度 O(log 2N) ： 在特例情况下（例如 [1, 1, 1, 1]），会退化到 O(N)。<br>空间复杂度 O(1) ： i , j , m 变量使用常数大小的额外空间。</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> numbers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>num <span class="token operator">:</span> numbers<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> res<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                res <span class="token operator">=</span> num<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 低级写法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> numbers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                res <span class="token operator">=</span> numbers<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429174629219.png" alt="image-20220429174629219"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429174611872.png" alt="image-20220429174611872"></p><hr><h3 id="3-第一个只出现一次的字符"><a href="#3-第一个只出现一次的字符" class="headerlink" title="3. 第一个只出现一次的字符"></a>3. 第一个只出现一次的字符</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429174721949.png" alt="image-20220429174721949"></p><p><strong>解题思路</strong>:</p><p>1.哈希表</p><ol><li>遍历字符串 <code>s</code> ，使用哈希表统“各字符数量是否 &gt; 1&gt;1 ”。</li><li>再遍历字符串 <code>s</code> ，在哈希表中找到首个 “数量为 11 的字符”，并返回。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/ed093aabc9195caff6d088454eaebe3cad875e8ca4a643c004ef25e4e5e9e174-Picture1.png" alt="Picture1.png"></p><blockquote><p>  算法流程：<br>  初始化： map，记为 dic ；<br>  字符统计： 遍历字符串 s 中的每个字符 c ；<br>  若 dic 中 不包含 键(key) c ：则向 dic 中添加键值对 (c, True) ，代表字符 c 的数量为 1 ；<br>  若 dic 中 包含 键(key) c ：则修改键 c 的键值对为 (c, False) ，代表字符 c 的数量 &gt; 1。<br>  查找数量为 1 的字符： 遍历字符串 s 中的每个字符 c ；<br>  若 dic中键 c 对应的值为 True ：，则返回 c 。<br>  返回 ‘ ‘ ，代表字符串无数量为 1 的字符。</p></blockquote><p><strong>时间复杂度</strong>: O(N) ： N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N)；HashMap 查找操作的复杂度为 O(1) ；<br><strong>空间复杂度</strong> O(1) ： 由于题目指出 s 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用 O(26) = O(1)的额外空间。</p><p>2.<strong>有序哈希表</strong></p><p>在哈希表的基础上，有序哈希表中的键值对是 按照插入顺序排序 的。基于此，可通过遍历有序哈希表，实现搜索首个 “数量为 11 的字符”。</p><p>哈希表是 去重 的，即哈希表中键值对数量 \leq≤ 字符串 s 的长度。因此，相比于方法一，方法二减少了第二轮遍历的循环次数。当字符串很长（重复字符很多）时，方法二则效率更高。</p><p>复杂度分析：<br>时间和空间复杂度均与 “方法一” 相同，而具体分析：方法一 需遍历 s 两轮；方法二 遍历 s 一轮，遍历 dic 一轮（ dic 的长度不大于 26 ）。</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">char</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> dic<span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span>       <span class="token punctuation">{</span>            dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> dic<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 向dic中添加键值对(c, True)，代表字符c的数量为 1 , 若 dic 中 包含 键(key) c ：则修改键 c 的键值对为 (c, False) ，代表字符 c 的数量 > 1。</span>       <span class="token punctuation">}</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span>       <span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> c<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 若 dic中键 c 对应的值为 True ：，则返回 c 。</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429180019234.png" alt="image-20220429180019234"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">char</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> dic<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vec<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> dic<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 未找到, 可能是target</span>            <span class="token punctuation">{</span>                vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> dic<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> vec<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> c<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 若 dic中键 c 对应的值为 True ：，则返回 c 。</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429180917945.png" alt="image-20220429180917945"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第五天-查找算法-中等&quot;&gt;&lt;a href=&quot;#第五天-查找算法-中等&quot; class=&quot;headerlink&quot; title=&quot;第五天_查找算法(中等)&quot;&gt;&lt;/a&gt;第五天_查找算法(中等)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href=&quot;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第四天_查找算法（简单）</title>
    <link href="https://roranrui.cn/2022/04/27/shua-ti-bi-ji-si/"/>
    <id>https://roranrui.cn/2022/04/27/shua-ti-bi-ji-si/</id>
    <published>2022-04-27T00:00:50.000Z</published>
    <updated>2022-04-30T08:41:40.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四天-查找算法（简单）"><a href="#第四天-查找算法（简单）" class="headerlink" title="第四天_查找算法（简单）"></a>第四天_查找算法（简单）</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="散列表-HashSet"><a href="#散列表-HashSet" class="headerlink" title="散列表(HashSet)"></a>散列表(HashSet)</h3><p>散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 <code>key</code>」映射至对应的「值 <code>value</code>」，以实现高效的元素查找。</p><blockquote><p>  设想一个简单场景：小力、小特、小扣的学号分别为 10001, 10002, 10003 。<br>  现需求从「姓名」查找「学号」。</p></blockquote><p>则可通过建立姓名为 key ，学号为 value 的散列表实现此需求，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 初始化散列表</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> dic<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 添加 key -> value 键值对</span>dic<span class="token punctuation">[</span><span class="token string">"小力"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10001</span><span class="token punctuation">;</span>dic<span class="token punctuation">[</span><span class="token string">"小特"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10002</span><span class="token punctuation">;</span>dic<span class="token punctuation">[</span><span class="token string">"小扣"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10003</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从姓名查找学号</span>dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"小力"</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> 10001</span>dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"小特"</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> 10002</span>dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"小扣"</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> 10003</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599811794-ruXMOV-Picture8.png" alt="Picture8.png"></p><h4 id="Hash-函数设计-Demo"><a href="#Hash-函数设计-Demo" class="headerlink" title="Hash 函数设计 Demo"></a>Hash 函数设计 Demo</h4><p>将三人的姓名存储至以下数组中，则各姓名在数组中的索引分别为 0, 1, 2 。</p><p>string names[] = { “小力”, “小特”, “小扣” };</p><p>此时，我们构造一个简单的 Hash 函数（ %% 为取余符号 ），公式和封装函数如下所示：</p><p><code>hash(key) = (key - 1) \% 10000</code><br><code>hash(key)=(key−1)%10000</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>id <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10000</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> index<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>则我们构建了以学号为 key 、姓名对应的数组索引为 value 的散列表。利用此 Hash 函数，则可在 O(1)O(1) 时间复杂度下通过学号查找到对应姓名，即：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599811794-NfbpfW-Picture8-1.png" alt="Picture8-1.png"></p><blockquote><p>  以上设计只适用于此示例，实际的 Hash 函数需保证低碰撞率、 高鲁棒性等，以适用于各类数据和场景。</p></blockquote><hr><h3 id="七大查找算法"><a href="#七大查找算法" class="headerlink" title="七大查找算法"></a>七大查找算法</h3><ul><li><strong>1. 顺序查找</strong></li><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label1"><strong>2. 二分查找</strong></a></li><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label2"><strong>3. 插值查找</strong></a></li><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label3"><strong>4. 斐波那契查找</strong></a></li><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label4"><strong>5. 树表查找</strong></a></li><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label5"><strong>6. 分块查找</strong></a></li><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label6"><strong>7. 哈希查找</strong></a></li></ul><blockquote><p>  查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。树表查找和哈希查找会在后续的博文中进行详细介绍。</p></blockquote><p>  <strong>查找定义</strong>：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p><h3 id="查找算法分类"><a href="#查找算法分类" class="headerlink" title="查找算法分类"></a><strong>查找算法分类</strong></h3><ol><li><p>静态查找和动态查找；</p><p>注：静态或者动态都是针对查找表而言的。<strong>动态表指查找表中有删除和插入操作的表。</strong></p></li><li><p>无序查找和有序查找。</p><p><strong>无序查找</strong>：被查找数列有序无序均可；</p><p>有序查找：被查找数列必须为有序数列。</p></li></ol><blockquote><p>  <strong>平均查找长度（Average Search Length，ASL）</strong>：需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。</p><p>  　　对于含有n个数据元素的查找表，查找成功的平均查找长度为：<code>ASL = Pi*Ci</code>的和。<br>  　　<strong>Pi</strong>：查找表中第i个数据元素的概率。<br>  　　<strong>Ci</strong>：找到第i个数据元素时已经比较过的次数。</p></blockquote><h4 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h4><blockquote><p>  说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</p></blockquote><p><strong>基本思想</strong>：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p><p><strong>复杂度分析</strong>：　</p><p>　　查找成功时的平均查找长度为：（假设每个数据元素的概率相等） <code>ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;</code><br>　　当查找不成功时，需要n+1次比较，时间复杂度为O(n);</p><p>　　所以，顺序查找的时间复杂度为O(n)。</p><h4 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h4><p>　　<strong>说明：元素必须是有序的，如果是无序的则要先进行排序操作。</strong></p><p>　　<strong>基本思想：</strong>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</p><p>　　<strong>复杂度分析：</strong>最坏情况下，关键词比较次数为log2(n+1)，且**期望时间复杂度为O(log2n)**；</p><p>　　注：<strong>折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》</strong></p><p><strong>其他查找算法后面补充</strong></p><hr><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-数组中重复的数字"><a href="#1-数组中重复的数字" class="headerlink" title="1. 数组中重复的数字"></a>1. 数组中重复的数字</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427081435148.png" alt="image-20220427081435148"></p><p><strong>解题思路:</strong></p><p>1.<strong>原地交换</strong><br>题目说明尚未被充分使用，即 在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 此说明含义：数组元素的 索引 和 值 是 一对多 的关系。<br>因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 `nums[i] = i ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p><p>遍历中，第一次遇到数字 x 时，将其交换至索引 x 处；而当第二次遇到数字 x 时，一定有 <code>nums[x] = x</code> ，此时即可得到一组重复数字。</p><blockquote><p>  <strong>算法流程：</strong><br>  遍历数组 <code>numsnums</code> ，设索引初始值为 i = 0 :</p><p>  若 <code>nums[i] = i</code>： 说明此数字已在对应索引位置，无需交换，因此跳过；<br>  若 <code>nums[nums[i]] = nums[i]</code>： 代表索引 <code>nums[i]</code> 处和索引 <code>i</code> 处的元素值都为 <code>nums[i]</code> ，即找到一组重复值，返回此值 <code>nums[i]</code> ；<br>  否则： 交换索引为 <code>i</code> 和 <code>nums[i]</code> 的元素值，将此数字交换至对应索引位置。<br>  若遍历完毕尚未返回，则返回 −1 。</p></blockquote><p><strong>复杂度分析：</strong><br>时间复杂度 O(N) ： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。<br>空间复杂度 O(1)： 使用常数复杂度的额外空间。</p><p><strong>2.利用HashSet</strong></p><p>利用数据结构特点，容易想到使用哈希表（Set）记录数组的各个数字，当查找到重复数字则直接返回。</p><blockquote><p>  <strong>算法流程：</strong><br>  初始化： 新建 HashSet ，记为 dic ；<br>  遍历数组 nums 中的每个数字 num ：<br>  当 num 在 dic中，说明重复，直接返回 num ；<br>  将 num 添加至 dic 中；<br>  返回 -1 。本题中一定有重复数字，因此这里返回多少都可以。</p></blockquote><p><strong>复杂度分析：</strong><br>时间复杂度 O(N)： 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1) 。<br>空间复杂度 O(N)： HashSet 占用O(N) 大小的额外空间。</p><p><strong>实现:</strong></p><ol><li>原地交换</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 数据与下标相同</span>            <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427084044831.png" alt="image-20220427084044831"></p><ol start="2"><li>HashSet</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> dic<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dic<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">return</span> num<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            dic<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427084019040.png" alt="image-20220427084019040"></p><p>其他范例参考:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>           <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  先让数组有序, 然后比较前后</p></blockquote><hr><h3 id="2-在排序数组中查找数字-I"><a href="#2-在排序数组中查找数字-I" class="headerlink" title="2.  在排序数组中查找数字 I"></a>2.  在排序数组中查找数字 I</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427084923052.png" alt="image-20220427084923052"></p><p><strong>解题思路:</strong></p><p>1.遍历求解</p><p>遍历<code>nums</code>并用<code>count</code>记录下<code>target</code>的次数</p><p><strong>复杂度分析：</strong><br>时间复杂度 O(N)： 遍历数组使用 O(N) ，count计数为O(1)<br>空间复杂度 O(1);</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> iterator <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iterator <span class="token operator">!=</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iterator<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>iterator <span class="token operator">==</span> target<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427085427712.png" alt="image-20220427085427712"></p><p>2.二分查找</p><p>排序数组 nums 中的所有数字 target 形成一个窗口，记窗口的 左 / 右边界 索引分别为 left和 right ，分别对应窗口左边 / 右边的首个元素。</p><p>本题要求统计数字 target 的出现次数，可转化为：使用二分法分别找到 左边界 leftleft 和 右边界 rightright ，易得数字 target 的数量为 right - left - 1。</p><blockquote><p>  <strong>算法解析：</strong><br>  初始化： 左边界 i = 0 ，右边界 j = len(nums) - 1 。<br>  循环二分： 当闭区间 [i, j] 无元素时跳出；<br>  计算中点 m = (i + j) / 2（向下取整）；<br>  若 nums[m] &lt; target ，则 target 在闭区间 [m + 1, j]中，因此执行 i = m + 1；<br>  若 nums[m] &gt; target ，则 target 在闭区间 [i, m - 1]中，因此执行 j = m - 1；<br>  若 nums[m] = target ，则右边界 right在闭区间 [m+1, j]中；左边界 left在闭区间 [i, m-1] 中。因此分为以下两种情况：<br>  若查找 右边界 right ，则执行 i = m + 1 ；（跳出时 i 指向右边界）<br>  若查找 左边界 left ，则执行 j = m - 1 ；（跳出时 j指向左边界）<br>  返回值： 应用两次二分，分别查找 right 和 left ，最终返回 right - left - 1right−left−1 即可。</p></blockquote><blockquote><p>  效率优化：<br>  以下优化基于：查找完右边界 right = i 后，则 nums[j]指向最右边的 target （若存在）。</p></blockquote><ol><li>查找完右边界后，可用 nums[j] = target判断数组中是否包含 target，若不包含则直接提前返回 0 ，无需后续查找左边界。</li><li>查找完右边界后，左边界 left一定在闭区间 [0, j] 中，因此直接从此区间开始二分查找即可。</li></ol><p><strong>复杂度分析：</strong><br>时间复杂度 O(logN) ： 二分法为对数级别复杂度。<br>空间复杂度 O(1)： 几个变量使用常数大小的额外空间。<br>代码：<br>可将 nums[m] = target情况合并至其他两种情况中。</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 搜索右边界 right */</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">)</span> i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 若数组中无 target ，则提前返回 */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 搜索左边界 right */</span>        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token keyword">return</span> right <span class="token operator">-</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-0～n-1-中缺失的数字"><a href="#3-0～n-1-中缺失的数字" class="headerlink" title="3. 0～n-1 中缺失的数字"></a>3. 0～n-1 中缺失的数字</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427204205526.png" alt="image-20220427204205526"></p><p><strong>解题思路</strong><br>1.二分查找到某个值(最优解)，满足：</p><p>左子数组： <code>nums[i] = i</code><br>右子数组： <code>nums[i] != i</code></p><p>时间复杂度O(logN)</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//使用(left + right)/2 也可以 但是要注意 left + right 可能会超过 int 表示范围</span>            <span class="token comment" spellcheck="true">//left + (right - left )/2 可以有效的 防止溢出;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427205126432.png" alt="image-20220427205126432"></p><p>2.顺序查找</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427205223931.png" alt="image-20220427205223931"></p><p>其他方法参考:</p><p><strong>位运算处理</strong></p><ul><li>我们知道异或具有交换律</li><li>令0~n的数与<strong>nums</strong>中的数异或，运算中除了缺失值只出现一次外，其他数都出现两次等同于与自身异或。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span>     <span class="token punctuation">{</span>          <span class="token keyword">int</span> res <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            res <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>              res <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//其是就是 比较 数组下标 和 对应的元素 是否相等，不相等即为miss的数</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427210015051.png" alt="image-20220427210015051"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第四天-查找算法（简单）&quot;&gt;&lt;a href=&quot;#第四天-查找算法（简单）&quot; class=&quot;headerlink&quot; title=&quot;第四天_查找算法（简单）&quot;&gt;&lt;/a&gt;第四天_查找算法（简单）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HTML学习笔记</title>
    <link href="https://roranrui.cn/2022/04/26/html-xue-xi-bi-ji/"/>
    <id>https://roranrui.cn/2022/04/26/html-xue-xi-bi-ji/</id>
    <published>2022-04-26T14:22:03.000Z</published>
    <updated>2022-04-26T15:14:18.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML学习笔记"><a href="#HTML学习笔记" class="headerlink" title="HTML学习笔记"></a>HTML学习笔记</h1><blockquote><p>  文章转载至: [<a href="https://docs.mphy.top/">MurphyChen’s Notes</a>]仅供学习交流使用</p><p>  如有侵权, 请立即联系我删除!</p></blockquote><h1 id="（一）HTML-标签（上）"><a href="#（一）HTML-标签（上）" class="headerlink" title="（一）HTML 标签（上）"></a>（一）HTML 标签（上）</h1><h2 id="1-HTML-语法规范"><a href="#1-HTML-语法规范" class="headerlink" title="1. HTML 语法规范"></a>1. HTML 语法规范</h2><h3 id="1-1-基本语法规范"><a href="#1-1-基本语法规范" class="headerlink" title="1.1 基本语法规范"></a>1.1 基本语法规范</h3><ol><li>HTML 标签通常是成对出现的，例如<code>&lt;html&gt;</code>和<code>&lt;html/&gt;</code>，称为双标签。第一个是开始标签，第二个是结束标签。</li><li>有些特殊标签必须是单个标签（极少情况），例如<code>&lt;br/&gt;</code>，我们称之为单标签。</li></ol><h3 id="1-2-标签关系"><a href="#1-2-标签关系" class="headerlink" title="1.2 标签关系"></a>1.2 标签关系</h3><p>标签关系可以分为两类：包含关系和并列关系</p><h2 id="2-HTML-基本结构标签"><a href="#2-HTML-基本结构标签" class="headerlink" title="2. HTML 基本结构标签"></a>2. HTML 基本结构标签</h2><p>每个网页都会有一个基本的结构标签，页面内容都是在这些基本标签上书写。 HTML 页面也叫 HTML 文档。</p><h2 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3. 开发工具"></a>3. 开发工具</h2><h3 id="3-1-文档类型声明标签"><a href="#3-1-文档类型声明标签" class="headerlink" title="3.1 文档类型声明标签"></a>3.1 文档类型声明标签</h3><p><code>!&lt;DOCTYPE&gt;</code> 文档类型声明，告诉浏览器使用何种 HTML 版本来显示网页。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>这句话的意思是：当前页面采用的是 HTML5 版本来显示网页。</strong> <strong>注意：</strong></p><ol><li><code>&lt;!DOCTYPE&gt;</code> 声明位于文档最前面的位置，处于<code>&lt;html&gt;</code>标签之前。</li><li><code>&lt;!DOCTYPE&gt;</code> 不是一个 HTML 标签，他就是文档类型声明标签。</li></ol><h3 id="3-2-lang-语言种类"><a href="#3-2-lang-语言种类" class="headerlink" title="3.2 lang 语言种类"></a>3.2 lang 语言种类</h3><p>用来显示当前文档显示的语言。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zh-CN<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li><code>en</code> 定义语言为英文。</li><li><code>zh-CN</code> 定义语言为中文。</li></ol><p>这个属性对浏览器和搜索引擎（谷歌/百度）还是有作用的。</p><h3 id="3-3-charset-字符集"><a href="#3-3-charset-字符集" class="headerlink" title="3.3 charset 字符集"></a>3.3 charset 字符集</h3><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>字符集（character set）是多个字符的集合，以便计算机能够识别和存储各种文字。</p><p>在<code>&lt;head&gt;</code>标签内，可以通过<code>&lt;meta&gt;</code>标签的<code>charset</code> 属性来设置文档使用何种字符编码。</p><p><code>charset</code>常用的值有：GBK、UTF-8，其中UTF-8被称为万国码，基本包含了全世界所有国家需要用到的字符。</p><h2 id="4-HTML-常用标签"><a href="#4-HTML-常用标签" class="headerlink" title="4. HTML 常用标签"></a>4. HTML 常用标签</h2><h3 id="4-1-标签语义"><a href="#4-1-标签语义" class="headerlink" title="4.1 标签语义"></a>4.1 标签语义</h3><p>标签语义就是标签的含义。</p><p>根据标签的语义，再合适的地方给一个最合理的标签，可以让页面结构更清晰。</p><h3 id="4-2-标题标签-h1-h6（重要）"><a href="#4-2-标题标签-h1-h6（重要）" class="headerlink" title="4.2 标题标签 h1-h6（重要）"></a>4.2 标题标签 h1-h6（重要）</h3><p>为了使网页具有语义化，经常使用标题标签，HTML 提供 6 个等级的网页标题标签即 <code>&lt;h1&gt;-&lt;h6&gt;</code>。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>标题标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>标题一共六级选,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>文字加粗一行显。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>由大到小依次减，<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>从重到轻随之变。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h5</span><span class="token punctuation">></span></span>语法规范书写后，<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h5</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">></span></span>具体效果刷新见。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h6</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单词为 head 简写，从 h1-h6 依据重要性递减。</p><h3 id="4-3-段落和换行标签（重要）"><a href="#4-3-段落和换行标签（重要）" class="headerlink" title="4.3 段落和换行标签（重要）"></a>4.3 段落和换行标签（重要）</h3><p><code>p</code> 指<strong>paragraph</strong>，意为段落。把文字有条理的显示出来就需要将文字分段显示。在 html 中，<code>&lt;p&gt;</code> 标签用于定义段落，将整个网页分成若干个段落。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>我是一个段落标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>标签语义: 把 HTML 文档分割为若干段落。</p><p><strong>特点：</strong></p><ol><li>文本在一个段落中会根据浏览器窗口的大小自动换行。</li><li>段落和段落之间保有空隙。</li></ol><hr><p><code>&lt;br/&gt;</code> 是 break 缩写，意为打断、换行。</p><p>标签语义： 强制换行</p><p><strong>特点：</strong></p><ol><li><code>&lt;br/&gt;</code> 是个单标签。</li><li><code>&lt;br/&gt;</code> 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距。</li></ol><p>课堂案例</p><p>体育新闻显示页面——基本标签的使用</p><h3 id="4-4-文本格式化标签"><a href="#4-4-文本格式化标签" class="headerlink" title="4.4 文本格式化标签"></a>4.4 文本格式化标签</h3><p>在网页中，有时候需要为文字设置<strong>粗体</strong>、<em>斜体</em>或下划线等效果，需要使用 HTML 中的文本格式化标签，使文字以特殊方式显示。</p><p>标签语义： 突出重要性，比普通文字重要。</p><table><thead><tr><th>语义</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>加粗</td><td><code>&lt;strong&gt;&lt;/strong&gt;</code>或<code>&lt;b&gt;&lt;/b&gt;</code></td><td>更推荐<code>&lt;strong&gt;</code>，语义更强烈</td></tr><tr><td>斜体</td><td><code>&lt;em&gt;&lt;/em&gt;</code>或<code>&lt;i&gt;&lt;/i&gt;</code></td><td>更推荐使用<code>&lt;em&gt;</code>，语义更强烈</td></tr><tr><td>删除线</td><td><code>&lt;del&gt;&lt;/del&gt;</code>或<code>&lt;s&gt;&lt;s/&gt;</code></td><td>更推荐使用<code>&lt;del&gt;</code>，语义更强烈</td></tr><tr><td>下划线</td><td><code>&lt;ins&gt;&lt;/ins&gt;</code>或<code>&lt;u&gt;&lt;/u&gt;</code></td><td>更推荐使用<code>&lt;ins&gt;</code>，语义更强烈</td></tr></tbody></table><h3 id="4-5-div-和-span-标签"><a href="#4-5-div-和-span-标签" class="headerlink" title="4.5 div 和 span 标签"></a>4.5 div 和 span 标签</h3><div>&nbsp;和&nbsp;<span>&nbsp;是没有语义的，它们是一个盒子，用来装内容的。<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>这是头部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>今日价格<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>div 是 division 的缩写，表示分割、分区。span 意思是跨度、跨距。</p><p><strong>特点：</strong></p><ol><li>div 标签用来布局，但是现在一行只能放一个 div，大盒子。</li><li>span 标签用来布局，一行可以多个 span，小盒子。</li></ol><h3 id="4-6-图像标签和路径（重点）"><a href="#4-6-图像标签和路径（重点）" class="headerlink" title="4.6 图像标签和路径（重点）"></a>4.6 图像标签和路径（重点）</h3><h4 id="4-6-1-图像标签"><a href="#4-6-1-图像标签" class="headerlink" title="4.6.1 图像标签"></a>4.6.1 图像标签</h4><p>在 HTML 标签中，<code>&lt;img /&gt;</code> 标签用于定义 HTML 标签页面中的图像。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>图像url<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>单词 image 的缩写，意为图像。</p><p>src 是标签的 必须属性，用于指定图像文件的路径和文件名。</p><p><strong>属性：</strong> 属于这个图像标签的特性。</p><p><strong>图像标签的其他属性</strong></p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td><code>src</code></td><td>图片路径</td><td>必须属性</td></tr><tr><td><code>alt</code></td><td>文本</td><td>替换文本，当图片不显示时显示文字</td></tr><tr><td><code>title</code></td><td>文本</td><td>提示文本。鼠标放到图像上显示文字</td></tr><tr><td><code>width</code></td><td>像素</td><td>图像宽度</td></tr><tr><td><code>height</code></td><td>像素</td><td>图像高度</td></tr><tr><td><code>border</code></td><td>像素</td><td>图像边框粗细</td></tr></tbody></table><h4 id="4-6-2-路径"><a href="#4-6-2-路径" class="headerlink" title="4.6.2 路径"></a>4.6.2 路径</h4><ul><li>相对路径</li><li>绝对路径</li></ul><h5 id="1-相对路径"><a href="#1-相对路径" class="headerlink" title="1. 相对路径"></a>1. 相对路径</h5><p>相对路径： 以引用文件位置为参考基础，而建立出来的目录路径。是相对于 HTML 页面的位置。</p><table><thead><tr><th>分类</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>同级路径</td><td></td><td>同一级</td></tr><tr><td>下一级路径</td><td><code>/</code></td><td>位于 HTML 文件上一级</td></tr><tr><td>上一级路径</td><td><code>../</code></td><td>位于 HTML 文件下一级</td></tr></tbody></table><h5 id="2-绝对路径"><a href="#2-绝对路径" class="headerlink" title="2. 绝对路径"></a>2. 绝对路径</h5><p>绝对路径： 是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径或者完整的网络地址。</p><h3 id="4-7-超链接标签"><a href="#4-7-超链接标签" class="headerlink" title="4.7 超链接标签"></a>4.7 超链接标签</h3><p>在 HTML 标签中，<code>&lt;a/&gt;</code> 标签用于从一个页面链接到另一个页面。</p><h4 id="4-7-1-链接的语法格式"><a href="#4-7-1-链接的语法格式" class="headerlink" title="4.7.1 链接的语法格式"></a>4.7.1 链接的语法格式</h4><p>a 是单词 anchor 的简写，是锚的意思。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>跳转目标<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>目标窗口的弹出方式<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>文本或图像<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>属性</strong></p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>href</code></td><td>指定链接地址 url，为必须属性。</td></tr><tr><td><code>target</code></td><td>指定页面打开方式，<code>_self</code>为默认值，<code>_blank</code>为在新窗口中打开</td></tr></tbody></table><h4 id="4-7-2-超链接分类"><a href="#4-7-2-超链接分类" class="headerlink" title="4.7.2 超链接分类"></a>4.7.2 超链接分类</h4><ol><li><p>外部链接</p></li><li><p>内部链接：网站内部页面之间的相互链接。</p></li><li><p>空链接: <code>#</code></p></li><li><p>下载链接：地址链接的是文件.exe、压缩包.zip 等。</p></li><li><p>网页元素链接：在网页中的各种网页元素。如文本、图像、表格、音频、视频等。</p></li><li><p>锚点链接：</p><p>点击链接，可以快速定位到页面中的某个位置。</p><ul><li>在链接文本的<code>href</code>属性中，设置属性为 #名字的形式</li><li>找到目标位置标签，里面添加一个 id 属性 = 名字</li></ul></li></ol><p>Tip</p><p>阻止 <code>a</code> 链接跳转，课可给 <code>href</code> 属性设置 <code>javascript:void(0);</code> 或者 <code>javascript:;</code>。</p><h2 id="5-HTML-中的注释和特殊字符号"><a href="#5-HTML-中的注释和特殊字符号" class="headerlink" title="5. HTML 中的注释和特殊字符号"></a>5. HTML 中的注释和特殊字符号</h2><ol><li>注释: <code>&lt;!--注释--&gt;</code> VSCode 中快捷键：Ctrk + /</li><li>字符实体</li></ol><table><thead><tr><th>字符</th><th>显示</th></tr></thead><tbody><tr><td><code> </code></td><td>空格</td></tr><tr><td><code>&lt;</code></td><td>＜</td></tr><tr><td><code>&gt;</code></td><td>＞</td></tr><tr><td><code>©</code></td><td>©</td></tr></tbody></table><hr><h1 id="（二）HTML-标签（下）"><a href="#（二）HTML-标签（下）" class="headerlink" title="（二）HTML 标签（下）"></a>（二）HTML 标签（下）</h1><h2 id="1-表格标签"><a href="#1-表格标签" class="headerlink" title="1. 表格标签"></a>1. 表格标签</h2><h3 id="1-1-表格的主要作用"><a href="#1-1-表格的主要作用" class="headerlink" title="1.1 表格的主要作用"></a>1.1 表格的主要作用</h3><p>表格主要用于显示、展示数据，因为可以让数据显示非常规整，可读性好。 表格不是来布局的，而是来展示数据的。</p><h3 id="1-2-表格基本语法"><a href="#1-2-表格基本语法" class="headerlink" title="1.2 表格基本语法"></a>1.2 表格基本语法</h3><ol><li><code>&lt;table&gt;&lt;/table&gt;</code> 用于定义表格的标签。</li><li><code>&lt;tr&gt;&lt;/tr&gt;</code> 标签用于定义表格中的行，必须嵌套在 <code>&lt;table&gt;&lt;/table&gt;</code>中。</li><li><code>&lt;td&gt;&lt;/td&gt;</code> 用于定义表格中的单元格，必须嵌套在 <code>&lt;tr&gt;&lt;/tr&gt;</code> 中。</li><li>字母 td 指表格数据（table data），即单元格的内容。</li></ol><h3 id="1-3-表头单元格标签-th"><a href="#1-3-表头单元格标签-th" class="headerlink" title="1.3 表头单元格标签 th"></a>1.3 表头单元格标签 th</h3><p>一般单元格位于表格的第一行或第一列，表格单元格里面的文本内容 <strong>加粗显示</strong>。 <code>&lt;th&gt;</code> 标签表示 HTML 表格的表头部分（table head 的缩写） 表头单元格(<code>&lt;th&gt;</code>)也是单元格，常用于表格第一行，突出重要性，表头单元格里面的文字会加粗居中显示。</p><h3 id="1-4-表格属性"><a href="#1-4-表格属性" class="headerlink" title="1.4 表格属性"></a>1.4 表格属性</h3><p>只作了解，后期通过 CSS 来设置。 这些属性都要写到 <code>&lt;table&gt;&lt;/table&gt;</code> 标签中</p><table><thead><tr><th>属性名</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>align</code></td><td>left、center、right</td><td>表格元素对齐方式</td></tr><tr><td><code>border</code></td><td>1 或””</td><td>规定是否有边框，默认为<code>""</code>，表示没有边框</td></tr><tr><td><code>cellpadding</code></td><td>像素值</td><td>规定单元边沿与其内容之间空白，默认 1px</td></tr><tr><td><code>cellspacing</code></td><td>像素值</td><td>规定单元格之间的空白，默认为 2px</td></tr><tr><td><code>width</code></td><td>像素值或百分比</td><td>规定表格宽度</td></tr><tr><td><code>hight</code></td><td>像素</td><td>表格高度</td></tr></tbody></table><h3 id="1-5-表格结构标签"><a href="#1-5-表格结构标签" class="headerlink" title="1.5 表格结构标签"></a>1.5 表格结构标签</h3><p>场景：表格可能很长，将表格分割为表格头部和表格主题两大部分。</p><p>加强语义化：<code>&lt;thead&gt;</code> 表示头部区域，<code>&lt;tbody&gt;</code> 表示主体区域，更好区分表格结构。</p><p>注意：</p><ol><li><code>&lt;thead&gt;&lt;/thead&gt;</code>：定义表格头部，且内部必须有<code>&lt;tr&gt;</code>标签。</li><li><code>&lt;tbody&gt;&lt;/tbody&gt;</code>：定义表格主体，存放数据。</li><li>以上标签都放在 <code>&lt;table&gt;&lt;/table&gt;</code> 里面。</li></ol><h3 id="1-6-合并单元格"><a href="#1-6-合并单元格" class="headerlink" title="1.6 合并单元格"></a>1.6 合并单元格</h3><p><strong>合并单元格方式：</strong></p><ul><li>跨行合并：rowspan=”合并单元格个数”</li><li>跨列合并：colspan=”合并单元格个数”</li></ul><p>合并三部曲：</p><ol><li>确定跨行 or 跨列。</li><li>找到目标单元格：跨行取最上面为目标单元格，跨列取最左边为目标单元格。<code>&lt;td colspan="2"&gt;&lt;/td&gt;</code></li><li>删除多余单元格。</li></ol><h2 id="2-列表标签"><a href="#2-列表标签" class="headerlink" title="2. 列表标签"></a>2. 列表标签</h2><p>表格展示数据，列表则用来布局。 列表特点是整齐、整洁、有序，作为布局更方便自由。 根据使用场景不同，列表分为三大类：</p><ul><li>无序列表</li><li>有序列表</li><li>自定义列表。</li></ul><h3 id="2-1-无序列表（重要）"><a href="#2-1-无序列表（重要）" class="headerlink" title="2.1 无序列表（重要）"></a>2.1 无序列表（重要）</h3><p><code>&lt;ul&gt;</code> 标签标识 HTML 页面项目中的无序列表，一般以项目符号呈现列表项。</p><p>语法格式:</p><pre class="line-numbers language-HTML"><code class="language-HTML"><ul>    <li>列表项1</li>    <li>列表项2</li>    <li>列表项3</li></ul>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意:</p><ol><li>各个列表项之间无需，并列关系。</li><li><code>&lt;ul&gt;&lt;/ul&gt;</code>中只能包含<code>&lt;li&gt;&lt;/li&gt;</code>，写入其他标签或文字是不允许的。</li><li>无序列表带有自己的属性，可用 CSS 修改样式属性。</li></ol><h3 id="2-2-有序列表（理解）"><a href="#2-2-有序列表（理解）" class="headerlink" title="2.2 有序列表（理解）"></a>2.2 有序列表（理解）</h3><p>使用 <code>&lt;ol&gt;</code> 标签来定义有序列表，<code>&lt;li&gt;</code> 来定义列表项。</p><pre class="line-numbers language-HTML"><code class="language-HTML"><ol>    <li>列表项1</li>    <li>列表项2</li>    <li>列表项3</li></ol>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与无需列表类似，有自己的样式属性，通过 CSS 设置。</p><h3 id="2-3-自定义列表（重点）"><a href="#2-3-自定义列表（重点）" class="headerlink" title="2.3 自定义列表（重点）"></a>2.3 自定义列表（重点）</h3><p><code>&lt;dl&gt;</code> 定义描述列表，与 <code>&lt;dt&gt;</code> 和 <code>&lt;dd&gt;</code> 标签配合使用。</p><p>基本语法：</p><pre class="line-numbers language-HTML"><code class="language-HTML"><dl>    <dt>名词1</dt>    <dd>名词1解释1</dd>    <dd>名词1解释2</dd></dl>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ol><li>dl 里面只能包含 dt 和 dd。</li></ol><h2 id="3-表头标签"><a href="#3-表头标签" class="headerlink" title="3. 表头标签"></a>3. 表头标签</h2><h3 id="3-1-为什么需要表头"><a href="#3-1-为什么需要表头" class="headerlink" title="3.1 为什么需要表头"></a>3.1 为什么需要表头</h3><p>收集用户信息。 和用户进行交互，收集用户资料。</p><h3 id="3-2-表头组成"><a href="#3-2-表头组成" class="headerlink" title="3.2 表头组成"></a>3.2 表头组成</h3><ul><li>表单域</li><li>表单控件（元素）</li><li>提示信息</li></ul><h3 id="3-3-表单域"><a href="#3-3-表单域" class="headerlink" title="3.3 表单域"></a>3.3 表单域</h3><p>表单域是一个包含表单元素的区域。 使用 <code>&lt;form&gt;</code> 标签用于定义表单域，手机和传递用户信息。 form 标签会将它范围内的表单元素信息提交给服务器。</p><p>目前而言，暂时不需要用表单域提交数据，只需要写上 <code>form</code> 标签即可。</p><p><strong>语法格式</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url地址<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>提交方式<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>表单域名称<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  各种表单元素控件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>常用属性：</strong></p><table><thead><tr><th>属性</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td>url 地址</td><td>指定接受并处理表单数据的服务器的 url 地址</td></tr><tr><td>method</td><td>get/post</td><td>设置表单数据的提交方式</td></tr><tr><td>name</td><td>名称</td><td>用于指定表单名称，区分同一个页面中的多个表单域</td></tr></tbody></table><p>注意：</p><ol><li>写表单元素之前需要有表单域将其包含。</li><li>表单域是 <code>form</code> 标签。</li></ol><h3 id="3-4-表单控件（表单元素）"><a href="#3-4-表单控件（表单元素）" class="headerlink" title="3.4 表单控件（表单元素）"></a>3.4 表单控件（表单元素）</h3><p>在表单域中定义各种表单元素，允许用户在表单中输入或选择的内容控件。</p><h4 id="3-4-1-表单元素"><a href="#3-4-1-表单元素" class="headerlink" title="3.4.1 表单元素"></a>3.4.1 表单元素</h4><p><code>&lt;input&gt;</code> 标签用于收集用户信息。</p><p><code>input</code> 标签包含 <code>type</code> 属性，决定了输入字段的不同形式：文本字段、复选框、掩码后的文本控件、单选按钮、按钮等。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>属性值<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>input</code> 标签为单标签</li><li><code>type</code> 属性设置不同属性值来指定不同控件类型</li></ul><p>type 常用属性值</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>button</td><td>定义可点击按钮</td></tr><tr><td>checkox</td><td>复选框</td></tr><tr><td>file</td><td>定义输入字段和“浏览”按钮，供文件上传</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段</td></tr><tr><td>image</td><td>定义图像形式的提交按钮</td></tr><tr><td>password</td><td>定义密码字段。字符被掩码。</td></tr><tr><td>radio</td><td>定义单选按钮</td></tr><tr><td>reset</td><td>定义重置按钮，清除表单所有数据。</td></tr><tr><td>submit</td><td>定义提交按钮。重置按钮会清除表单所有数据。</td></tr><tr><td>text</td><td>定义输入字段。用户可输入文本，默认宽度为 20 个字符。</td></tr></tbody></table><p>input 的其他属性</p><table><thead><tr><th>属性</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>自定义</td><td>定义 input 元素名称</td></tr><tr><td>value</td><td>自定义</td><td>规定 input 元素的值</td></tr><tr><td>checked</td><td>checked</td><td>规定此 input 元素首次加载时应当被选中</td></tr><tr><td>maxlength</td><td>正整数</td><td>规定输入字段字符的最大长度</td></tr></tbody></table><p>注意</p><ol><li>对于 <code>radio</code> 单选框，必须使 <code>input</code> 的 <code>name</code> 具有相同的属性值，才能实现多选一。 同理，复选框也要有相同的<code>name</code>值。</li><li>单选框和复选框可以设置 <code>checked</code> 属性，页面打开默认选择按钮。</li><li>设置 <code>type</code> 的值为 <code>submit</code>，点击按钮后可以把表单域 form 里面的表单元素里面的值提交给后台。</li><li>设置 <code>type="button"</code>，普通按钮，后期结合 js 使用</li></ol><h3 id="3-4-2-label-标签"><a href="#3-4-2-label-标签" class="headerlink" title="3.4.2 label 标签"></a>3.4.2 label 标签</h3><p><code>&lt;label&gt;</code> 标签为 input 元素定义标注。 <code>&lt;label&gt;</code> 标签用于绑定一个表单源深路，当点击 label 标签内的文本时，浏览器自动将焦点转到或者选择对应的表单元素上，提升用户体验。 <strong>语法：</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>核心：</strong> <code>&lt;lable&gt;</code>标签的 for 属性与相关元素的 id 属性相同。</p><h3 id="3-4-3-select-下拉表单元素"><a href="#3-4-3-select-下拉表单元素" class="headerlink" title="3.4.3 select 下拉表单元素"></a>3.4.3 select 下拉表单元素</h3><p><code>select</code> 标签设置多个选项让用户选择，节约页面空间。 <strong>语法</strong></p><pre class="line-numbers language-HTML"><code class="language-HTML"><select>    <option>选项1</option>    <option>选项2</option>    <option>选项3</option></select>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ol><li>select 中至少包含一对 option。</li><li>在 option 中定义属性<code>selected=selected</code>，当前项即为默认选项。</li></ol><h3 id="3-4-4-textarea-文本域表单元素"><a href="#3-4-4-textarea-文本域表单元素" class="headerlink" title="3.4.4 textarea 文本域表单元素"></a>3.4.4 textarea 文本域表单元素</h3><p>场景：输入内容较多时。</p><p><strong>语法：</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span> <span class="token attr-name">rows</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span> <span class="token attr-name">cols</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    文本内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Tip</p><p>&gt; <code>cols="每行字符数"，rows="显示的行数"</code></p></span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML学习笔记&quot;&gt;&lt;a href=&quot;#HTML学习笔记&quot; class=&quot;headerlink&quot; title=&quot;HTML学习笔记&quot;&gt;&lt;/a&gt;HTML学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  文章转载至: [&lt;a href=&quot;https://docs.m</summary>
      
    
    
    
    <category term="前端学习" scheme="https://roranrui.cn/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="html" scheme="https://roranrui.cn/tags/html/"/>
    
    <category term="前端" scheme="https://roranrui.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概谈</title>
    <link href="https://roranrui.cn/2022/04/26/she-ji-mo-shi-gai-tan/"/>
    <id>https://roranrui.cn/2022/04/26/she-ji-mo-shi-gai-tan/</id>
    <published>2022-04-26T14:15:32.000Z</published>
    <updated>2022-04-26T14:16:35.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式概谈"><a href="#设计模式概谈" class="headerlink" title="设计模式概谈"></a>设计模式概谈</h1><h2 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1.设计模式"></a>1.设计模式</h2><ul><li>程序灵活，维护起来可能方便，用设计模式理念写出来的代码很晦涩，但是别人接管、阅读代码都会很痛苦</li><li>老外应付特别大的项目时，把项目的开发经验、模块划分经验，总结整理成设计模式</li><li>中国零几年设计模式刚开始火时，总喜欢拿一个设计模式往上套，导致一个小小的项目总要加几个设计模式，本末倒置</li><li>设计模式有其独特的优点，要活学活用，不要深陷其中，生搬硬套</li></ul><hr><h2 id="2-单例设计模式："><a href="#2-单例设计模式：" class="headerlink" title="2.单例设计模式："></a>2.单例设计模式：</h2><p>整个项目中，有某个或者某些特殊的类，只能创建一个属于该类的对象。</p><blockquote><p>  单例类：只能生成一个对象。</p></blockquote><hr><h2 id="3-单例设计模式共享数据分析、解决"><a href="#3-单例设计模式共享数据分析、解决" class="headerlink" title="3.单例设计模式共享数据分析、解决"></a>3.单例设计模式共享数据分析、解决</h2><p>面临问题：需要在自己创建的线程中来创建单例类的对象，这种线程可能不止一个。我们可能面临<code>GetInstance()</code>这种成员函数需要互斥。</p><blockquote><p>  如果觉得在单例模式<code>new</code>了一个对象，而没有自己delete掉，这样不合理。可以增加一个类中类<code>Recycle</code>，<code>new</code>一个单例类时创建一个静态的<code>Recycle</code>对象，这样在程序结束时会调用<code>Recycle</code>的析构函数，释放掉<code>new</code>出来的单例对象。</p></blockquote><p><strong>单例类</strong>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyCAS</span>  <span class="token comment" spellcheck="true">// 单例类</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">MyCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 私有化构造函数</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> MyCAS <span class="token operator">*</span>my_intstance<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> MyCAS <span class="token operator">*</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>my_intstance <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            my_intstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MyCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">static</span> Recycle recycle<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> my_intstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"for Test."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Recycle</span>    <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token operator">~</span><span class="token function">Recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>MyCAS<span class="token operator">::</span>my_intstance <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">delete</span> MyCAS<span class="token operator">::</span>my_intstance<span class="token punctuation">;</span>                MyCAS<span class="token operator">::</span>my_intstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    ~MyCAS()  // 不能在类中直接调用, 因为不会析构(没有创建实体类)</span><span class="token comment" spellcheck="true">//    {</span><span class="token comment" spellcheck="true">//        if (my_intstance != nullptr)</span><span class="token comment" spellcheck="true">//        {</span><span class="token comment" spellcheck="true">//            delete my_intstance;</span><span class="token comment" spellcheck="true">//            my_intstance = nullptr;</span><span class="token comment" spellcheck="true">//        }</span><span class="token comment" spellcheck="true">//    }</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化静态成员变量</span>MyCAS <span class="token operator">*</span>MyCAS<span class="token operator">::</span>my_intstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 单例类</span>    MyCAS <span class="token operator">*</span>p_m <span class="token operator">=</span> MyCAS<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 创建一个对象, 返回该类的对象指针</span><span class="token comment" spellcheck="true">//    MyCAS *p_b = MyCAS::getInstance();  // 返回的仍是同一个</span>    p_m<span class="token operator">-</span><span class="token operator">></span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MyCAS<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决线程重复调用<code>getInstance()</code>问题:</p><blockquote><p>  可以在加锁前判断m_instance是否为空，否则每次调用<code>MyCAS::getInstance()</code>都要加锁，十分影响效率。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token comment" spellcheck="true">// 提高效率</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>my_intstance <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 双重锁定</span>        <span class="token punctuation">{</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">myMtx</span><span class="token punctuation">(</span>recursive_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>my_intstance <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                my_intstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MyCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">static</span> Recycle recycle<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> my_intstance<span class="token punctuation">;</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="4-call-once"><a href="#4-call-once" class="headerlink" title="4. call_once()"></a>4. call_once()</h2><blockquote><p>  函数模板，该函数的第一个参数为标记，第二个参数是一个函数名（如a()）。<br>  <strong>功能：能够保证函数a()只被调用一次。具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。</strong><br>  <code>call_once()</code>需要与一个标记结合使用，这个标记为<code>std::once_flag</code>；其实<code>once_flag</code>是一个结构，<code>call_once()</code>就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态。</p><p>  多个线程同时执行时，一个线程会等待另一个线程先执行。</p></blockquote><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">static</span> once_flag m_flag<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 系统定义的标记</span><span class="token keyword">class</span> <span class="token class-name">MyCAS</span>  <span class="token comment" spellcheck="true">// 单例类</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        my_intstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MyCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> Recycle recycle<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"creatInstance()只执行了一次"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">MyCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 私有化构造函数</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> MyCAS <span class="token operator">*</span>my_intstance<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> MyCAS <span class="token operator">*</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">call_once</span><span class="token punctuation">(</span>m_flag<span class="token punctuation">,</span> createInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call_once执行完毕"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> my_intstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"for Test."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Recycle</span>    <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token operator">~</span><span class="token function">Recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>MyCAS<span class="token operator">::</span>my_intstance <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">delete</span> MyCAS<span class="token operator">::</span>my_intstance<span class="token punctuation">;</span>                MyCAS<span class="token operator">::</span>my_intstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化静态成员变量</span>MyCAS <span class="token operator">*</span>MyCAS<span class="token operator">::</span>my_intstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">myThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程 "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 开始执行"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    MyCAS <span class="token operator">*</span>p_A<span class="token operator">=</span> MyCAS<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p_A<span class="token operator">-</span><span class="token operator">></span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    thread <span class="token function">ts1</span><span class="token punctuation">(</span>myThread<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">ts2</span><span class="token punctuation">(</span>myThread<span class="token punctuation">)</span><span class="token punctuation">;</span>    ts1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ts2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式概谈&quot;&gt;&lt;a href=&quot;#设计模式概谈&quot; class=&quot;headerlink&quot; title=&quot;设计模式概谈&quot;&gt;&lt;/a&gt;设计模式概谈&lt;/h1&gt;&lt;h2 id=&quot;1-设计模式&quot;&gt;&lt;a href=&quot;#1-设计模式&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语言学习" scheme="https://roranrui.cn/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="设计模式" scheme="https://roranrui.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Shell入门</title>
    <link href="https://roranrui.cn/2022/04/26/shell-ru-men/"/>
    <id>https://roranrui.cn/2022/04/26/shell-ru-men/</id>
    <published>2022-04-26T12:35:20.000Z</published>
    <updated>2022-04-26T12:36:30.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell基础"><a href="#Shell基础" class="headerlink" title="Shell基础"></a>Shell基础</h1><h1 id="一、关于shell"><a href="#一、关于shell" class="headerlink" title="一、关于shell"></a>一、关于shell</h1><h2 id="1、什么是shell"><a href="#1、什么是shell" class="headerlink" title="1、什么是shell"></a>1、什么是shell</h2><p><strong>什么是shell？</strong></p><p>Shell（外壳） 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。<strong>Shell</strong> <strong>既是一种命令语言</strong>，<strong>又是一种程序设计语言</strong>。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p><strong>什么是脚本？</strong></p><p>脚本简单地说就是一条条的文字命令，这些文字命令是可以看到的（如可以用记事本打开查看、编辑）。</p><p>常见的脚本： <strong>JavaScript（JS，前端）</strong>，VBScript， <strong>ASP，JSP，PHP（后端）</strong>，SQL（数据库操作语言），Perl，<strong>Shell</strong>，python，Ruby，JavaFX，Lua等。</p><p><strong>为什么要学习和使用shell？</strong></p><p>Shell属于内置的脚本</p><p>程序开发的效率非常高，依赖于功能强大的命令可以迅速地完成开发任务（批处理）</p><p>语法简单，代码写起来比较轻松，简单易学</p><p><strong>常见的shell种类？</strong></p><p>在linux中有很多类型的shell，不同的shell具备不同的功能，shell还决定了脚本中函数的语法，Linux中默认的shell是**/bin/bash（重点）**，流行的shell有ash、bash、ksh、csh、zsh等，不同的shell都有自己的特点以及用途。</p><p>csh</p><p>C shell 使用的是“类C”语法,csh是具有C语言风格的一种shell，其内部命令有52个，较为庞大。目前使用的并不多，已经被/bin/tcsh所取代。</p><p>ksh</p><p>Korn shell 的语法与 Bourne shell 相同，同时具备了 C shell 的易用特点。许多安装脚本都使用 ksh ，ksh有42条内部命令，与bash相比有一定的限制性。</p><p>tcsh</p><p>tcsh是csh的增强版，与 C shell 完全兼容。</p><p>sh </p><p>是一个快捷方式，已经被/bin/bash所取代。</p><p>nologin</p><p>指用户不能登录</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image1.png" alt="img"></p><p>zsh</p><p>目前Linux里最庞大的一种shell：zsh。它有84个内部命令，使用起来也比较复杂。一般情况下，不会使用该shell。</p><p><strong>bash</strong></p><p><strong>大多数Linux系统默认使用的shell</strong>，bash shell 是 Bourne shell 的一个免费版本，它是最早的 Unix shell，bash还有一个特点，可以通过help命令来查看帮助。包含的功能几乎可以涵盖shell所具有的功能，所以一般的shell脚本都会指定它为执行路径。</p><h2 id="2、shell入门"><a href="#2、shell入门" class="headerlink" title="2、shell入门"></a>2、shell入门</h2><p>编写规范：</p><p>代码规范：</p><p>​    #!/bin/bash            [指定告知系统当前这个脚本要使用的shell解释器]</p><p>​    Shell相关指令</p><p>文件命名规范：</p><p>​    文件名.sh              .sh是linux下bash shell 的默认后缀</p><p>使用流程：</p><p>①创建.sh文件          touch/vim</p><p>②编写shell代码</p><p>③执行shell脚本        脚本必须得有执行权限</p><p>案例1：创建test.sh，实现第一个shell脚本程序，输出hello world.</p><p>输出命令：#echo 123</p><p>注意：输出的内容如果包含字母和符号（不包含变量），则需要用引号包括起来。如果是纯数字可以包也可以不包。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image2.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image4.jpg" alt="img"></p><p>注意，这里在运行时一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，Linux 系统会去 PATH（环境变量） 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p><p>案例2：使用root用户帐号创建并执行test2.sh，实现创建一个shelltest用户，并在其家目录中新建文件try.html。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image5.png" alt="img"></p><p>脚本执行的另外一个方式：/bin/bash 脚本的路径（了解）</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image6.png" alt="img"></p><p>Shell脚本分为简单的写法（简单命令的堆积）和复杂写法（程序的设计）</p><h1 id="二、shell进阶（重点）"><a href="#二、shell进阶（重点）" class="headerlink" title="二、shell进阶（重点）"></a>二、shell进阶（重点）</h1><h2 id="1、变量（重点）"><a href="#1、变量（重点）" class="headerlink" title="1、变量（重点）"></a>1、变量（重点）</h2><h3 id="1-1、变量的含义"><a href="#1-1、变量的含义" class="headerlink" title="1.1、变量的含义"></a>1.1、变量的含义</h3><p>a. 什么是量</p><p>量就是数据.</p><p>b. 什么是变量</p><p>数据可以发生改变就是变量.</p><p><strong>在一个脚本周期内,其值可以发生改变的量就是变量.</strong></p><p>c. 什么叫做一个脚本周期</p><p>一个脚本周期我们可以简单的理解为当前的shell文件</p><p>变量是shell中不可或缺的一部分，也是<strong>最基础、最重要</strong>的组成部分。</p><h3 id="1-2、变量的定义与使用（重点）"><a href="#1-2、变量的定义与使用（重点）" class="headerlink" title="1.2、变量的定义与使用（重点）"></a>1.2、变量的定义与使用（重点）</h3><p>变量，先定义后使用。</p><p><strong>定义形如：class_name=”yunwe “</strong></p><p><strong>使用形如：echo $class_name</strong></p><p>变量就是由2部分组成,一个是变量名（左边），另外一部分是变量的值（右边）</p><p>变量名和变量值是什么关系??</p><p>变量名和变量值是<strong>使用和被使用</strong>关系; 我们的变量名来使用变量值;</p><p>在使用变量的时候一定需要在变量名前面添加一个$符号，该要求在其他语言中也存在的（例如php）。</p><p>变量名的规范</p><p>注意，变量名后面的等号左右不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p><p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</p><p>中间不能有空格，可以使用下划线“_”。</p><p>不能使用标点符号。</p><p>不能使用bash里的关键字（可用help命令查看保留关键字）。</p><pre><code>问题：以下哪个shell变量名是合法的？A. var       B.?var       C. user*name       D.echo</code></pre><p>案例1：使用变量改写入门脚本中的第1个shell脚本。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image7.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image8.png" alt="img"></p><p><strong>关于单双引号的问题：</strong></p><p><strong>双引号能够识别变量，双引号能够实现转义（类似于“*”）</strong></p><p><strong>单引号是不能识别变量，只会原样输出，单引号是不能转义的</strong></p><p>案例2：定义一个变量，输出当前时间，要求格式为“年-月-日 时:分:秒”。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image9.png" alt="img"></p><p><strong>注意：反引号（esc键下方的那个键），当在脚本中需要执行一些指令并且将执行的结果赋给变量的时候需要使用“反引号”。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image10.png" alt="img"></p><h3 id="1-3、只读变量（了解）"><a href="#1-3、只读变量（了解）" class="headerlink" title="1.3、只读变量（了解）"></a>1.3、只读变量（了解）</h3><p>语法：readonly 变量名</p><p>案例：定义变量a并且其值为10，随后设置其为只读变量，再去尝试重新赋值</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image11.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image12.png" alt="img"></p><h3 id="1-4、接收用户输入（重点）"><a href="#1-4、接收用户输入（重点）" class="headerlink" title="1.4、接收用户输入（重点）"></a>1.4、接收用户输入（重点）</h3><p><strong>语法：read -p</strong> <strong>提示信息</strong>  <strong>变量名</strong></p><p>案例：编写一个脚本test6.sh，要求执行之后提示用户输入文件的名称（路径），然后自动为用户创建该文件</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image14.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image16.jpg" alt="img"></p><h3 id="1-5、删除变量（了解）"><a href="#1-5、删除变量（了解）" class="headerlink" title="1.5、删除变量（了解）"></a>1.5、删除变量（了解）</h3><p>语法：unset 变量名</p><p>案例：定义变量b=20，再输出b的值，随后删除b，最后再输出下b</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image17.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image18.png" alt="img"></p><h2 id="2、条件判断语句"><a href="#2、条件判断语句" class="headerlink" title="2、条件判断语句"></a>2、条件判断语句</h2><p>老婆给当程序员的老公打电话：<strong>下班顺路买一斤包子带回来，如果看到卖西瓜的，买一个</strong>。当晚，程序员老公手捧一个包子进了家门…老婆怒道：你怎么就买了一个包子？！老公答曰：因为看到了卖西瓜的。</p><p>把程序员老婆的话当作一段需求分析一下吧。买一斤包子是一个确定无疑的需求项，无论后面是什么情况什么条件，前面这一斤包子是肯定要买的。看到卖西瓜的是一个条件判断，后面“买一个”是一个模糊不清的需求项，买一个什么呢？需求里没说啊。客户把这个当作开发人员默认了解的内容了。可是作为一个成熟合格的程序员，该老婆的丈夫应该马上跟进确认需求“买一个什么？”，要不然程序可怎么写呢？所以笑话里该程序员是不合格的，起码是不积极不负责的。在没有明确需求的情况下，他只能按照自己的理解来完成工作了。那比较可能的结果就有如下几种：</p><p>1 看到卖西瓜的，买一个西瓜</p><p>​    <strong>如果</strong> <strong>看到卖西瓜的</strong></p><p>​         <strong>那么</strong></p><p>​         <strong>买一个西瓜</strong></p><p>​    <strong>否则</strong></p><p>​        <strong>买一斤包子</strong></p><p>2 看到卖西瓜的，买一个包子</p><p>​    <strong>如果</strong> <strong>看到卖西瓜的</strong></p><p>​         <strong>那么</strong></p><p>​         <strong>买一个包子</strong></p><p>3 看到卖西瓜的，买一个卖西瓜的</p><p>4 看到卖西瓜的，买一个老婆一直想买的东西</p><p>5 看到卖西瓜的，随便买一个东西</p><p><strong>上述1和2下面的条件汉字描述称之为“伪代码”，也是属于条件表达式的语法。</strong></p><p>语法1（一个条件）：</p><p><strong>if condition</strong></p><p><strong>then</strong></p><p>  <strong>command1</strong> </p><p>  <strong>command2</strong></p><p>  <strong>…</strong></p><p><strong>fi</strong></p><p>单行写法（一般在命令行中执行的时候）：if [ condition ]; then command; fi</p><p>语法2（两个条件）：</p><p><strong>if condition</strong></p><p><strong>then</strong></p><p>  <strong>command1</strong> </p><p>  <strong>command2</strong></p><p>  <strong>…</strong></p><p><strong>else</strong></p><p>  <strong>command</strong></p><p><strong>fi</strong></p><p>语法3（多个条件）：</p><p><strong>if condition1</strong></p><p><strong>then</strong></p><p>  <strong>command1</strong></p><p><strong>elif condition2</strong> </p><p><strong>then</strong></p><p>  <strong>command2</strong></p><p><strong>else</strong></p><p>  <strong>commandN</strong></p><p><strong>fi</strong></p><h2 id="3、运算符"><a href="#3、运算符" class="headerlink" title="3、运算符"></a>3、运算符</h2><p>在shell中，运算符和其他编程脚本语言一样，常见的有算数运算符、关系运算符、</p><p>逻辑运算符、字符串运算符、<strong>文件测试运算符</strong>等</p><h3 id="3-1、算数运算符"><a href="#3-1、算数运算符" class="headerlink" title="3.1、算数运算符"></a>3.1、算数运算符</h3><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>+</td><td>加法</td><td><code>expr  $a + $b</code> 结果为 30。</td></tr><tr><td>-</td><td>减法</td><td><code>expr  $a - $b</code> 结果为 -10。</td></tr><tr><td>*</td><td>乘法</td><td><code>expr  $a \* $b</code> 结果为  200。</td></tr><tr><td>/</td><td>除法</td><td><code>expr  $b / $a</code> 结果为 2。</td></tr><tr><td>%</td><td>取余</td><td><code>expr  $b % $a</code> 结果为 0。</td></tr><tr><td>=</td><td>赋值</td><td>a=$b 将把变量 b 的值赋给 a。</td></tr><tr><td>==</td><td>相等。用于比较两个数字，相同则返回 true（真）。</td><td>[ $a  == $b ] 返回 false（假）。</td></tr><tr><td>!=</td><td>不相等。用于比较两个数字，不相同则返回 true。</td><td>[ $a  != $b ] 返回 true。</td></tr></tbody></table><p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <strong>[$a==$b]</strong> 是错误的，必须写成 **[ $a == $b ]**。</p><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><p>例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ‘)：</p><p>#!/bin/bash</p><p>val=<code>expr 2 + 2</code></p><p>echo “两数之和为 : $val”</p><p>两点注意：</p><p>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</p><p>完整的表达式要被 <code> </code> 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image19.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image20.png" alt="img"></p><h3 id="3-2、关系运算符"><a href="#3-2、关系运算符" class="headerlink" title="3.2、关系运算符"></a>3.2、关系运算符</h3><p><strong>关系运算符只支持数字，不支持字符串，除非字符串的值是数字</strong>。</p><p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>-eq</td><td>检测<strong>两个数是否相等</strong>，相等返回 true。</td><td>[ $a  -eq $b ] 返回 false。</td></tr><tr><td>-ne</td><td>检测<strong>两个数是否相等</strong>，不相等返回 true。</td><td>[ $a  -ne $b ] 返回 true。</td></tr><tr><td>-gt</td><td>检测左边的数<strong>是否大于</strong>右边的，如果是，则返回 true。</td><td>[ $a  -gt $b ] 返回 false。</td></tr><tr><td>-lt</td><td>检测左边的数<strong>是否小于</strong>右边的，如果是，则返回 true。</td><td>[ $a  -lt $b ] 返回 true。</td></tr><tr><td>-ge</td><td>检测左边的数<strong>是否大于等于</strong>右边的，如果是，则返回 true。</td><td>[ $a  -ge $b ] 返回 false。</td></tr><tr><td>-le</td><td>检测左边的数<strong>是否小于等于</strong>右边的，如果是，则返回 true。</td><td>[ $a  -le $b ] 返回 true。</td></tr></tbody></table><p>-eq：equal</p><p>-ne：not equal</p><p>-gt：great than</p><p>-lt：less than</p><p>-ge：great than or equal</p><p>-le：less than or equal</p><p>案例：使用a=10，b=20来实现本案例</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image21.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image22.png" alt="img"></p><p><strong>课堂作业：</strong></p><p>写一个脚本，判断当前输入的用户是否存在。如果存在则提示“用户存在”否则提示“用户不存在”。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image24.jpg" alt="img"></p><h3 id="3-3、逻辑运算符"><a href="#3-3、逻辑运算符" class="headerlink" title="3.3、逻辑运算符"></a>3.3、逻辑运算符</h3><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>!</td><td>非运算，表达式为 true 则返回 false，否则返回 true。</td><td>[ !  false ] 返回 true。</td></tr><tr><td>-o</td><td>或（或者）运算，<strong>有一个表达式为</strong> <strong>true</strong> <strong>则返回</strong> <strong>true</strong>。</td><td>[ $a  -lt 20 -o $b -gt 100 ] 返回 true。</td></tr><tr><td>-a</td><td>与（并且）运算，<strong>两个表达式都为</strong> <strong>true</strong> 才返回 true。</td><td>[ $a  -lt 20 -a $b -gt 100 ] 返回 false。</td></tr></tbody></table><p><strong>或运算：一个为真即为真，全部为假才是假</strong></p><p><strong>与运算：一个为假即为假，全部为真才是真</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image25.png" alt="img"></p><h3 id="3-4、字符串运算符"><a href="#3-4、字符串运算符" class="headerlink" title="3.4、字符串运算符"></a>3.4、字符串运算符</h3><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>=</td><td>检测两个字符串是否相等，相等返回 true。</td><td>[ $a =  $b ] 返回 false。</td></tr><tr><td>!=</td><td>检测两个字符串是否相等，不相等返回 true。</td><td>[ $a  != $b ] 返回 true。</td></tr><tr><td>-z</td><td>检测字符串长度是否为0，为0返回 true。</td><td>[ -z  $a ] 返回 false。</td></tr><tr><td>-n</td><td>检测字符串长度是否为0，不为0返回 true。</td><td>[ -n  $a ] 返回 true。</td></tr><tr><td>str</td><td>检测字符串是否为空，不为空返回 true。</td><td>[ $a ]  返回 true。</td></tr></tbody></table><p>案例：将上述的语法验证下</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image26.png" alt="img"></p><h3 id="3-5、文件测试运算符（重点）"><a href="#3-5、文件测试运算符（重点）" class="headerlink" title="3.5、文件测试运算符（重点）"></a>3.5、文件测试运算符（重点）</h3><p>文件测试运算符用于检测 Unix/Linux 文件的各种属性。</p><p>属性检测描述如下：</p><table><thead><tr><th><strong>操作符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>-b  file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td><td>[ -b  $file ] 返回 false。</td></tr><tr><td>-c  file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td><td>[ -c  $file ] 返回 false。</td></tr><tr><td>-d  file</td><td><strong>检测文件是否是目录，如果是，则返回</strong> <strong>true。</strong></td><td>[ -d  $file ] 返回 false。</td></tr><tr><td>-f  file</td><td><strong>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回</strong> <strong>true。</strong></td><td>[ -f  $file ] 返回 true。</td></tr><tr><td>-g  file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td>[ -g  $file ] 返回 false。</td></tr><tr><td>-k  file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td>[ -k  $file ] 返回 false。</td></tr><tr><td>-p  file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td><td>[ -p  $file ] 返回 false。</td></tr><tr><td>-u  file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td>[ -u  $file ] 返回 false。</td></tr><tr><td>-r  file</td><td><strong>检测文件是否可读，如果是，则返回</strong> <strong>true。</strong></td><td>[ -r  $file ] 返回 true。</td></tr><tr><td>-w  file</td><td><strong>检测文件是否可写，如果是，则返回</strong> <strong>true。</strong></td><td>[ -w  $file ] 返回 true。</td></tr><tr><td>-x  file</td><td><strong>检测文件是否可执行，如果是，则返回</strong> <strong>true。</strong></td><td>[ -x  $file ] 返回 true。</td></tr><tr><td>-s  file</td><td><strong>检测文件是否为空（文件大小是否大于0），不为空返回</strong> <strong>true</strong>。</td><td>[ -s  $file ] 返回 true。</td></tr><tr><td>-e  file</td><td><strong>检测文件（包括目录）是否存在，如果是，则返回</strong> <strong>true。</strong></td><td>[ -e  $file ] 返回 true。</td></tr></tbody></table><p>案例：测试上述标绿色的效果</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image27.png" alt="img"></p><p>注意：权限几个判断，如果只有一个部分符合，则认为是有权限的。</p><h2 id="4、shell脚本附带选项（重点）"><a href="#4、shell脚本附带选项（重点）" class="headerlink" title="4、shell脚本附带选项（重点）"></a>4、shell脚本附带选项（重点）</h2><p>问题描述：在linux shell中如何处理tail -10 access.log这样的命令行选项？</p><p>步骤：</p><p>​    调用tail指令</p><p>​    <strong>系统把后续选项传递给tail</strong></p><p>​    Tail先去打开指定的文件</p><p>​    取出最后10行</p><p>问题：自己写的shell是否也可以像内置命令一样传递一些选项呢？</p><p>答：可以的，传递方式与上述的描述是一样的，关键是怎么接收。例如：</p><p>传递：</p><p>#./test.sh a b c</p><p>接收：</p><p>在脚本中可以用“$1”来表示a，“$2”来表示b，以此类推。</p><p><strong>接收可以用“$”加上选项对应的序号即可。</strong></p><p>测试：编写test14.sh，传递a，b，c，输出其值</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image28.png" alt="img"></p><p>其实$1、$2是变量。</p><p>练习：创建自定义<strong>指令“user”</strong>，可以直接执行，要求该指令具备以下语法和功能：</p><p>​    a. #user -add 用户名           【添加用户】</p><p>​    b. #user -del 用户名            【删除用户及其家目录】</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image29.png" alt="img"></p><p>同时题目中要求是指令，所以可以再去添加个别名：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image30.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shell基础&quot;&gt;&lt;a href=&quot;#Shell基础&quot; class=&quot;headerlink&quot; title=&quot;Shell基础&quot;&gt;&lt;/a&gt;Shell基础&lt;/h1&gt;&lt;h1 id=&quot;一、关于shell&quot;&gt;&lt;a href=&quot;#一、关于shell&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Shell脚本" scheme="https://roranrui.cn/categories/Shell%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="shell" scheme="https://roranrui.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>七.Linux网络基础</title>
    <link href="https://roranrui.cn/2022/04/26/qi-linux-wang-luo-ji-chu/"/>
    <id>https://roranrui.cn/2022/04/26/qi-linux-wang-luo-ji-chu/</id>
    <published>2022-04-26T12:34:05.000Z</published>
    <updated>2022-05-01T03:49:35.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux的网络基础"><a href="#Linux的网络基础" class="headerlink" title="Linux的网络基础"></a>Linux的网络基础</h1><h1 id="一、网络相关概述"><a href="#一、网络相关概述" class="headerlink" title="一、网络相关概述"></a>一、网络相关概述</h1><h2 id="1、网络发展"><a href="#1、网络发展" class="headerlink" title="1、网络发展"></a>1、网络发展</h2><p><strong>信息传递</strong></p><p>n 远古时期，人们就通过简单的语言、壁画等方式交换信息</p><p>n 千百年来，人们一直在用语言、图符、钟鼓、烟火、竹简、纸书等传递信息</p><p>n 古代人的烽火狼烟、飞鸽传信、驿马邮递</p><p>n 现代社会中，交通警的指挥手语、航海中的旗语等</p><p>n 这些信息传递的基本方式都是依靠人的视觉与听觉</p><p><strong>电的产生</strong></p><p>n 1831年，法拉第制出了世界上最早的第一台发电机</p><p>n 1866年，德国人西门子（Siemens）制成世界上第一台大功率发电机</p><p>n 1837年，美国人塞缪乐·莫乐斯成功地研制出世界上第一台电磁式电报机</p><p>n 1844年5月24日，莫乐斯在国会大厦联邦最高法院会议厅进行了“用莫尔斯电码”发出了人类历史上的第一份电报，从而实现了长途电报通信</p><p><strong>网络诞生</strong></p><p>n 1957年，前苏联发射了第一颗人造卫星，震惊了美国</p><p>n 1958年美国成立了国防部<strong>高级研究计划署</strong>（ARPA，Advanced Research Projects Agency），应对冷战形势，ARPA是一个管理机构，没有实验室和科学家</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image2.png" alt="http://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Arpanet_1974.svg/800px-Arpanet_1974.svg.png"></p><p>n 1969年，ARPANET（阿帕网）开始联机，<strong>因此1969年被称为Internet元年</strong></p><p><strong>网络分类（记忆）</strong></p><p>n <strong>局域网</strong>（Local Area Network，<strong>LAN</strong>）是指范围在几百米到十几公里内办公楼群或校园内的计算机相互连接所构成的计算机网络。</p><p>n 城域网（Metropolitan Area Network，MAN）所采用的技术基本上与局域网相类似，只是规模上要大一些。城域网既可以覆盖相距不远的几栋办公楼，也可以覆盖一个城。</p><p>n <strong>广域网</strong>（Wide Area Network，<strong>WAN</strong>）通常跨接很大的物理范围，如一个国家。</p><p>除了上述的划分，<strong>网络还可以按照所有者分</strong>为公网、私网是两种Internet的接入方式。公网接入方式：上网的计算机得到的IP地址是Internet上的非保留地址，公网的计算机和Internet上的其他计算机可随意互相访问。私网则反之。</p><h2 id="2、ip地址（重点记忆）"><a href="#2、ip地址（重点记忆）" class="headerlink" title="2、ip地址（重点记忆）"></a>2、ip地址（重点记忆）</h2><p>IP是英文Internet Protocol的缩写，意思是“网络之间互连的协议”，也就是为计算机网络相互连接进行通信而设计的<strong>协议</strong>。</p><p><strong>IP地址类型分为：公有地址、私有地址。</strong></p><p>公有地址</p><p>公有地址（Public address）由Inter NIC（Internet Network Information Center因特网信息中心）负责。这些IP地址分配给注册并向Inter NIC提出申请的组织机构。通过它直接访问因特网。</p><p><strong>私有地址（重点）</strong></p><p>私有地址（Private address）属于<strong>非注册地址</strong>，专门为组织机构内部使用。以下列出留用的内部私有地址：</p><p>A类 10.0.0.0–10.255.255.255</p><p>B类 172.16.0.0–172.31.255.255</p><p><strong>C类 192.168.0.0–192.168.255.255</strong></p><p><strong>IP地址按类型可以分为三类：</strong></p><table><thead><tr><th>类别</th><th>最大网络数</th><th>IP地址范围</th><th>最大主机数</th><th>私有IP地址范围</th></tr></thead><tbody><tr><td>A</td><td>126（2^7-2)</td><td>1.0.0.0-127.255.255.255</td><td>16777214</td><td>10.0.0.0-10.255.255.255</td></tr><tr><td>B</td><td>16384(2^14)</td><td>128.0.0.0-191.255.255.255</td><td>65534</td><td>172.16.0.0-172.31.255.255</td></tr><tr><td>C</td><td>2097152(2^21)</td><td>192.0.0.0-223.255.255.255</td><td>254</td><td>192.168.0.0-192.168.255.255</td></tr></tbody></table><p>网络运维相关技能：ip分类、<strong>子网划分</strong>、划分vlan、ACL、综合布线、各种Serve的搭建。</p><p>127.0.0.1         本机ip</p><h2 id="3、网卡"><a href="#3、网卡" class="headerlink" title="3、网卡"></a>3、网卡</h2><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image004.jpg" alt="img"></p><p>网卡是一个网络组件，属于硬件范畴，主要负责计算机之间数据的<strong>封装和解封</strong>。</p><p>MAC地址：网卡的物理地址，网卡设备的编号，<strong>默认</strong>情况是全球唯一的（16进制）。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image5.png" alt="img"></p><p><strong>与IP地址的区别：</strong></p><p>n 长度不同。IP地址为32位，MAC地址为48位。</p><p>n 分配依据不同。</p><p>n <strong>网络寻址方式不同</strong>。OSI参考模型，ip地址是基于第三层工作（网络层），mac地址是第二层（数据链路层）</p><h2 id="4、网线"><a href="#4、网线" class="headerlink" title="4、网线"></a>4、网线</h2><p>网线是连接局域网必不可少的。在局域网中常见的网线主要有双绞线（RJ45接口）、铜轴电缆、光缆三种。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image7.jpg" alt="img"><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image9.jpg" alt="img"><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image11.jpg" alt="img"></p><p>​         双绞线                       铜轴电缆                  光纤</p><h2 id="5、交换机"><a href="#5、交换机" class="headerlink" title="5、交换机"></a>5、交换机</h2><p>交换机（Switch）意为“开关”，是一种用于电（光）信号转发的网络设备，交换机它可以为接入交换机的任意两个网络节点提供<strong>独享</strong>的电信号通路。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image13.jpg" alt="img"></p><p>目前，交换机品牌比较有名的是：华为、华三（h3c）、思科、锐捷。</p><h2 id="6、路由器"><a href="#6、路由器" class="headerlink" title="6、路由器"></a>6、路由器</h2><p>路由器（Router）又称网关设备（Gateway）是用于<strong>连接多个逻辑上分开、相对独立的网络</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image15.jpg" alt="img">       <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image17.jpg" alt="img"></p><h2 id="7、拓扑结构图（扩展）"><a href="#7、拓扑结构图（扩展）" class="headerlink" title="7、拓扑结构图（扩展）"></a>7、拓扑结构图（扩展）</h2><p>所谓“拓扑”就是把实体抽象成与其大小、形状无关的“点”，而把连接实体的线路抽象成“线”，进而以图的形式来表示这些点与线之间关系的方法，<strong>其目的在于研究这些点、线之间的相连关系</strong>。表示点和线之间关系的图被称为拓扑结构图。</p><p>常见的几种拓扑结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image019.jpg" alt="img">  <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image21.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image23.jpg" alt="img">          <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image25.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image27.jpg" alt="img">         <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image29.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image31.jpg" alt="img"></p><h1 id="二、网络相关命令"><a href="#二、网络相关命令" class="headerlink" title="二、网络相关命令"></a>二、网络相关命令</h1><h2 id="1、ping"><a href="#1、ping" class="headerlink" title="1、ping"></a>1、ping</h2><p><strong>作用：检测当前主机与目标主机之间的连通性</strong>（不是100%准确，有的服务器是禁ping）</p><p>语法：#ping 主机地址（ip地址、主机名、域名等）</p><p>例如：测试和baidu.com之间的连通性。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image33.jpg" alt="img"></p><p>该命令可以跨平台，windows下也可以使用，语法一致。（区别在于Linux下默认一直发送，windows下默认发送4个数据包）</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image35.jpg" alt="img"></p><h2 id="2、netstat"><a href="#2、netstat" class="headerlink" title="2、netstat"></a>2、netstat</h2><p><strong>作用：表示查看网络的连接信息</strong></p><p>语法：#netstat -tnlp      （-t：tcp协议，-n：将字母转化成数字，-l：列出状态为监听，-p：显示进程相关信息）</p><p>​     #netstat -an       （-a：表示全部，-n：将字母转化为数字）</p><p>TCP/IP协议需要使用这个命令。</p><h2 id="3、traceroute"><a href="#3、traceroute" class="headerlink" title="3、traceroute"></a>3、traceroute</h2><p><strong>作用：查找当前主机与目标主机之间所有的网关</strong>（路由器，会给沿途各个路由器发送icmp数据包，路由器可能会不给响应）。</p><p>该命令不是内置命令，需要安装，但是目前的已经安装好了（之前选了开发工具）。</p><p>语法：#traceroute 主机地址</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image37.jpg" alt="img"></p><p>类似于查看快递的跟踪路由：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image39.jpg" alt="img"></p><p>扩展：在windows下也有类似的命令：tracert 主机地址</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image41.jpg" alt="img"></p><p>在线工具网址：<a href="http://tool.chinaz.com/">http://tool.chinaz.com</a></p><h2 id="4、arp"><a href="#4、arp" class="headerlink" title="4、arp"></a>4、arp</h2><p>地址解析协议，即ARP（Address Resolution Protocol），是<strong>根据IP地址获取（MAC）物理地址的协议</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image043.png" alt="img"></p><p><strong>当一个主机发送数据时，首先查看本机MAC地址缓存中有没有目标主机的MAC地址，</strong> <strong>如果有就使用缓存中的结果；如果没有，ARP协议就会发出一个广播包，该广播包要求查询目标主机IP地址对应的MAC地址，拥有该IP地址的主机会发出回应，回应中包括了目标主机的MAC地址，这样发送方就得到了目标主机的MAC地址。如果目标主机不在本地子网中，则ARP解析到的MAC地址是默认网关的MAC地址</strong>。</p><p>常用语法：#arp -a     查看本地缓存mac表</p><p>​          #arp -d 主机地址            删除指定的缓存记录</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image45.jpg" alt="img"></p><p>该命令在windows下同样适用。</p><h2 id="5、tcpdump-了解"><a href="#5、tcpdump-了解" class="headerlink" title="5、tcpdump(了解)"></a>5、tcpdump(了解)</h2><p>作用：抓包，抓取数据表</p><p>常用语法：</p><p>​    #tcpdump 协议 port 端口</p><p>​    #tcpdump 协议 port 端口 host 地址</p><p>​    #tcpdump -i 网卡设备名</p><p>查看22端口（ssh）的数据包：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image47.jpg" alt="img"></p><p>00:09:17.xxxx         监听数据的时分秒</p><p>IP：使用的协议类型</p><p>192.168.21.1          数据包的一个方向（来自）</p><p>&gt;                    数据的流向</p><p>192.168.21.136        数据包的另外一个方向（到达）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux的网络基础&quot;&gt;&lt;a href=&quot;#Linux的网络基础&quot; class=&quot;headerlink&quot; title=&quot;Linux的网络基础&quot;&gt;&lt;/a&gt;Linux的网络基础&lt;/h1&gt;&lt;h1 id=&quot;一、网络相关概述&quot;&gt;&lt;a href=&quot;#一、网络相关概述&quot; cla</summary>
      
    
    
    
    <category term="操作系统学习" scheme="https://roranrui.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="操作系统" scheme="https://roranrui.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>六.Linux权限管理操作</title>
    <link href="https://roranrui.cn/2022/04/26/liu.linux-quan-xian-guan-li-cao-zuo/"/>
    <id>https://roranrui.cn/2022/04/26/liu.linux-quan-xian-guan-li-cao-zuo/</id>
    <published>2022-04-26T07:37:28.000Z</published>
    <updated>2022-04-26T07:38:06.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux的权限管理操作"><a href="#Linux的权限管理操作" class="headerlink" title="Linux的权限管理操作"></a>Linux的权限管理操作</h1><p><strong>Linux的权限操作与用户、用户组是兄弟操作。</strong></p><h1 id="一、权限概述"><a href="#一、权限概述" class="headerlink" title="一、权限概述"></a>一、权限概述</h1><p>总述：Linux系统一般将文件可存/取访问的身份分为3个类别：owner、group、others，且3种身份各有read、write、execute等权限。</p><h2 id="1、权限介绍"><a href="#1、权限介绍" class="headerlink" title="1、权限介绍"></a>1、权限介绍</h2><p>什么是权限？</p><p>在多用户（可以不同时）计算机系统的管理中，权限是指某个特定的用户具有特定的系统资源使用权力，像是文件夹、特定系统指令的使用或存储量的限制。</p><p>在Linux中分别有读、写、执行权限：</p><p>读权限：</p><p>​    对于文件夹来说，读权限影响用户是否能够列出目录结构</p><p>​    对于文件来说，读权限影响用户是否可以查看文件内容</p><p>写权限：</p><p>​    对文件夹来说，写权限影响用户是否可以在文件夹下“创建/删除/复制到/移动到”文档</p><p>​    对于文件来说，写权限影响用户是否可以编辑文件内容</p><p>执行权限：</p><p>​    一般都是对于文件来说，特别脚本文件。</p><h2 id="2、身份介绍"><a href="#2、身份介绍" class="headerlink" title="2、身份介绍"></a>2、身份介绍</h2><h3 id="Owner身份（文件所有者，默认为文档的创建者）"><a href="#Owner身份（文件所有者，默认为文档的创建者）" class="headerlink" title="Owner身份（文件所有者，默认为文档的创建者）"></a>Owner身份（文件所有者，默认为文档的创建者）</h3><p>由于Linux是多用户、多任务的操作系统，因此可能常常有多人同时在某台主机上工作，但每个人均可在主机上设置文件的权限，让其成为个人的“私密文件”，即个人所有者。因为设置了适当的文件权限，除本人（文件所有者）之外的用户无法查看文件内容。</p><p>例如某个MM给你发了一封Email情书，你将情书转为文件之后存档在自己的主文件夹中。为了不让别人看到情书的内容，你就能利用所有者的身份去设置文件的适当权限，这样，即使你的情敌想偷看你的情书内容也是做不到的。</p><h3 id="Group身份（与文件所有者同组的用户）"><a href="#Group身份（与文件所有者同组的用户）" class="headerlink" title="Group身份（与文件所有者同组的用户）"></a>Group身份（与文件所有者同组的用户）</h3><p>与文件所有者同组最有用的功能就体现在<strong>多个团队在同一台主机上开发资源的时候</strong>。例如主机上有A、B两个团体，A中有a1,a2,a3三个成员，B中有b1,b2两个成员，这两个团体要共同完成一份报告F。由于设置了适当的权限，A、B团体中的成员都能互相修改对方的数据，但是团体C的成员则不能修改F的内容，甚至连查看的权限都没有。同时，团体的成员也能设置自己的私密文件，让团队的其它成员也读取不了文件数据。<strong>在Linux中，每个账户支持多个用户组。如用户a1、b1即可属于A用户组，也能属于B用户组【主组和附加组】</strong>。</p><h3 id="Others身份（其他人，相对于所有者）"><a href="#Others身份（其他人，相对于所有者）" class="headerlink" title="Others身份（其他人，相对于所有者）"></a>Others身份（其他人，相对于所有者）</h3><p>这个是个相对概念。打个比方，大明、二明、小明一家三兄弟住在一间房，房产证上的登记者是大明（owner所有者），那么，大明一家就是一个用户组，这个组有大明、二明、小明三个成员；另外有个人叫张三，和他们三没有关系，那么这个张三就是其他人了。</p><p>同时，大明、二明、小明有各自的房间，三者虽然能自由进出各自的房间，但是小明不能让大明看到自己的情书、日记等，这就是文件所有者（用户）的意义。</p><h3 id="Root用户（超级用户）"><a href="#Root用户（超级用户）" class="headerlink" title="Root用户（超级用户）"></a>Root用户（超级用户）</h3><p>在Linux中，还有一个神一样存在的用户，这就是root用户，因为在所有用户中它拥有最大的权限 ，所以管理着普通用户。</p><h2 id="3、Linux的权限介绍"><a href="#3、Linux的权限介绍" class="headerlink" title="3、Linux的权限介绍"></a>3、Linux的权限介绍</h2><p>要设置权限，就需要知道文件的一些基本属性和权限的分配规则。在Linux中，ls命令常用来查看文件的属性，用于显示文件的文件名和相关属性。</p><p>#ls -l 路径      【ls -l 等价于 ll】</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image2.jpg" alt="img"></p><p>标红的部分就是Linux的文档权限属性信息。</p><p><strong>Linux中存在用户、用户组和其他人概念</strong>，各自有不同的权限，对于一个文档来说，其权限具体分配如下：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image3.png" alt="img"></p><p>十位字符表示含义：</p><p>第1位：表示文档类型，取值常见的有“d表示文件夹”、“-表示文件”、“l表示软连接”、“s表示套接字”等等；</p><p>第2-4位：表示文档所有者的权限情况，第2位表示读权限的情况，取值有r、-；第3位表示写权限的情况，w表示可写，-表示不可写，第4位表示执行权限的情况，取值有x、-。</p><p>第5-7位：表示与所有者同在一个组的用户的权限情况，第5位表示读权限的情况，取值有r、-；第6位表示写权限的情况，w表示可写，-表示不可写，第7位表示执行权限的情况，取值有x、-。</p><p>第8-10位：表示除了上面的前2部分的用户之外的其他用户的权限情况，第8位表示读权限的情况，取值有r、-；第9位表示写权限的情况，w表示可写，-表示不可写，第10位表示执行权限的情况，取值有x、-。</p><p>权限分配中,均是rwx的三个参数组合，<strong>且位置顺序不会变化</strong>。没有对应权限就用 – 代替。</p><p><strong>例如：以下一个文档权限是怎么样的？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image5.jpg" alt="img"></p><p>a. 其是文件夹类型</p><p>b. 所有者：拥有全部权限（读写执行）</p><p>c. 同组用户：可读、可执行</p><p>d. 其他用户：可读、可执行</p><h1 id="二、权限设置"><a href="#二、权限设置" class="headerlink" title="二、权限设置"></a>二、权限设置</h1><p><strong>语法：#chmod</strong> <strong>选项</strong> <strong>权限模式</strong> <strong>文档</strong></p><p>注意事项：</p><p>​    常用选项：</p><p>​             -R：递归设置权限 （当文档类型为文件夹的时候）</p><p>​    权限模式：就是该文档需要设置的权限信息</p><p>​    文档：可以是文件，也可以是文件夹，可以是相对路径也可以是绝对路径。</p><p><strong>注意点：如果想要给文档设置权限，操作者要么是root用户，要么就是文档的所有者。</strong></p><h2 id="1、字母形式"><a href="#1、字母形式" class="headerlink" title="1、字母形式"></a>1、字母形式</h2><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image7.jpg" alt="img"></p><p>给谁设置：</p><p>​    u：表示所有者身份owner（user）</p><p>​    g：表示给所有者同组用户设置（group）</p><p>​    o：表示others，给其他用户设置权限</p><p>​    a：表示all，给所有人（包含ugo部分）设置权限</p><p>​         <strong>如果在设置权限的时候不指定给谁设置，则默认给所有用户设置</strong></p><p>权限字符：</p><p>​    r：读</p><p>​    w：写</p><p>​    x：表示执行</p><p>​    -：表示没有权限</p><p>权限分配方式：</p><p>​    +：表示给具体的用户新增权限（相对当前）</p><p>​    -：表示删除用户的权限（相对当前）</p><p>​    =：表示将权限设置成具体的值（注重结果）【赋值】</p><p><strong>例如：需要给anaconda-ks.cfg文件（-rw——-.）设置权限，要求所有者拥有全部的权限，同组用户拥有读和执行权限，其他用户只读权限。</strong></p><p>答案：</p><p>①#chmod u+x,g+rx,o+r anaconda-ks.cfg</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image9.jpg" alt="img"></p><p>​    ②#chmod u=rwx,g=rx,o=r anaconda-ks.cfg</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image11.jpg" alt="img"></p><p><strong>提示：当文档拥有执行权限（任意部分），则其颜色在终端中是绿色。</strong></p><p>#chmod ug=rwx 形式，如果有两部分权限一样则可以合在一起写的</p><p><strong>例如：如果anaconda-ks.cfg文件什么权限都没有，可以使用root用户设置所有人都有执行权限，则可以写成</strong></p><p>​    ①#chmod +x anaconda-ks.cfg</p><p>​    ②#chmod a=x anaconda-ks.cfg</p><p>​    ③#chmod a+x anaconda-ks.cfg</p><h2 id="2、数字形式"><a href="#2、数字形式" class="headerlink" title="2、数字形式"></a>2、数字形式</h2><p>经常会在一些技术性的网页上看到类似于**#chmod 777 a.txt**  这样的一个权限，这种形式称之为数字形式权限（777）。</p><p><strong>读：r     4</strong></p><p><strong>写：w        2</strong></p><p><strong>执行：x      1</strong></p><p>没有任何权限：0</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image13.jpg" alt="img"></p><p>例如：需要给anaconda-ks.cfg设置权限，权限要求所有者拥有全部权限，同组用户拥有读执行权限，其他用户只读。</p><p><strong>全部权限（u）：读+写+执行=4+2+1=7</strong></p><p><strong>读和执行（g）：读+执行=4+1=5</strong></p><p><strong>读权限（o）：读=4</strong></p><p>由上得知权限为：754</p><p>#chmod 754 anaconda-ks.cfg</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image15.jpg" alt="img"></p><p><strong>面试题：用超级管理员设置文档的权限命令是#chmod -R 731 aaa，请问这个命令有没有什么不合理的地方？</strong></p><p>拥有者：7=4+2+1=读+写+执行</p><p>同组用户：3=2+1=写+执行</p><p>其他用户：1=1=执行</p><p>注意：<strong>在写权限的时候千万不要设置类似于上面的这种“奇葩权限”</strong>。如果一个权限数字中但凡出现2与3的数字，则该权限有不合理的情况。</p><h2 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h2><p>使用root用户创建一个文件夹（/oo），权限默认，权限如下：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image016.png" alt="img"></p><p>需要在oo目录下创建文件（oo/xx.txt），需要给777权限：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image18.jpg" alt="img"></p><p>切换到test用户（不是文档所有者，也不是同组用户，属于other部分）：</p><p>问题1：test用户是否可以打开oo/xx.txt文件？【能打开】</p><p>问题2：test用户是否可以编辑oo/xx.txt文件？【可以】</p><p>问题3：test用户是否可以删除oo/xx.txt文件？【不可以，同样还不允许创建文件/文件夹、移动文件、重命名文件】</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image20.jpg" alt="img"></p><p><strong>在Linux中，如果要删除一个文件，不是看文件有没有对应的权限，而是看文件所在的目录是否有写权限，如果有才可以删除</strong>。</p><h1 id="三、属主与属组设置"><a href="#三、属主与属组设置" class="headerlink" title="三、属主与属组设置"></a>三、属主与属组设置</h1><p>属主：所属的用户（文件的主人）</p><p>属组：所属的用户组</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image022.jpg" alt="img"></p><p>前面的那个root就是属主</p><p>后面的那个root就是属组</p><p>这两项信息在文档创建的时候会使用创建者的信息（用户名、用户所属的主组名称）。</p><p>如果有时候去删除某个用户，则该用户对应的文档的属主和属组信息就需要去修改。</p><h2 id="1、chown（重点）"><a href="#1、chown（重点）" class="headerlink" title="1、chown（重点）"></a>1、chown（重点）</h2><p><strong>作用：更改文档的所属用户</strong></p><p>语法：#chown -R username 文档路径</p><p>案例：将刚才root用户创建的oo目录，所有者更改为test</p><p>#chown test oo/</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image24.jpg" alt="img"></p><h2 id="2、chgrp（了解）"><a href="#2、chgrp（了解）" class="headerlink" title="2、chgrp（了解）"></a>2、chgrp（了解）</h2><p><strong>作用：更改文档的所属用户组</strong></p><p>语法：#chgrp -R groupname 文档的路径</p><p>案例：将刚才root用户创建的oo目录，所有者更改为test，并且将所属用户组也改为test</p><p>#chgrp test oo/</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image26.jpg" alt="img"></p><p><strong>思考，如何通过一个命令实现既可以更改所属的用户，也可以修改所属的用户组呢？</strong></p><p>答：可以实现的，通过chown命令</p><p>​    语法：#chown -R username:groupname  文档路径</p><p>案例：要求只使用chown指令，将oo目录的所属用户和用户组改回成root，并且包含其子目录</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image28.jpg" alt="img"></p><h1 id="四、扩展（1）"><a href="#四、扩展（1）" class="headerlink" title="四、扩展（1）"></a>四、扩展（1）</h1><p>问题：reboot、shutdown、init、halt、user管理，在普通用户身份上都是操作不了，但是有些特殊的情况下又需要有执行权限。又不可能让root用户把自己的密码告诉普通用户，这个问题该怎么解决？</p><p><strong>该问题是可以被解决的，可以使用sudo（switch user do）命令来进行权限设置。Sudo可以让管理员（root）事先定义某些特殊命令谁可以执行</strong>。</p><p>默认sudo中是没有除root之外用户的规则，要想使用则先<strong>配置</strong>sudo。</p><p><strong>Sudo配置文件：/etc/sudoers</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image29.png" alt="img"></p><p>a. 配置sudo文件请使用“#visudo”，打开之后其使用方法和vim一致</p><p>b. 配置普通用户的权限</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image030.png" alt="img"></p><p>Root表示用户名，如果是用户组，则可以写成“%组名”</p><p>ALL：表示允许登录的主机（地址白名单）</p><p>(ALL)：表示以谁的身份执行，ALL表示root身份</p><p>ALL：表示当前用户可以执行的命令，多个命令可以使用“,”分割</p><p><strong>案例：本身test用户不能添加用户，要求使用sudo配置，将其设置为可以添加用户，并且可以修改密码（但是不能修改root用户密码）。</strong></p><p>注意：在写sudo规则的时候不建议写直接形式的命令，而是写命令的完整路径。</p><p>路径可以使用which命令来查看</p><p>语法：#which 指令名称</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image31.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image32.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image034.jpg" alt="img"></p><p>在添加好对应的规则之后就可以切换用户，切换到普通用户test，再去执行：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image35.png" alt="img"></p><p>此时要想使用刚才的规则，则以以下命令进行：</p><p><strong>#sudo</strong> <strong>需要执行的指令</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image36.png" alt="img"></p><p><strong>在输入sudo指令之后需要输入当前的用户密码进行确认的操作（不是root用户密码），输入之后在接下来5分钟内再次执行sudo指令不需要密码</strong>。</p><p>特别注意：此处按照案例要求，不能让test用户修改root密码，因此规则还需要调整，不然其可以修改root密码的：</p><p><strong>禁止修改root密码的配置（先允许全部，再拒绝root密码设置）：</strong> /usr/bin/passwd [A-Za-z]*, <strong>!/usr/bin/passwd root</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image38.jpg" alt="img"></p><p>补充：在普通用户下怎么查看自己具有哪些特殊权限呢？</p><p><strong>#sudo -l</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image040.jpg" alt="img"></p><p>最后：sudo不是任何Linux分支都有的命令，常见centos与ubuntu都存在sudo命令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux的权限管理操作&quot;&gt;&lt;a href=&quot;#Linux的权限管理操作&quot; class=&quot;headerlink&quot; title=&quot;Linux的权限管理操作&quot;&gt;&lt;/a&gt;Linux的权限管理操作&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Linux的权限操作与用户、用户组是兄弟操作</summary>
      
    
    
    
    <category term="操作系统学习" scheme="https://roranrui.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="操作系统" scheme="https://roranrui.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>五.Linux自有服务（二）</title>
    <link href="https://roranrui.cn/2022/04/26/wu.linux-zi-you-fu-wu-er/"/>
    <id>https://roranrui.cn/2022/04/26/wu.linux-zi-you-fu-wu-er/</id>
    <published>2022-04-26T07:29:55.000Z</published>
    <updated>2022-04-30T09:34:23.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux自有服务（2）"><a href="#Linux自有服务（2）" class="headerlink" title="Linux自有服务（2）"></a>Linux自有服务（2）</h1><p>自有服务，即不需要用户独立去安装的软件的服务，而是当系统安装好之后就可以直接使用的服务（内置）。</p><h1 id="一、设置主机名"><a href="#一、设置主机名" class="headerlink" title="一、设置主机名"></a>一、设置主机名</h1><p>回顾：</p><p>#hostname</p><p>#hostname -f      FQDN（全限定域名）</p><p>①临时设置主机名（立竿见影），需要切换用户使之生效</p><p>#hostname 设置的主机名</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image1.png" alt="img"></p><p>②永久设置主机名（需要重启）</p><p>先找到一个文件</p><p>/etc/sysconfig/network      【主机名的配置文件】</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image2.png" alt="img"></p><p>修改其中的HOSTNAME为自己需要设置的永久主机名</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image3.png" alt="img"></p><p><strong>③修改linux服务器的hosts文件，将yunwei指向本地（设置FQDN）</strong></p><p>Hosts文件的位置：/etc/hosts</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image5.jpg" alt="img"></p><p>问题：不设置FQDN会怎么样？</p><p>​    ①很多开源服务器软件（例如Apache）则无法启动，或出现报错；</p><p>​    ②方便记忆，看到主机名对其作用有一个初步判断；</p><p>​    ③如果不设置则会影响本地的域名的解析（本地访问）；</p><h1 id="二、chkconfig"><a href="#二、chkconfig" class="headerlink" title="二、chkconfig"></a>二、chkconfig</h1><p>作用：相当于windows下“安全卫士”、“电脑管家”之类的安全辅助工具<strong>提供“开机启动项”的一个管理服务</strong>。</p><p>在linux下不是所有的软件安装完成之后都有开机启动服务，有的可能需要自己去添加。除此之外还可以查看和删除。</p><p>①开机启动<strong>服务查询</strong></p><p>#chkconfig –list</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image7.jpg" alt="img"></p><p>其中0-6表示各个启动级别</p><p>例如：以httpd为例，其3级别为关闭（off），则表示其在3启动形式下默认开机不启动</p><p>5对应的也是关闭，则表示其在桌面环境下也是开机不启动。</p><p>再例如：kdump服务，在2，3，4，5的级别下默认开机启动的，其他级别下默认开机不启动</p><p>②删除服务</p><p>#chkconfig –del 服务名</p><p>例如删除httpd服务</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image9.jpg" alt="img"></p><p>③添加开机启动服务</p><p>#chkconfig –add 服务名            【必须要保证服务正常运行，才可以添加】</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image11.jpg" alt="img"></p><p><strong>④设置服务在某个级别下开机启动/不启动【重点命令】</strong></p><p><strong>#chkconfig –level</strong> <strong>连在一起的启动级别</strong> <strong>服务名on/off</strong></p><p>案例：设置httpd服务在3，5级别下默认开机启动</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image13.jpg" alt="img"></p><p>案例：设置httpd服务在5的级别下默认开机不启动</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image15.jpg" alt="img"></p><h1 id="三、ntp服务"><a href="#三、ntp服务" class="headerlink" title="三、ntp服务"></a>三、ntp服务</h1><p>作用：ntp主要是用于<strong>对计算机的时间同步管理</strong>操作。</p><p>时间是对服务器来说是很重要的，一般很多网站都需要读取服务器时间来记录相关信息，如果时间不准，则可能造成很大的影响。</p><p>例如：当前虚拟机里的linux时间就是不准确的</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image16.png" alt="img"></p><p>同时服务器时间方式有2个：<strong>一次性同步（手动同步）、通过服务自动同步</strong>。</p><p>上游的概念：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image18.jpg" alt="img"></p><p>①一次性同步时间（简单）</p><p><strong>#ntpdate</strong> <strong>时间服务器的域名或ip地址</strong></p><p>Ip地址查看可以访问：<a href="http://www.ntp.org.cn/pool.php">http://www.ntp.org.cn/pool.php</a></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image20.jpg" alt="img"></p><p>②设置时间同步服务</p><p>服务名：ntpd</p><p>启动ntpd服务</p><p>​    #service ntpd start   或者  /etc/init.d/ntpd start</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image22.jpg" alt="img"></p><p>设置ntpd服务开机启动：</p><p># chkconfig –list|grep ntpd</p><p># chkconfig –level 35 ntpd on</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image24.jpg" alt="img"></p><h1 id="四、防火墙服务"><a href="#四、防火墙服务" class="headerlink" title="四、防火墙服务"></a>四、防火墙服务</h1><p>防火墙：<strong>防范一些网络攻击</strong>。有<strong>软件防火墙</strong>、硬件防火墙之分。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image25.png" alt="img"></p><p>防火墙选择让请求通过，从而保证网络安全性。</p><p><strong>在当前的centos6.5中防火墙有一个名称：iptables</strong> 【7.x中默认使用的是firewalld】</p><p>①查看iptables是否开机启动</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image27.jpg" alt="img"></p><p>②iptables服务启动/重启/关闭</p><p>#service iptables start/restart/stop</p><p>/etc/init.d/iptables start /restart/stop</p><p><strong>③查看iptables的状态（规则）</strong></p><p>]# service iptables status</p><p>如果iptables没有启动，则提示服务没启动，如果已经启动，则显示防火墙的相关的规则信息</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image29.jpg" alt="img"></p><p>④查看规则的命令</p><p>#iptables -L -n</p><p>含义：</p><p>​    -L：表示列出规则</p><p>​    -n：表示将单词表达形式改成数字形式显示</p><p>⑤简单设置防火墙规则</p><p>例如，需要允许80端口通过防火墙，则规则可以用以下的命令来设置</p><p><strong>#iptables -I INPUT -p tcp –dport 80 -j ACCEPT  #允许访问80端口</strong></p><p>Iptables：主命令</p><p>-I：表示将规则放到最前面</p><p>-A：add，添加规则（最后）</p><p>INPUT：进站请求【出站output】</p><p>-p：protocol，指定协议（icmp/tcp/udp）</p><p>–dport：指定端口号</p><p>-j：指定行为结果，允许（accept）/禁止（reject）/丢弃（drop）</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image31.jpg" alt="img"></p><p>添加完成之后需要保存操作：</p><p><strong>/etc/init.d/iptables save</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image33.jpg" alt="img"></p><p>测试80端口访问：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image34.png" alt="img"></p><h1 id="五、rpm管理（重点）"><a href="#五、rpm管理（重点）" class="headerlink" title="五、rpm管理（重点）"></a>五、rpm管理（重点）</h1><p>作用：rpm的作用类似于windows上的电脑管家中“软件管理”、安全卫士里面“软件管家”等产品，主要作用是对linux服务器上的软件包进行对应管理操作，<strong>管理分为：查询、卸载、安装</strong>。</p><p>①查询某个软件的安装情况</p><p><strong>#rpm -qa|grep</strong> <strong>关键词</strong></p><p>选项：</p><p>​    -q：查询，query</p><p>​    -a：全部，all</p><p>案例：查询linux上是否安装firefox</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image35.png" alt="img"></p><p>案例：查询是否安装qq</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image36.png" alt="img"></p><p>②卸载某个软件</p><p>#rpm -e 软件的名称</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image38.jpg" alt="img"></p><p>火狐卸载的时候是没有依赖关系的，所以可以直接卸载。</p><p>但是在卸载Apache的时候提示无法卸载：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image40.jpg" alt="img"></p><p>当存在依赖关系的时候又不想去解决这个问题的时候可以：</p><p>#rpm -e 软件包名 –nodeps</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image41.png" alt="img"></p><p>③软件的安装</p><p>要想装软件，和windows下一样，先得找到安装包。</p><p>​    软件包的获得方式：</p><p>​         a. 去官网去下载；</p><p>​         b. 不介意老版本的话，可以从光盘（或者镜像文件）中读取；</p><p>此处以光盘文件为例：</p><p><strong>查看块状设备的信息：</strong></p><p>#lsblk  （list block devices）       查看块状设备的信息  </p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image43.jpg" alt="img"></p><p>Name：名称</p><p>Size：设备大小</p><p>Type：类型</p><p>MountPoint：挂载点（类似windows下盘符）</p><p><strong>扩展：光盘的挂载和解挂</strong></p><p>a. 解挂操作</p><p>​    命令：umount</p><p>​    <strong>语法：#umount</strong> <strong>当前设备的挂载点（路径）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image45.jpg" alt="img"></p><p>此时，相当于U盘在windows上已经被弹出了，但是没有拔下电脑USB接口。</p><p>b. 挂载光盘</p><p>​    命令：mount</p><p>​    <strong>语法：#mount</strong> <strong>设备原始地址</strong> <strong>要挂载的位置路径</strong></p><p>设备原始地址：地址统一都在/dev下，然后根据大小确定具体name值，拼凑在一起组成原始地址，例如当前：“/dev/sr0”</p><p>要挂载的位置路径：挂载目录一般都在mnt下，也可以在mnt下建目录，此处以“/mnt/dvd”为例</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image47.jpg" alt="img"></p><p><strong>安装软件的命令：</strong></p><p><strong>#rpm -ivh</strong> <strong>软件包完整名称</strong></p><p>选项：</p><p>​    -i：install，安装</p><p>​    -v：显示进度条</p><p>​    -h：表示以“#”形式显示进度条</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image49.jpg" alt="img"></p><h1 id="六、cron-x2F-crontab计划任务（重点）"><a href="#六、cron-x2F-crontab计划任务（重点）" class="headerlink" title="六、cron/crontab计划任务（重点）"></a>六、cron/crontab计划任务（重点）</h1><p>作用：操作系统不可能24小时都有人在操作，有些时候想在指定的时间点去执行任务（例如：每天夜里2点去重新启动Apache），此时不可能真有人每天夜里2点去执行命令，此时可以交给计划任务程序去执行操作。</p><p>语法：#crontab 选项</p><p>​    常用选项：</p><p>​         <strong>-l：list，列出指定用户的计划任务列表</strong></p><p>​         <strong>-e：edit，编辑指定用户的计划任务列表</strong></p><p>​         -u：user，指定的用户名，如果不指定，则表示当前用户</p><p>​         -r：remove，删除指定用户的计划任务列表</p><p>①列出</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image50.png" alt="img"></p><p><strong>②编辑计划任务（重点）</strong></p><p>计划任务的规则语法格式，以行为单位，一行则为一个计划：</p><p>分 时 日 月 周 需要执行的命令</p><p>例如：如果想要每天的0点0分执行reboot指令，则可以写成</p><p>0 0 * * * reboot</p><p><strong>取值范围：</strong></p><p>分：0~59</p><p>时：0~23</p><p>日：1~31</p><p>月：1~12</p><p>周：0~7，0和7表示星期天</p><p><strong>四个符号：</strong></p><p>*：表示取值范围中的每一个数字</p><p>-：做连续区间表达式的，要想表示1~7，则可以写成：1-7</p><p>/：表示每多少个，例如：想每10分钟一次，则可以在分的位置写：*/10</p><p>,：表示多个取值，比如想在1点，2点6点执行，则可以在时的位置写：1,2,6</p><p>问题1：每月1、10、22日的4:45重启network服务</p><p>45 4 1,10,22 * * service network restart</p><p>问题2：每周六、周日的1:10重启network服务</p><p>10 1 * * 6,0  service network restart</p><p>问题3：每天18:00至23:00之间每隔30分钟重启network服务</p><p>*/30 18-23 * * *  service network restart</p><p>问题4：每隔两天的上午8点到11点的第3和第15分钟执行一次重启</p><p>3,15 8-11 */2 * *  reboot</p><p>案例：真实测试案例，每1分钟往root家目录中的RT.txt中输入当前的时间信息，为了看到效果使用追加输出</p><p>计划任务：*/1 *  *  *  * ls ~&gt;&gt; /root/RT.txt</p><p><strong>Crontab权限问题：本身是任何用户都可以创建自己的计划任务</strong>。</p><p>但是超级管理员可以通过配置来设置某些用户不允许设置计划任务 ：</p><p>配置文件位于（黑名单）：</p><p>​    /etc/cron.deny             里面写用户名，一行一个</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image51.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/alip_image53.jpg" alt="img"></p><p>还有一个配置文件：（白名单）</p><p>​    /etc/cron.allow        （本身不存在，自己创建）</p><p><strong>注意：白名单优先级高于黑名单，如果一个用户同时存在两个名单文件中，则会被默认允许创建计划任务。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux自有服务（2）&quot;&gt;&lt;a href=&quot;#Linux自有服务（2）&quot; class=&quot;headerlink&quot; title=&quot;Linux自有服务（2）&quot;&gt;&lt;/a&gt;Linux自有服务（2）&lt;/h1&gt;&lt;p&gt;自有服务，即不需要用户独立去安装的软件的服务，而是当系统安装</summary>
      
    
    
    
    <category term="操作系统学习" scheme="https://roranrui.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="操作系统" scheme="https://roranrui.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>四.Linux自有服务（一）</title>
    <link href="https://roranrui.cn/2022/04/26/si.linux-zi-you-fu-wu-yi/"/>
    <id>https://roranrui.cn/2022/04/26/si.linux-zi-you-fu-wu-yi/</id>
    <published>2022-04-26T07:29:49.000Z</published>
    <updated>2022-04-26T07:36:30.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux自有服务（1）"><a href="#Linux自有服务（1）" class="headerlink" title="Linux自有服务（1）"></a>Linux自有服务（1）</h1><p>自有服务，即不需要用户独立去安装的软件的服务，而是当系统安装好之后就可以直接使用的服务（内置）。</p><h1 id="一、运行模式"><a href="#一、运行模式" class="headerlink" title="一、运行模式"></a>一、运行模式</h1><p>运行模式也可以称之为<strong>运行级别</strong>。</p><p>在linux中存在一个进程：init （initialize，初始化），进程id是1。</p><p>查看进程：#ps -ef|grep init</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image1.png" alt="img"></p><p>该进程存在一个对应的配置文件：inittab（<strong>系统运行级别配置文件</strong>，位置/etc/inittab）</p><p>文件的主要内容：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image3.jpg" alt="img"></p><p>根据上述的描述，可以得知，Centos6.5中存在7中运行级别/模式。</p><p>0 — 表示关机级别（不要将默认的运行级别设置成这个值）</p><p>1 — 单用户模式</p><p>2 — 多用户模式，不带NFS（Network File Syetem）</p><p>3 — 多用户模式，完全的多用户模式（不带桌面的，纯命令行模式）</p><p>4 — 没有被使用的模式（被保留模式）</p><p>5 — X11，完整的图形化界面模式</p><p>6 — 表示重启级别（不要将默认的运行级别设置成这个值）</p><p>与该级别相关的几个命令：</p><p>#init 0       表示关机</p><p>#init 3       表示切换到不带桌面的模式</p><p>#init 5       切换到图形界面</p><p>#init 6       重启电脑</p><p>注意：init指令需要超级管理员的权限，普通用户无法执行。</p><p><strong>这些命令其实都是调用的init进程，将数字（运行级别）传递给进程，进程去读配置文件执行对应的操作。</strong></p><p>①切换到纯命令行模式下（<strong>临时切换，重启之后又恢复</strong>）</p><p>#init 3</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image4.png" alt="img"></p><p>切换之后需要输入用户名和密码，在<strong>输入密码的时候没有“*”提示输入，只要自己确认输入的密码没有错误，按下回车即可</strong>。</p><p>②回到桌面模式</p><p>#init 5</p><p><strong>③设置模式永久为命令行模式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image5.png" alt="img"></p><p>将/etc/inittab文件中的initdefault值设置成3，然后重启操作系统。</p><h1 id="二、用户与用户组管理（重点）"><a href="#二、用户与用户组管理（重点）" class="headerlink" title="二、用户与用户组管理（重点）"></a>二、用户与用户组管理（重点）</h1><p>Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个惟一的用户名和各自的密码。</p><p>用户在登录时键入正确的用户名和密码后，就能够进入系统和自己的主目录。</p><p>要想实现用户账号的管理，要完成的工作主要有如下几个方面：</p><p>用户账号的添加、删除、修改以及用户密码的管理。</p><p>用户组的管理。</p><p><strong>注意三个文件：</strong></p><p>/etc/passwd               存储用户的关键信息</p><p>/etc/group                存储用户组的关键信息</p><p>/etc/shadow               存储用户的密码信息</p><h2 id="1、用户管理"><a href="#1、用户管理" class="headerlink" title="1、用户管理"></a>1、用户管理</h2><p>①添加用户</p><p>常用语法：#useradd 选项 用户名</p><p>常用选项：</p><p>​    -g：表示指定用户的用户主组，选项的值可以是用户组的id，也可以是组名</p><p>​    -G：表示指定用户的用户附加组，选项的值可以是用户组的id，也可以是组名</p><p>​    -u：uid，用户的id（用户的标识符），<strong>系统默认会从500之后按顺序分配uid</strong>，如果不想使用系统分配的，可以通过该选项自定义【类似于腾讯QQ的自选靓号情况】</p><p>​    -c comment：添加注释</p><p>案例：创建用户zhangsan，不带任何选项</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image6.png" alt="img"></p><p>验证是否成功：</p><p>​    a. 验证/etc/passwd的最后一行，查看是否有zhangsan的信息；</p><p>​    b. 验证是否存在家目录（在Centos下创建好用户之后随之产生一个同名家目录）；</p><p>扩展：认识passwd文件</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image8.jpg" alt="img"></p><p>用户名:密码:用户ID:用户组ID:注释:家目录:解释器shell</p><p>用户名：创建新用户名称，后期登录的时候需要输入；</p><p>密码：此密码位置一般情况都是“x”，表示密码的占位；</p><p>用户ID：用户的识别符；</p><p>用户组ID：该用户所属的主组ID；</p><p>注释：解释该用户是做什么用的；</p><p>家目录：用户登录进入系统之后默认的位置；</p><p>解释器shell：等待用户进入系统之后，用户输入指令之后，该解释器会收集用户输入的指令，传递给内核处理；</p><p><strong>注意：在不添加选项的时候，执行useradd之后会执行一系列的操作</strong></p><p>​    <strong>a.</strong> <strong>创建同名的家目录；</strong></p><p>​    <strong>b.</strong> <strong>创建同名的用户组；</strong></p><p>案例：添加选项，创建用户lisi，让lisi属于501主组，附加组500，自选靓号666。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image9.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image10.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image11.png" alt="img"></p><p><strong>注意：查看用户的主组可以查看passwd文件，查看附加组可以查看group文件。</strong></p><p>②修改用户</p><p>常用语法：#usermod 选项 用户名</p><p>Usermod：user modify，用户修改</p><p>常用选项：</p><p>​    -g：表示指定用户的用户主组，选项的值可以是用户组的id，也可以是组名</p><p>​    -G：表示指定用户的用户附加组，选项的值可以是用户组的id，也可以是组名</p><p>​    -u：uid，用户的id（用户的标识符），<strong>系统默认会从500之后按顺序分配uid</strong>，如果不想使用系统分配的，可以通过该选项自定义【类似于腾讯QQ的自选靓号情况】</p><p>​    -l：修改用户名</p><p>案例：修改zhangsan用户主组为500，附加组改为501</p><p>#usermod -g 500 -G 501 zhangsan</p><p>案例：修改zhangsan用户用户名，改为wangerma</p><p><strong>#usermod -l</strong> <strong>新的用户名</strong> <strong>旧的用户名</strong></p><p>#usermod -l wangerma zhangsan</p><p>③设置密码</p><p>Linux不允许没有密码的用户登录到系统，因此前面创建的用户目前都处于锁定状态，需要设置密码之后才能登录计算机。</p><p><strong>常用语法：#passwd</strong> <strong>用户名</strong></p><p>案例：设置wangerma用户的密码</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image12.png" alt="img"></p><p>在设置密码的时候也是没有任何输入提示的，放心输入，确保两次输入的密码一致，按下回车即可。</p><p>也可以使用弱密码，但是不建议，否则会看到以下的提示：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image14.jpg" alt="img"></p><p>设置密码之后shadow文件中的体现：能够看出lisi用户没有密码的。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image16.jpg" alt="img"></p><p>在设置用户密码之后可以登录帐号，例如此处需要登录wangerma</p><p>切换用户命令：#su [用户名]   （switch user）</p><p>如果用户名不指定则表示切换到root用户。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image17.png" alt="img"></p><p>切换用户需要注意的事项：</p><p>​    a. 从root往普通用户切换不需要密码，但是反之则需要root密码；</p><p>​    b. 切换用户之后前后的工作路径是不变的；</p><p>​    c. 普通用户没有办法访问root用户家目录，但是反之则可以；</p><p>④删除用户</p><p>常用语法：#userdel 选项 用户名</p><p>Userdel：user delete（用户删除）</p><p>常用选项：</p><p>​    -r：表示删除用户的同时，删除其家目录；</p><p>案例：删除wangerma用户</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image18.png" alt="img"></p><p><strong>注意：已经登录的wangerma用户删除的时候提示删除失败，但是没有登录的lisi用户可以正常删除</strong>。</p><p>解决办法：简单粗暴，kill对应用户的全部进程</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image20.jpg" alt="img"></p><p>提示：所有跟用户操作的命令（除passwd外）只有root超级管理员有权限执行。</p><h2 id="2、用户组管理"><a href="#2、用户组管理" class="headerlink" title="2、用户组管理"></a>2、用户组管理</h2><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，<strong>这个用户组在创建用户时同时创建</strong>。</p><p>用户组的管理涉及用户组的<strong>添加、删除和修改</strong>。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image21.png" alt="img"></p><p>文件结构：</p><p><strong>用户组名:密码:用户组ID:组内用户名</strong></p><p>密码：X表示占位符，虽然用户组可以设置密码，但是绝大部分的情况下不设置密码；</p><p>组内用户名：表示附加组是该组的用户名称；</p><p>①用户组添加</p><p>常用语法：#groupadd 选项 用户组名</p><p>常用选项：</p><p>​    -g：类似用户添加里的“-u”，-g表示选择自己设置一个自定义的用户组ID数字，如果自己不指定，则默认从500之后递增；</p><p>案例：使用groupadd指令创建一个新的用户组，命名为Administrators</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image22.png" alt="img"></p><p>②用户组编辑</p><p>常用语法：#groupmod 选项 用户组名</p><p>常用选项：</p><p>​    -g：类似用户修改里的“-u”，-g表示选择自己设置一个自定义的用户组ID数字</p><p>​    -n：类似于用户修改“-l”，表示设置新的用户组的名称</p><p>案例：修改Administrators用户组，将组ID从502改成520，将名称改为admins</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image24.jpg" alt="img"></p><p>③用户组删除</p><p>常用语法：#groupdel 用户组名</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image25.png" alt="img"></p><p>注意：当如果需要删除一个组，但是<strong>这个组是某个用户的主组时</strong>，则不允许删除；如果确实需要删除，则先从组内移出所有用户。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image27.jpg" alt="img"></p><h1 id="三、网络设置"><a href="#三、网络设置" class="headerlink" title="三、网络设置"></a>三、网络设置</h1><p>首先知道网卡配置文件位置：/etc/sysconfig/network-scripts</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image29.jpg" alt="img"></p><p>在目录中网卡的配置文件命名格式：ifcfg-网卡名称</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image31.jpg" alt="img"></p><p>ONBOOT：是否开机启动</p><p>BOOTPROTO：ip地址分配方式，DHCP表示动态主机分配协议</p><p>HWADDR：硬件地址，MAC地址</p><p>如果后续需要重启网卡怎么去操作呢？</p><p><strong>#service network restart</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image33.jpg" alt="img"></p><p>在有的分支版本中可能没有service命令来快速操作服务，但是有一个共性的目录：/etc/init.d</p><p>这个目录中放着很对服务的快捷方式。</p><p>此处重启网卡命令还可以使用：</p><p><strong>#/etc/init.d/network restart</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image35.jpg" alt="img"></p><p><strong>扩展1：</strong>如果修改网卡的配置文件，但是配置文件的目录层次很深，此时可以在浅的目录中创建一个快捷方式（软连接），方便以后去查找</p><p><strong>#ln -s</strong> <strong>原始文件的路径</strong> <strong>快捷方式的路径</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image37.jpg" alt="img"></p><p>通过ls -l可以列出如下的效果：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image39.jpg" alt="img"></p><p>其中，文件类型位置的“l”表示其类型为link（连接类型），后面的“-&gt;”指向的是原始文件路径。</p><p><strong>扩展2：如何去重启单个网卡？</strong></p><p>停止某个网卡：#ifdown 网卡名</p><p>开启某个网卡：#ifup 网卡名</p><p>例如：需要停止-启动（重启）eth0网卡，则可以输入</p><p>#ifdown eth0</p><p>#ifup eth0</p><p><strong>提示：在实际工作的时候不要随意禁网卡。</strong></p><h1 id="四、ssh服务（重点）"><a href="#四、ssh服务（重点）" class="headerlink" title="四、ssh服务（重点）"></a>四、ssh服务（重点）</h1><p>ssh（secure shell，安全外壳协议），该协议有2个常用的作用：<strong>远程连接协议</strong>、远程文件传输协议。</p><p>协议使用<strong>端口</strong>号：默认是22</p><p>可以是被修改的，如果需要修改，则需要修改ssh服务的配置文件：</p><p>#/etc/ssh/ssh_config</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image40.png" alt="img"></p><p>端口号可以修改，但是得注意2个事项：</p><p>​    a. 注意范围，端口范围是从0-65535；</p><p>​    b. 不能使用别的服务已经占用的端口；</p><p><strong>服务启动/停止/重启</strong></p><p>#service sshd start/stop/restart</p><p>#/etc/init.d/sshd start/stop/restart</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image42.jpg" alt="img"></p><h2 id="1、远程终端"><a href="#1、远程终端" class="headerlink" title="1、远程终端"></a>1、远程终端</h2><p>终端工具主要帮助运维人员连接远程的服务器，常见终端工具有：Xshell、secureCRT、Putty等。以putty为例：</p><p>①获取服务器ip地址，可以通过ifconfig命令进行查看，然后顺手测试ip的连接相通性</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image43.png" alt="img"></p><p>②打开putty，输入相关的信息</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image44.png" alt="img"></p><p>③在弹出key确认的时候点击“是”，以后不会再提示</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image45.png" alt="img"></p><p>④输入登录信息</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image47.jpg" alt="img"></p><h2 id="2、SSH服务文件传输"><a href="#2、SSH服务文件传输" class="headerlink" title="2、SSH服务文件传输"></a>2、SSH服务文件传输</h2><p>可视化的界面传输工具：Filezilla</p><p>安装好之后可以查看到桌面图标：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image48.png" alt="img"></p><p>①选择“文件”- “站点管理器（Ctrl + S）”</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image50.jpg" alt="img"></p><p>②点击“文件”菜单下方的“▽”选择需要连接的服务器，连接好之后的效果</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image52.jpg" alt="img"></p><p>③从本地windows上传文件到linux中方式</p><p>支持直接拖拽文件，也可以右键本地需要上传的文件，然后点选“上传”即可</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image54.jpg" alt="img"></p><p>④下载linux文件到本地</p><p>支持服务器文件直接拖拽到本地，也可以在右侧窗口选择需要下载的文件，右键，点选“下载”。</p><p><strong>扩展3：通过命令行工具来传输文件/文件夹</strong></p><p>工具：PSCP.exe（必须通过cmd命令行打开），为了使用方便可以将其放到环境变量目录中</p><p>如果不清楚哪些路径是环境变量路径，只需要将其放到C:/Windows目录下即可。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image55.png" alt="img"></p><p>用法：</p><p>​    <strong>a. pscp</strong> <strong>选项</strong> <strong>用户名@linux主机地址:资源路径 windows本地的地址</strong> <strong>（下载到win）</strong></p><p>​    <strong>b. pscp</strong> <strong>选项</strong> <strong>资源路径</strong> <strong>用户名@linux主机地址:远程路径</strong>  <strong>（上传到linux）</strong></p><p>​    c. pscp 选项 -ls 用户名@linux主机地址 （列出远程路径下结构）</p><p>①下载到本地windows</p><p>要求将远程linux服务器下的/etc整个目录下载到本地E:\tmp下</p><p>#pscp -r <a href="mailto:root@192.168.21.128:/etc">root@192.168.21.128:/etc</a> E:\tmp</p><p>在CMD中输入之后输入密码</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image56.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image57.png" alt="img"></p><p>②上传文件到linux</p><p>将“E:\coursedocs\运维学科\北京运维01期\01-基础班\20180329_Linux自有服务”所有的内容传输到linux下root用户的家目录</p><p>#pscp -r “E:\coursedocs\运维学科\北京运维01期\01-基础班\20180329_Linux自有服务” <a href="mailto:root@192.168.21.128:/root">root@192.168.21.128:/root</a></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/slip_image59.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux自有服务（1）&quot;&gt;&lt;a href=&quot;#Linux自有服务（1）&quot; class=&quot;headerlink&quot; title=&quot;Linux自有服务（1）&quot;&gt;&lt;/a&gt;Linux自有服务（1）&lt;/h1&gt;&lt;p&gt;自有服务，即不需要用户独立去安装的软件的服务，而是当系统安装</summary>
      
    
    
    
    <category term="操作系统学习" scheme="https://roranrui.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="操作系统" scheme="https://roranrui.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>三.Linux高级指令</title>
    <link href="https://roranrui.cn/2022/04/26/san.linux-gao-ji-zhi-ling/"/>
    <id>https://roranrui.cn/2022/04/26/san.linux-gao-ji-zhi-ling/</id>
    <published>2022-04-26T07:29:43.000Z</published>
    <updated>2022-04-26T07:36:24.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux的基本指令（2）"><a href="#Linux的基本指令（2）" class="headerlink" title="Linux的基本指令（2）"></a>Linux的基本指令（2）</h1><h1 id="一、高级指令"><a href="#一、高级指令" class="headerlink" title="一、高级指令"></a>一、高级指令</h1><h2 id="1、hostname指令"><a href="#1、hostname指令" class="headerlink" title="1、hostname指令"></a>1、hostname指令</h2><p>作用：操作服务器的<strong>主机名</strong>（<strong>读取</strong>、设置）</p><p>语法1：#hostname            含义：表示输出完整的主机名</p><p><strong>语法2：#hostname -f</strong>             <strong>含义：表示输出当前主机名中的FQDN</strong>（全限定<strong>域名</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/QQ%E5%9B%BE%E7%89%8732131220220426153236.png" alt="img"></p><h2 id="2、id指令"><a href="#2、id指令" class="headerlink" title="2、id指令"></a>2、id指令</h2><p><strong>作用：查看一个用户的一些基本信息（包含用户id，用户组id，附加组id…），该指令如果不指定用户则默认当前用户。</strong></p><p>语法1：#id       默认显示当前执行该命令的用户的基本信息</p><p>语法2：#id 用户名       显示指定用户的基本信息</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/QQ%E5%9B%BE%E7%89%8720321312220426153317.png" alt="img"></p><p>验证上述信息是否正确？</p><p><strong>验证用户信息：通过文件/etc/passwd</strong></p><p><strong>验证用户组信息：通过文件/etc/group</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image004.png" alt="img"></p><h2 id="3、whoami指令"><a href="#3、whoami指令" class="headerlink" title="3、whoami指令"></a>3、whoami指令</h2><p><strong>作用：“我是谁？”显示当前登录的用户名，一般用于shell脚本，用于获取当前操作的用户名方便记录日志。</strong></p><p>语法：#whoami</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image05.png" alt="img"></p><h2 id="4、ps-ef指令（重点）"><a href="#4、ps-ef指令（重点）" class="headerlink" title="4、ps -ef指令（重点）"></a>4、ps -ef指令（重点）</h2><p>指令：ps </p><p>作用：主要是查看服务器的进程信息</p><p>选项含义：</p><p>​    -e：等价于“-A”，表示列出全部的进程</p><p>​    -f：显示全部的列（显示全字段）</p><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image007.jpg" alt="img"></p><p>列的含义：</p><p>UID：该进程执行的用户id；</p><p>PID：进程id；</p><p>PPID：该进程的父级进程id，如果一个程序的父级进程找不到，该程序的进程称之为僵尸进程（parent process ID）；</p><p>C：Cpu的占用率，其形式是百分数；</p><p>STIME：进行的启动时间；</p><p>TTY：终端设备，发起该进程的设备识别符号，如果显示“?”则表示该进程并不是由终端设备发起；</p><p>TIME：进程的执行时间；</p><p>CMD：该进程的名称或者对应的路径；</p><p>案例：（100%使用的命令）在ps的结果中过滤出想要查看的进程状态</p><p><strong>#ps -ef|grep “进程名称”</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/lip_image9.jpg" alt="img"></p><p>再例如查看火狐浏览器的进程：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/lip_image11.jpg" alt="img"></p><h2 id="5、top指令（重点）"><a href="#5、top指令（重点）" class="headerlink" title="5、top指令（重点）"></a>5、top指令（重点）</h2><p><strong>作用：查看服务器的进程占的资源（100%使用）</strong></p><p>语法：</p><p>​    进入命令：#top           （动态显示）</p><p>​    退出命令：按下q键</p><p>输出的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image013.jpg" alt="img"></p><p>表头含义：</p><p>PID：进程id；</p><p>USER：该进程对应的用户；</p><p>PR：优先级；</p><p>VIRT：虚拟内存；</p><p>RES：常驻内存；</p><p>SHR：共享内存；</p><p>​    计算一个进程实际使用的内存 = 常驻内存（RES）- 共享内存（SHR）</p><p>S：表示进程的状态status（sleeping，其中S表示睡眠，R表示运行）；</p><p>%CPU：表示CPU的占用百分比；</p><p>%MEM：表示内存的占用百分比；</p><p>TIME+：执行的时间；</p><p>COMMAND：进程的名称或者路径；</p><p><strong>在运行top的时候，可以按下方便的快捷键：</strong></p><p>M：表示将结果按照内存（MEM）从高到低进行降序排列；</p><p>P：表示将结果按照CPU使用率从高到低进行降序排列；</p><p>1：当服务器拥有多个cpu的时候可以使用“1”快捷键来切换是否展示显示各个cpu的详细信息；</p><h2 id="6、du-sh指令"><a href="#6、du-sh指令" class="headerlink" title="6、du -sh指令"></a>6、du -sh指令</h2><p>作用：查看目录的真实大小</p><p><strong>语法：#du -sh</strong> <strong>目录路径</strong></p><p>选项含义：</p><p>​    -s：summaries，只显示汇总的大小</p><p>​    -h：表示以高可读性的形式进行显示</p><p>案例：统计“/root/yunweihenniux”目录的实际大小</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/lip_image14.png" alt="img"></p><p>案例：统计“/etc”目录实际大小</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/lip_image15.png" alt="img"></p><h2 id="7、find指令"><a href="#7、find指令" class="headerlink" title="7、find指令"></a>7、find指令</h2><p>作用：用于查找文件（其参数有55个之多）</p><p>语法：#<strong>find</strong> <strong>路径范围</strong> <strong>选项</strong> <strong>选项的值</strong></p><p>选项：</p><p>​    -name：按照文档名称进行搜索（支持模糊搜索）</p><p>​    -type：按照文档的类型进行搜索</p><p>​         <strong>文档类型：“-”表示文件（在使用find的时候需要用f来替换），“d”表示文件夹</strong></p><p>案例：使用find来搜索httpd.conf</p><p>#find / -name httpd.conf</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/lip_image16.png" alt="img"></p><p>案例：搜索etc目录下所有的conf后缀文件</p><p>#find /etc -name *.conf</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/lip_image17.png" alt="img"></p><p>案例：使用find来搜索/etc/sane.d/目录下所有的<strong>文件</strong></p><p>#find /etc/sane.d/ -type f</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image018.png" alt="img"></p><p>案例：使用find来搜索/etc/目录下所有的<strong>文件夹</strong></p><p>#find /etc -type d</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/lip_image19.png" alt="img"></p><h2 id="8、service指令（重点）"><a href="#8、service指令（重点）" class="headerlink" title="8、service指令（重点）"></a>8、service指令（重点）</h2><p>作用：用于控制一些软件的服务启动/停止/重启</p><p><strong>语法：#service</strong> <strong>服务名 start/stop/restart</strong></p><p>例如：需要启动本机安装的Apache（网站服务器软件），其服务名httpd</p><p>#service httpd start</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/lip_image21.jpg" alt="img"></p><p>通过ps命令来检查httpd服务是否启动：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image023.jpg" alt="img"></p><h2 id="9、kill指令（重点）"><a href="#9、kill指令（重点）" class="headerlink" title="9、kill指令（重点）"></a>9、kill指令（重点）</h2><p><strong>作用：表示杀死进程</strong>      （当遇到僵尸进程或者出于某些原因需要关闭进程的时候）</p><p>语法：**#kill** <strong>进程PID</strong>      （语法需要配合ps一起使用）</p><p>案例：需要kill掉Apache的进程</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/lip_image25.jpg" alt="img"></p><p>与kill命令作用相似但是比kill更加好用的杀死进程的命令：killall</p><p>语法：**#killall** <strong>进程名称</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/lip_image26.png" alt="img"></p><h2 id="10、ifconfig指令（重点）"><a href="#10、ifconfig指令（重点）" class="headerlink" title="10、ifconfig指令（重点）"></a>10、ifconfig指令（重点）</h2><p><strong>作用：用于操作网卡相关的指令。</strong></p><p>简单语法：#ifconfig        （获取网卡信息）</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image028.jpg" alt="img"></p><p>Eth0表示Linux中的一个网卡，eth0是其名称。Lo（<strong>loop，本地回还网卡，其ip地址一般都是127.0.0.1</strong>）也是一个网卡名称。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/lip_image30.jpg" alt="img"></p><p><strong>注意：inet addr就是网卡的ip地址</strong>。</p><h2 id="11、reboot指令"><a href="#11、reboot指令" class="headerlink" title="11、reboot指令"></a>11、reboot指令</h2><p>作用：重新启动计算机         </p><p><strong>语法1：#reboot</strong>      <strong>重启</strong></p><p>语法2：#reboot  -w  模拟重启，但是不重启（只写关机与开机的日志信息）</p><h2 id="12、shutdown指令"><a href="#12、shutdown指令" class="headerlink" title="12、shutdown指令"></a>12、shutdown指令</h2><p>作用：关机           （慎用）</p><p><strong>语法1：#shutdown -h now “关机提示”</strong> <strong>或者  #shutdown -h 15:25 “关机提示”</strong></p><p>案例：设置Linux系统关机时间在12:00</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image032.jpg" alt="img"></p><p><strong>如果想要取消关机计划的话，则可以按照以下方式去尝试：</strong></p><p><strong>①针对于centos7.x之前的版本：ctrl+c</strong></p><p><strong>②针对于centos7.x（包含）之后的版本：#shutdown  -c</strong></p><p>除了shutdown关机以外，还有以下几个关机命令：</p><p>#init 0</p><p>#halt</p><p>#poweroff</p><h2 id="13、uptime指令"><a href="#13、uptime指令" class="headerlink" title="13、uptime指令"></a>13、uptime指令</h2><p>作用：输出计算机的持续在线时间（<strong>计算机从开机到现在运行的时间</strong>）</p><p><strong>语法：#uptime</strong></p><p><img src="C:/Users/13993/AppData/Local/Temp/msohtmlclip1/01/lip_image34.jpg" alt="img"></p><h2 id="14、uname指令"><a href="#14、uname指令" class="headerlink" title="14、uname指令"></a>14、uname指令</h2><p>作用：获取计算机操作系统相关信息</p><p>语法1：#uname           获取操作系统的类型</p><p><strong>语法2：#uname -a       all，表示获取全部的系统信息（类型、全部主机名、内核版本、发布时间、开源计划）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image036.jpg" alt="img"></p><h2 id="15、netstat-tnlp指令"><a href="#15、netstat-tnlp指令" class="headerlink" title="15、netstat -tnlp指令"></a>15、netstat -tnlp指令</h2><p>作用：查看网络连接状态</p><p>语法：#netstat -tnlp</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/lip_image38.jpg" alt="img"></p><p>选项说明：</p><p>​    -t：表示只列出tcp协议的连接；</p><p>​    -n：表示将地址从字母组合转化成ip地址，将协议转化成端口号来显示；</p><p>​    -l：表示过滤出“state（状态）”列中其值为LISTEN（监听）的连接；</p><p>​    -p：表示显示发起连接的进程pid和进程名称；</p><h2 id="16、man指令"><a href="#16、man指令" class="headerlink" title="16、man指令"></a>16、man指令</h2><p>作用：manual，手册（包含了Linux中全部命令手册，英文）</p><p>语法：#man 命令         （退出按下q键）</p><p>案例：通过man命令查询cp指令的用法</p><p>#man cp</p><h1 id="二、练习题"><a href="#二、练习题" class="headerlink" title="二、练习题"></a>二、练习题</h1><p>1、如何通过命令行重启linux操作系统？  #reboot</p><p>2、<strong>如何在命令行中快速删除光标前/后的内容？</strong>  <strong>前：ctrl + u</strong>  <strong>后：ctrl + k</strong></p><p>3、如何删除/tmp下所有A开头的文件？    #rm -f /tmp/A* </p><p>4、系统重要文件需要备份，如何把/etc/passwd备份到/tmp目录下？</p><p>   #cp /etc/passwd /tmp/</p><p>5、如何查看系统最后创建的3个用户？</p><p>   #tail -3 /etc/passwd</p><p>6、什么命令可以统计当前系统中一共有多少账户？</p><p>   #wc -l /etc/passwd    #cat /etc/passwd|wc -l</p><p>7、如何创建/tmp/test.conf文件？</p><p>   #touch /tmp/test.conf</p><p>8、如何通过vim编辑打开/tmp/test.conf?</p><p>   #vim /tmp/test.conf</p><p>9、如何查看/etc/passwd的头3行和尾3行？</p><p>   #head -3 /etc/passwd</p><p>   #tail -3 /etc/passwd</p><p>10、如何<strong>一次性</strong>创建目录/text/1/2/3/4？</p><p>   #mkdir -p /text/1/2/3/4</p><p>11、如何最快的返回到当前账户的家目录？</p><p>   #cd ~         #cd</p><p>12、如何查看/etc所占的磁盘空间？</p><p>   #du -sh /etc</p><p>13、如何删除/tmp下所有的文件？</p><p>   #rm -rf /tmp/*</p><p>14、尝试启动Apache的服务，并且检查是否启动成功。</p><p>   #service httpd start</p><p>   #ps -ef|grep httpd</p><p>15、使用已学命令杀死Apache的进程。</p><p>   #killall httpd</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux的基本指令（2）&quot;&gt;&lt;a href=&quot;#Linux的基本指令（2）&quot; class=&quot;headerlink&quot; title=&quot;Linux的基本指令（2）&quot;&gt;&lt;/a&gt;Linux的基本指令（2）&lt;/h1&gt;&lt;h1 id=&quot;一、高级指令&quot;&gt;&lt;a href=&quot;#一、高</summary>
      
    
    
    
    <category term="操作系统学习" scheme="https://roranrui.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="操作系统" scheme="https://roranrui.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>二.Linux的基本指令</title>
    <link href="https://roranrui.cn/2022/04/26/er.linux-de-ji-ben-zhi-ling/"/>
    <id>https://roranrui.cn/2022/04/26/er.linux-de-ji-ben-zhi-ling/</id>
    <published>2022-04-26T07:29:35.000Z</published>
    <updated>2022-04-26T12:12:59.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux的基本指令"><a href="#Linux的基本指令" class="headerlink" title="Linux的基本指令"></a>Linux的基本指令</h1><h1 id="一、指令与选项"><a href="#一、指令与选项" class="headerlink" title="一、指令与选项"></a>一、指令与选项</h1><p>什么是Linux的指令？</p><p>指在Linux终端（命令行）中输入的内容就称之为指令。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image001.png" alt="img"></p><p>一个完整的指令的标准格式：Linux通用的格式</p><p>#<strong>指令主体（空格） [选项]（空格） [操作对象]</strong></p><p>一个指令可以包含多个选项</p><p>操作对象也可以是多个</p><p>例如：需要让张三同学帮忙去楼下小卖铺买一瓶农夫山泉水和清风餐巾纸，在这个指令中“买东西”是指令的主体，买的水和餐巾纸是操作的对象，农夫山泉、清风是操作的选项。</p><h1 id="二、基础指令（重点）"><a href="#二、基础指令（重点）" class="headerlink" title="二、基础指令（重点）"></a>二、基础指令（重点）</h1><h2 id="1、ls指令"><a href="#1、ls指令" class="headerlink" title="1、ls指令"></a>1、ls指令</h2><p>含义：ls （list）</p><p><strong>用法1：#ls</strong></p><p>含义：列出当前工作目录下的所有文件/文件夹的名称</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image003.jpg" alt="img"></p><p><strong>用法2：#ls 路径</strong></p><p>含义：列出指定路径下的所有文件/文件夹的名称</p><p>关于路径（重要）：</p><p>路径可以分为两种：相对路径、绝对路径。</p><p>相对路径：相对首先得有一个参照物（一般就是当前的工作路径）；</p><p>​    相对路径的写法：在相对路径中通常会用到2个符号“./”【表示当前目录下】、“../”【上一级目录下】。</p><p>绝对路径：绝对路径不需要参照物，直接从根“/”开始寻找对应路径；</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image0004.png" alt="img"></p><p><strong>用法3：#ls 选项 路径</strong></p><p>含义：在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示。</p><p>常见的语法：</p><p>​    #ls -l 路径</p><p>​    #ls -la 路径</p><p>选项解释：</p><p>​    <strong>-l：表示list，表示以详细列表的形式进行展示</strong></p><p>​    <strong>-a：表示显示所有的文件/文件夹（包含了隐藏文件/文件夹）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image005.png" alt="img"></p><p>上述列表中的第一列字符表示文档的类型，<strong>其中“-”表示改行对应的文档类型为文件，“d”表示文档类型为文件夹</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image0006.png" alt="img"></p><p><strong>在Linux中隐藏文档一般都是以“.”开头。</strong></p><p><strong>用法4：#ls -lh路径</strong></p><p>含义：列出指定路径下的所有文件/文件夹的名称，以列表的形式并且在显示文档大小的时候以<strong>可读性较高的形式显示</strong></p><p>参数含义：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image007.png" alt="img"></p><h2 id="2、pwd指令"><a href="#2、pwd指令" class="headerlink" title="2、pwd指令"></a>2、pwd指令</h2><p><strong>用法：#pwd      （print working directory，打印当前工作目录）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image008.png" alt="img"></p><h2 id="3、cd指令"><a href="#3、cd指令" class="headerlink" title="3、cd指令"></a>3、cd指令</h2><p>命令：#cd        （change directory，改变目录）</p><p>作用：用于切换当前的工作目录的</p><p><strong>语法：#cd 路径</strong></p><p>案例：当前在“/”下，需要使用绝对路径切换到/usr/local。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image009.jpg" alt="img"></p><p>案例：当前在/usr/local下，需要使用相对路径切换目录到home目录下的Linux123用户家目录中去。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image010.png" alt="img"></p><p>补充：</p><p>在Linux中有一个特殊的符号“~”，表示当前用户的家目录。</p><p>切换的方式：#cd ~</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image011.png" alt="img"></p><h2 id="4、mkdir指令"><a href="#4、mkdir指令" class="headerlink" title="4、mkdir指令"></a>4、mkdir指令</h2><p>指令：mkdir  （make directory，创建目录）</p><p>语法1：**#mkdir** <strong>路径</strong> <strong>【路径，可以是文件夹名称也可以是包含名称的一个完整路径】</strong></p><p>案例：在当前路径下创建出目录“yunweihenniux”</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image012.png" alt="img"></p><p>注意：ls列出的结果颜色说明，<strong>其中蓝色的名称表示文件夹</strong>，黑色的表示文件，<strong>绿色的其权限为拥有所有权限</strong>。</p><p>案例：在指定路径下创建出一个文件夹“yunweihenniux”</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image013.png" alt="img"></p><p>语法2：**#mkdir -p** <strong>路径</strong></p><p>含义：<strong>当一次性创建多层不存在的目录的时候</strong>，添加-p参数，否则会报错</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image015.jpg" alt="img"></p><p>语法3：**#mkdir** <strong>路径1</strong> <strong>路径2</strong> <strong>路径3 ….</strong>  【表示一次性创建多个目录】</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image017.png" alt="img"></p><h2 id="5、touch指令"><a href="#5、touch指令" class="headerlink" title="5、touch指令"></a>5、touch指令</h2><p>指令：touch  </p><p>作用：创建文件</p><p>语法：**#touch 文件路径**   【路径可以是直接的文件名也可以是路径】</p><p>案例：使用touch来在当前路径下创建一个文件，命名为Linux.txt</p><p><img src="C:/Users/13993/AppData/Local/Temp/msohtmlclip1/01/clip_image019.jpg" alt="img"></p><p>案例：使用touch来同时创建多个文件</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image021.jpg" alt="img"></p><p>案例：使用touch来在“Linux123”用户的家目录中创建文件，Linux.txt</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image022.png" alt="img"></p><h2 id="6、cp指令"><a href="#6、cp指令" class="headerlink" title="6、cp指令"></a>6、cp指令</h2><p>指令：cp     （copy，复制）</p><p>作用：复制文件/文件夹到指定的位置</p><p>语法：**#cp** <strong>被复制的文档路径</strong> <strong>文档被复制到的路径</strong></p><p>案例：使用cp命令来复制一个文件</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image023.png" alt="img"></p><p><strong>注意：Linux在复制过程中是可以重新对新位置的文件进行重命名的，但是如果不是必须的需要，则建议保持前后名称一致。</strong></p><p>案例：使用cp命令来复制一个文件夹</p><p><strong>注意：当使用cp命令进行文件夹复制操作的时候需要添加选项“-r”【-r表示递归复制】，否则目录将被忽略</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image025.jpg" alt="img"></p><h2 id="7、mv指令"><a href="#7、mv指令" class="headerlink" title="7、mv指令"></a>7、mv指令</h2><p>指令：mv  （move，移动，剪切）</p><p>作用：移动文档到新的位置</p><p>语法：**#mv** <strong>需要移动的文档路径</strong> <strong>需要保存的位置路径</strong></p><p>确认：移动之后原始的文件还在不在原来的位置？原始文件是不在原始位置的</p><p>案例：使用mv命令移动一个文件</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image026.png" alt="img"></p><p>案例：使用mv命令移动一个文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image027.png" alt="img"></p><p>补充：在Linux中重命名的命令也是mv，语法和移动语法一样。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image0028.jpg" alt="img"></p><h2 id="8、rm指令"><a href="#8、rm指令" class="headerlink" title="8、rm指令"></a>8、rm指令</h2><p>指令：rm （remove，移除、删除）</p><p>作用：移除/删除文档</p><p>语法：#rm 选项 需要移除的文档路径</p><p>选项：</p><p>​    -f：force，强制删除，不提示是否删除</p><p>​    -r：表示递归</p><p>案例：删除一个文件</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image029.png" alt="img"></p><p>在删除的时候如果不带选项，会提示是否删除，如果需要确认则输入“y/yes”，否则输入“n/no”按下回车。</p><p><strong>注意：如果在删除的时候不想频繁的确认，则可以在指令中添加选项“-f”，表示force（强制）。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image031.png" alt="img"></p><p>案例：删除一个文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image032.png" alt="img"></p><p><strong>注意：删除一个目录的时候需要做递归删除，并且一般也不需要进行删除确认询问，所以移除目录的时候一般需要使用-rf选项。</strong></p><p>案例：删除多个文档</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image033.png" alt="img"></p><p>案例：要删除一个目录下有公共特性的文档，例如都以Linux开头</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image035.jpg" alt="img"></p><p>其中** *称之为通配符，意思表示任意的字符，Linux*，则表示只要文件以Linux开头，后续字符则不管**。</p><h2 id="9、vim指令"><a href="#9、vim指令" class="headerlink" title="9、vim指令"></a>9、vim指令</h2><p>指令：vim  （vim是一款文本编辑器）</p><p>语法：**#vim** <strong>文件的路径</strong></p><p>作用：打开一个文件（可以不存在，也可以存在）</p><p>案例：使用vim来打开文件</p><p>退出打开的文件：在没有按下其他命令的时候，按下shift+英文冒号，输入q，按下回车即可</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image0036.jpg" alt="img"></p><h2 id="10、输出重定向"><a href="#10、输出重定向" class="headerlink" title="10、输出重定向"></a>10、输出重定向</h2><p><strong>一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析/统计，则这时候需要使用到的输出重定向技术。</strong></p><p>&gt;：覆盖输出，会覆盖掉原先的文件内容</p><p>&gt;&gt;：追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加</p><p><strong>语法：#正常执行的指令 &gt; / &gt;&gt;</strong> <strong>文件的路径</strong></p><p>注意：文件可以不存在，不存在则新建</p><p>案例：使用覆盖重定向，保存ls -la 的执行结果，保存到当前目录下的ls.txt</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image0037.png" alt="img"></p><p>案例：使用追加重定向，保存ls -la的执行结果到ls.txt中</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image038.png" alt="img"></p><h2 id="11、cat指令"><a href="#11、cat指令" class="headerlink" title="11、cat指令"></a>11、cat指令</h2><p><strong>作用1：cat有直接打开一个文件的功能。</strong></p><p><strong>语法1：#cat</strong> <strong>文件的路径</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image039.png" alt="img"></p><p><strong>作用2：cat还可以对文件进行合并</strong></p><p><strong>语法2：#cat</strong> <strong>待合并的文件路径1</strong> <strong>待合并的文件路径2 ….</strong> <strong>文件路径n &gt;</strong> <strong>合并之后的文件路径</strong></p><p>例如，合并3个文件，并存到一个文件中【配合输出重定向使用】</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image041.jpg" alt="img"></p><h1 id="三、进阶指令（重点）"><a href="#三、进阶指令（重点）" class="headerlink" title="三、进阶指令（重点）"></a>三、进阶指令（重点）</h1><h2 id="1、df指令"><a href="#1、df指令" class="headerlink" title="1、df指令"></a>1、df指令</h2><p>作用：查看磁盘的空间</p><p><strong>语法：#df -h      -h表示以可读性较高的形式展示大小</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20220426150013.png" alt="img"></p><h2 id="2、free指令"><a href="#2、free指令" class="headerlink" title="2、free指令"></a>2、free指令</h2><p>作用：查看内存使用情况</p><p><strong>语法：#free -m  -m表示以mb为单位查看</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image045.jpg" alt="img"></p><p>剩余的真实可以用的内存为1665mb。</p><p>Swap：用于临时内存，当系统真实内存不够用的时候可以临时使用磁盘空间来充当内存。</p><h2 id="3、head指令"><a href="#3、head指令" class="headerlink" title="3、head指令"></a>3、head指令</h2><p>作用：查看一个文件的前n行，如果不指定n，则默认显示前10行。</p><p><strong>语法：#head -n</strong> <strong>文件路径</strong>  <strong>【n表示数字】</strong></p><p><img src="C:/Users/13993/AppData/Local/Temp/msohtmlclip1/01/clip_image047.jpg" alt="img"></p><h2 id="4、tail指令"><a href="#4、tail指令" class="headerlink" title="4、tail指令"></a>4、tail指令</h2><p>作用1：查看一个文件的未n行，如果n不指定默认显示后10行</p><p><strong>语法：#tail -n</strong> <strong>文件的路径   n同样表示数字</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/QQ%E5%9B%BE%E7%89%8720220426150122.png" alt="img"></p><p>作用2：可以通过tail指令来查看一个文件的动态变化内容【<strong>变化的内容不能是用户手动增加的</strong>】</p><p><strong>语法：#tail -f</strong> <strong>文件路径</strong></p><p><strong>该命令一般用于查看系统的日志比较多。</strong></p><h2 id="5、less指令"><a href="#5、less指令" class="headerlink" title="5、less指令"></a>5、less指令</h2><p>作用：查看文件，以较少的内容进行输出，按下辅助功能键（数字+回车、<strong>空格键</strong>+上下方向键）查看更多</p><p><strong>语法：#less</strong> <strong>需要查看的文件路径</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image050.jpg" alt="img"></p><p>在退出的只需要按下q键即可。</p><h2 id="6、wc指令"><a href="#6、wc指令" class="headerlink" title="6、wc指令"></a>6、wc指令</h2><p>作用：统计文件内容信息（包含行数、单词数、字节数）</p><p>语法：**#wc -lwc** <strong>需要统计的文件路径</strong></p><p>​    <strong>-l：表示lines，行数</strong></p><p>​    -w：表示words，单词数  依照空格来判断单词数量</p><p>​    -c：表示bytes，字节数</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/QQ%E5%9B%BE%E7%89%8720220426150201.png" alt="img"></p><h2 id="7、date指令（重点）"><a href="#7、date指令（重点）" class="headerlink" title="7、date指令（重点）"></a>7、date指令（重点）</h2><p>作用：表示操作时间日期（<strong>读取</strong>、设置）</p><p>语法1：#date             输出的形式：2018年 3月 24日 星期六 15:54:28</p><p>语法2：**#date  +%F**   <strong>（等价于#date  “+%Y-%m-%d”</strong> <strong>）</strong>   输出形式：2018-03-24</p><p>语法3：#date “+%F %T”  引号表示让“年月日与时分秒”成为一个不可分割的整体</p><p>​    <strong>等价操作#date “+%Y-%m-%d %H:%M:%S”</strong></p><p>输出的形式：2018-03-24 16:01:00</p><p>语法4：获取之前或者之后的某个时间（备份）</p><p>#date -d  “**-**1 <strong>day</strong>” “+%Y-%m-%d %H:%M:%S”</p><p>符号的可选值：+（之后） 或者 - （之前）</p><p>单位的可选值：day（天）、month（月份）、year（年）</p><p>%F：表示完整的年月日</p><p>%T：表示完整的时分秒</p><p>%Y：表示四位年份</p><p>%m：表示两位月份（带前导0）</p><p>%d：表示日期（带前导0）</p><p>%H：表示小时（带前导0）</p><p>%M：表示分钟（带前导0）</p><p>%S：表示秒数（带前导0）</p><h2 id="8、cal指令"><a href="#8、cal指令" class="headerlink" title="8、cal指令"></a>8、cal指令</h2><p><strong>作用：用来操作日历的</strong></p><p><strong>语法1：#cal 等价于 #cal -1</strong>    直接输出当前月份的日历</p><p><strong>语法2：#cal -3</strong>          表示输出上一个月+本月+下个月的日历</p><p><strong>语法3：#cal -y</strong> <strong>年份</strong>         表示输出某一个年份的日历</p><h2 id="9、clear-x2F-ctrl-L指令"><a href="#9、clear-x2F-ctrl-L指令" class="headerlink" title="9、clear/ctrl + L指令"></a>9、clear/ctrl + L指令</h2><p>作用：清除终端中已经存在的命令和结果（信息）。</p><p><strong>语法：clear</strong>      <strong>或者快捷键：ctrl + L</strong></p><p>需要注意的是，该命令并不是真的清除了之前的信息，而是把之前的信息的隐藏到了最上面，通过滚动条继续查看以前的信息。</p><h2 id="10、管道（重要）"><a href="#10、管道（重要）" class="headerlink" title="10、管道（重要）"></a>10、管道（重要）</h2><p><strong>管道符：|</strong></p><p>作用：管道一般可以用于“<strong>过滤</strong>”，“特殊”，“扩展处理”。</p><p>语法：管道不能单独使用，必须需要配合前面所讲的一些指令来一起使用，其作用<strong>主要是辅助作用</strong>。</p><p><strong>①过滤案例（100%使用</strong>）：需要通过管道查询出根目录下包含“y”字母的文档名称。</p><p>#ls / | grep y</p><p>针对上面这个命令说明：</p><p>①以管道作为分界线，前面的命令有个输出，后面需要先输入，然后再过滤，最后再输出，通俗的讲就是管道前面的输出就是后面指令的输入；</p><p>②grep指令：主要用于过滤</p><p>②特殊用法案例：通过管道的操作方法来实现less的等价效果（了解）</p><p>之前通过less查看一个文件，可以#less 路径</p><p>现在通过管道还可以这么：#cat 路径|less</p><p>③扩展处理：请使用学过的命令，来统计某个目录下的文档的总个数？</p><p><strong>答：#ls / | wc -l</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux的基本指令&quot;&gt;&lt;a href=&quot;#Linux的基本指令&quot; class=&quot;headerlink&quot; title=&quot;Linux的基本指令&quot;&gt;&lt;/a&gt;Linux的基本指令&lt;/h1&gt;&lt;h1 id=&quot;一、指令与选项&quot;&gt;&lt;a href=&quot;#一、指令与选项&quot; class</summary>
      
    
    
    
    <category term="操作系统学习" scheme="https://roranrui.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="操作系统" scheme="https://roranrui.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>一.Linux介绍</title>
    <link href="https://roranrui.cn/2022/04/26/yi.linux-jie-shao/"/>
    <id>https://roranrui.cn/2022/04/26/yi.linux-jie-shao/</id>
    <published>2022-04-26T07:29:30.000Z</published>
    <updated>2022-04-30T09:36:16.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Linux发展史"><a href="#一、Linux发展史" class="headerlink" title="一、Linux发展史"></a>一、Linux发展史</h1><h2 id="1、Linux前身-Unix"><a href="#1、Linux前身-Unix" class="headerlink" title="1、Linux前身-Unix"></a>1、Linux前身-Unix</h2><p>1968年 Multics项目</p><p><strong>MIT</strong>、<strong>Bell</strong>实验室、<strong>美国通用电气有限公司</strong>走到了一起，致力于开发Multics项目。到后期由于开发进度不是很好，MIT和Bell实验室相继离开这个项目的开发，最终导致项目搁浅。</p><p><strong>1970年（Unix元年，时间戳）</strong> Unix诞生</p><p>当时在开发Multics项目的时候，实验室中有一个开发成员开发了一款游戏（travel space：遨游太空），因为两个实验室相继离开项目开发，导致这名开发人员没法玩游戏，后来他提议组织人员重新在Multics项目之上重新的开发，也就出现了1970年的Unix。当时Unix操作系统是使用的<strong>汇编语言（机器语言）</strong>开发的。</p><p>1973年 用<strong>C</strong>语言**重写Unix</p><p>因为汇编语言有一个最大的局限性：对于计算机硬件过于依赖。导致移植性不好，所以后期在1973年使用了C语言对其进行重新开发。</p><p>1975年 Bell实验室允许大学使用Unix。</p><p>1975年，bell实验室允许大学使用Unix操作系统用于教学作用，而不允许用于商业用途。</p><h2 id="2、Linux诞生"><a href="#2、Linux诞生" class="headerlink" title="2、Linux诞生"></a>2、Linux诞生</h2><p>人物 Linus</p><p>Linux的开发作者，Linux之父，李纳斯·托瓦兹。Linux诞生时是荷兰在校大学生。</p><p>Linux的开发作者，Linux之父，李纳斯·托瓦兹。Linux诞生时是荷兰在校大学生。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/e21312321%20.png" alt="img"></p><p>1991年 0.0.1版本</p><p>​李纳斯当时学校使用的就是Unix操作系统，然后其对系统的底层代码进行了修改，放到了学校为学生开放的网站上，原先他把文件命名写成了Linus’s Unix，后期网络管理发现之后觉得这个名字不好，自己手动的将名字改成Linux。随后其他同学下载之后发现这个版本还是挺好用的，随后都把自己代码贡献给李纳斯。</p><p>1992年 0.0.2版本</p><p>1994年 1.0版本</p><p>2003年 2.6版本</p><p><strong>上述所提及的版本号并不是分支版本，而是指Linux的内核版本。</strong></p><h2 id="3、开源文化"><a href="#3、开源文化" class="headerlink" title="3、开源文化"></a>3、开源文化</h2><p>Linux是<strong>开源</strong>的操作系统。所谓开源就是指开放源代码。</p><p>人 物 Stallman 斯特曼，开源文化的倡导人。</p><p><strong>1983<strong><strong>年 GNU</strong></strong>计划</strong></p><p>1985年 FSF基金会</p><p>1990年 Emacs、<strong>GCC</strong>（c语言的编译器）、程序库 </p><p>1991年   Stallman去找Linus，商谈让Linux加入其开源计划（GNU计划）</p><p>1992年 GNU/Linux</p><h2 id="4、Linux系统特点"><a href="#4、Linux系统特点" class="headerlink" title="4、Linux系统特点"></a>4、Linux系统特点</h2><p>开放性（开源）、多用户、多任务、良好的用户界面、优异的性能与稳定性</p><p>多用户多任务：</p><p>单用户：一个用户，在登录计算机（操作系统），只能允许<strong>同时</strong>登录一个用户；</p><p>单任务：一个任务，允许用户<strong>同时</strong>进行的操作任务数量；</p><p>多用户：多个用户，在登录计算机（操作系统），允许<strong>同时</strong>登录多个用户进行操作；</p><p>多任务：多个任务，允许用户<strong>同时</strong>进行多个操作任务；</p><p><strong>Windows属于：单用户、多任务。</strong></p><p><strong>Linux属于：多用户、多任务。</strong></p><h2 id="5、Linux分支"><a href="#5、Linux分支" class="headerlink" title="5、Linux分支"></a>5、Linux分支</h2><p>分支：Linux分支有很多，现在比较有名的<strong>ubuntu</strong>、debian、<strong>centos</strong>（Community Enterprise Operating System）、redhat、suse等等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Linux发展史&quot;&gt;&lt;a href=&quot;#一、Linux发展史&quot; class=&quot;headerlink&quot; title=&quot;一、Linux发展史&quot;&gt;&lt;/a&gt;一、Linux发展史&lt;/h1&gt;&lt;h2 id=&quot;1、Linux前身-Unix&quot;&gt;&lt;a href=&quot;#1、Linux</summary>
      
    
    
    
    <category term="操作系统学习" scheme="https://roranrui.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="操作系统" scheme="https://roranrui.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
