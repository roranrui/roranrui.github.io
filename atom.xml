<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>若然无亦的Blog</title>
  
  <subtitle>长日终有时, 长梦终有逝</subtitle>
  <link href="https://roranrui.cn/atom.xml" rel="self"/>
  
  <link href="https://roranrui.cn/"/>
  <updated>2022-05-04T14:03:20.059Z</updated>
  <id>https://roranrui.cn/</id>
  
  <author>
    <name>若然无亦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>视频拍摄频闪解决方案</title>
    <link href="https://roranrui.cn/2022/05/04/shi-pin-pai-she-pin-shan-jie-jue-fang-an/"/>
    <id>https://roranrui.cn/2022/05/04/shi-pin-pai-she-pin-shan-jie-jue-fang-an/</id>
    <published>2022-05-04T13:58:06.000Z</published>
    <updated>2022-05-04T14:03:20.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="视频频闪的快速解决方案"><a href="#视频频闪的快速解决方案" class="headerlink" title="视频频闪的快速解决方案"></a>视频频闪的快速解决方案</h1><blockquote><p>  文章转载自: <a href="https://extremeer.github.io/media/frame_rate_and_strobe/">Extremeer 极振科技传媒工作室</a></p><p>  作者: Marzzz 已授权</p></blockquote><hr><blockquote><p>  在拍摄视频时，有时镜头前的灯光或屏幕录制下来后会有相应频闪，灯光忽明忽暗。频闪与帧率、快门速度、用电频率的关系息息相关。本文所指频闪只是由于交流电频率导致的频闪，LED与屏幕刷新率等频闪不在此考虑范畴内。</p></blockquote><h2 id="1-小白方案"><a href="#1-小白方案" class="headerlink" title="1. 小白方案"></a>1. 小白方案</h2><p>对于不想深入了解的同学，可以直接套用下列方案来规避大部分频闪。</p><table><thead><tr><th>所在地区</th><th>设置帧率</th><th>快门速度（可选）</th></tr></thead><tbody><tr><td>中国及欧亚的大多数地区</td><td>25fps；50fps</td><td>1/50；1/100</td></tr><tr><td>北美、日本、韩国等地区</td><td>30fps；60fps</td><td>1/60；1/120</td></tr></tbody></table><hr><h2 id="2-高阶方案"><a href="#2-高阶方案" class="headerlink" title="2. 高阶方案"></a>2. 高阶方案</h2><h3 id="①-用电频率"><a href="#①-用电频率" class="headerlink" title="① 用电频率"></a>① 用电频率</h3><p>交流电的频率和性质决定了灯光会一明一暗的进行交变脉冲，Hz表示每秒交变几次。交流电频率50Hz，周期0.02s，在电流整流后电路将后半个周期电流反向，从而使灯光脉冲频率为100Hz，周期为0.01s。</p><p>不同地区的用电频率是不一样的，这也导致出现了不同的视频制式来适应不同的频率。</p><p>地区用电频率视频制式常见帧率<br>欧洲和亚洲的大多数地区50HzPAL25fps; 50fps<br>北美、日本、韩国等地区60HzNTSC30fps; 60fps<br>在人眼前这种脉冲闪烁也许非常微小甚至完全无法感受到，但对于手机及相机来说有时设置不当这种脉冲就会十分明显。</p><h3 id="②-帧率（FPS）"><a href="#②-帧率（FPS）" class="headerlink" title="② 帧率（FPS）"></a>② 帧率（FPS）</h3><p>帧率，用于测量显示帧数的量度。FPS（Frames Per Second）指每秒拍摄的帧数。一般说，帧率影响画面流畅度，帧率越大，画面越流畅；帧率越小，画面越有跳动感。</p><p>当快门速度一定且与光闪烁频率无整除关系时：</p><p>帧率与光闪烁频率若有倍数关系，每一帧的起始采样点就相同，那么在相同快门的情况下每一帧的亮度就相同。</p><p>红色面积的横轴代表快门速度，红色面积代表每一帧的进光量<br>数字位置代表每一帧的开始，两个数字的间隔代表每一帧<br>可以看到每一帧的亮度是相同的<br>反之，帧率与光闪烁频率若无倍数关系，每一帧的起始采样点就不同，每一帧的亮度就不同而造成频闪。</p><p>红色面积的横轴代表快门速度，红色面积代表每一帧的进光量<br>数字位置代表每一帧的开始，两个数字的间隔代表每一帧<br>可以看到每一帧的亮度是不同的<br>而在规避频闪的方法中，匹配帧率通常是最简单的。</p><p>帧率方案：设置帧率，让光源闪烁频率被这个帧率整除。</p><p>假设在中国PAL制式下拍摄视频，因为用电频率是50Hz，光闪烁频率为100Hz，则大多数时候只需要设置25或者50fps，就能在多数情况下避免频闪。</p><p>如果在如北美NTSC制式下拍摄视频，就相应选择30或者60fps。</p><h3 id="③-快门速度（不推荐）"><a href="#③-快门速度（不推荐）" class="headerlink" title="③ 快门速度（不推荐）"></a>③ 快门速度（不推荐）</h3><p>快门速度，指的是相机快门进行一次开启到闭合的时间。</p><p>当帧率一定且与光闪烁频率无整除关系时：</p><p>若快门速度与光闪烁频率有倍数关系，那么每一帧曝光的时候进光量就会固定等于一周期的量从而稳定无频闪。</p><p>红色面积的横轴代表快门速度，红色面积代表每一帧的进光量<br>数字位置代表每一帧的开始，两个数字的间隔代表每一帧<br>可以看到每一帧的亮度是相同的<br>反之，若快门速度与光闪烁频率无倍数关系，那么每一帧曝光的时候进光量就会受光闪烁的不同时刻影响导致每一帧亮度不同从而造成频闪。</p><p>红色面积的横轴代表快门速度，红色面积代表每一帧的进光量<br>数字位置代表每一帧的开始，两个数字的间隔代表每一帧<br>可以看到每一帧的亮度是不同的<br>快门方案：设置快门速度，让光源闪烁频率被这个快门速度整除。</p><p>如：中国供电频率50Hz，光闪烁频率为100Hz，将快门速度设定为1/50或1/100即可解决。</p><p>这个选项通常不好确定。在调整快门速度的同时，你也要避免慢速快门而导致运动模糊的产生。</p><h3 id="④-帧率与快门速度的混合运用"><a href="#④-帧率与快门速度的混合运用" class="headerlink" title="④ 帧率与快门速度的混合运用"></a>④ 帧率与快门速度的混合运用</h3><p>通常，在中国使用PAL制（即fps调整到25或50），无论多少快门速度都不会产生频闪。原因是相机的采样间隔是和灯光的周期是同步的，例如50帧的时候采样周期是20ms，是灯光周期10ms的整数倍，在每一个周期内，采样的起始点是一样的。所以无论多少快门速度，每一帧的亮度都是相同的。</p><p>而在中国使用NTSC制（即fps调整到30或60），假如视频帧率为60帧，意味着每次采样的时间点是在这个周期中的不同地方，这时只有快门速度等于光闪频率的倍数的时候才不会有频闪。</p><p>实际上，以部分索尼相机为例，在人造光源下，索尼相机的快门速度最高到1/100，如果超过1/100，如1/2500，虽然也是50Hz的整数倍，但在NTSC制下，仍然会出现频闪，甚至1/125都会。</p><p>PAL制下也并不能为所欲为，过高的快门速度，画面上会出现不明显的明暗条带，从上至下规律移动，且随着快门升高，画面上会出现细小的横纹。</p><hr><h2 id="3-插件方案"><a href="#3-插件方案" class="headerlink" title="3.插件方案"></a>3.插件方案</h2><p>如果素材已经拍摄，则可以使用相关插件进行后期补救。</p><p>如果使用Adobe Premiere Pro或Adobe After Effects，则可以使用插件DEFlicker进行消除。（需要下载）。<br>如果使用达芬奇Davinci Resolve在版本14以上可以使用自带效果去闪烁。<br><strong>但请注意一切后期都不如前期做好准备。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;视频频闪的快速解决方案&quot;&gt;&lt;a href=&quot;#视频频闪的快速解决方案&quot; class=&quot;headerlink&quot; title=&quot;视频频闪的快速解决方案&quot;&gt;&lt;/a&gt;视频频闪的快速解决方案&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  文章转载自: &lt;a href=&quot;htt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第十一天_双指针(简单)</title>
    <link href="https://roranrui.cn/2022/05/04/shua-ti-bi-ji-shi-yi/"/>
    <id>https://roranrui.cn/2022/05/04/shua-ti-bi-ji-shi-yi/</id>
    <published>2022-05-04T09:56:45.000Z</published>
    <updated>2022-05-04T10:25:48.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一天-双指针-简单"><a href="#第十一天-双指针-简单" class="headerlink" title="第十一天_双指针(简单)"></a>第十一天_双指针(简单)</h1><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><p>严格的来说，双指针只能说是是算法中的一种技巧。</p><blockquote><p>  双指针指的是在<a href="https://so.csdn.net/so/search?q=%E9%81%8D%E5%8E%86&amp;spm=1001.2101.3001.7020">遍历</a>对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（<strong>快慢指针</strong>）或者相反方向（<strong>对撞指针</strong>）的指针进行扫描，从而达到相应的目的。</p></blockquote><h3 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h3><p><strong>对撞指针</strong>是指在数组中，将指向最左侧的索引定义为<code>左指针（left）</code>，最右侧的定义为<code>右指针（right）</code>，然后从两头向中间进行数组遍历。快速排序就是典型的双指针问题。</p><p>我们假设数组名字为 nums，数组长度为 n，数组首元素对应的位置为 0。</p><p><strong>细节:</strong></p><ul><li>指针初始位置<ul><li>左指针（left)一般指向数组的第一个元素。即 left = 0。</li><li>右指针（right)一般指向数组的第一个元素。即 right = n-1。</li></ul></li></ul><p>​</p><ul><li><p><strong>指针移动方法</strong></p><ul><li>左指针(left）向右边👉移动，一般每次移动一个位置，即 left++。</li><li>右指针(right）向左边👈移动，一般每次移动一个位置，即 right–。</li></ul></li><li><p><strong>结束条件</strong></p><ul><li>左指针（left）位置和右指针（right）位置逆序。</li></ul></li></ul><p>从上面的描述可知，开始的时候，right &gt;= left。因此结束的条件就是 right &lt; left。</p><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>快慢指针是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如快指针（fast）每次增长两个，慢指针（slow）每次增长一个。</p><p>一般来说，快慢指针常用于判断链表等数据结构中是否有环。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/aHR0cHM6Ly9hc3NldHMubGVldGNvZGUtY24uY29tL2FsaXl1bi1sYy11cGxvYWQvdXBsb2Fkcy8yMDE4LzEyLzA3L2NpcmN1bGFybGlua2VkbGlzdC5wbmc" alt="img"></p><p><strong>细节</strong>:</p><ul><li><p>指针初始位置</p><ul><li>慢指针（slow）一般指向数组的第一个元素。即 slow = 0。</li><li>快指针（fast）一般指向数组的第一个元素。即 fast = 1。</li></ul></li><li><p>指针移动方法</p><ul><li><p>慢指针（slow）向右边👉移动，一般每次移动一个位置，即 slow++。</p></li><li><p>快指针（fast）向右边👉移动，一般每次移动两个个位置，即 fast += 2。</p></li></ul></li><li><p>结束条件</p><ul><li>慢指针（slow）位置和快指针（fast）位置重合；快指针（fast）达到数组的最后一个元素。</li></ul></li></ul><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-删除链表的节点"><a href="#1-删除链表的节点" class="headerlink" title="1. 删除链表的节点"></a>1. 删除链表的节点</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504180845519.png" alt="image-20220504180845519"></p><p><strong>解题思路:</strong></p><p>本题删除值为 val 的节点分需为两步：定位节点、修改引用。</p><p>定位节点： 遍历链表，直到 head.val == val 时跳出，即可定位目标节点。<br>修改引用： 设节点 cur 的前驱节点为 pre ，后继节点为 cur.next ；则执行 pre.next = cur.next ，即可实现删除 cur 节点。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/1613757478-NBOvjn-Picture1.png" alt="Picture1.png"></p><blockquote><p>  算法流程：<br>  特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。<br>  初始化： pre = head , cur = head.next 。<br>  定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。<br>  保存当前节点索引，即 pre = cur 。<br>  遍历下一节点，即 cur = cur.next 。<br>  删除节点： 若 cur 指向某节点，则执行 pre.next = cur.next ；若 cur 指向 null ，代表链表中不包含值为 val 的节点。<br>  返回值： 返回链表头部节点 head 即可。</p></blockquote><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>pre <span class="token operator">=</span> head<span class="token punctuation">,</span> <span class="token operator">*</span>cur <span class="token operator">=</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">==</span> val<span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> cur<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">!=</span> val<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> pre<span class="token operator">-</span><span class="token operator">></span>next <span class="token operator">=</span> cur<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504181829187.png" alt="image-20220504181829187"></p><hr><h3 id="2-链表中倒数第-k-个节点"><a href="#2-链表中倒数第-k-个节点" class="headerlink" title="2. 链表中倒数第 k 个节点"></a>2. 链表中倒数第 k 个节点</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504181656331.png" alt="image-20220504181656331"></p><p><strong>解题思路：</strong></p><p>先遍历统计链表长度，记为 n ；<br>设置一个指针走 (n-k)步，即可找到链表倒数第 k 个节点；<br>使用双指针则可以不用统计链表长度。</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/1600794523-AAMvoP-Picture1.png" alt="Picture1.png"></p><p><strong>算法流程简单, 略</strong></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    ListNode<span class="token operator">*</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>former<span class="token punctuation">,</span> <span class="token operator">*</span>latter<span class="token punctuation">;</span>        former <span class="token operator">=</span> latter <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            former <span class="token operator">=</span> former<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>former <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            former <span class="token operator">=</span> former<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>            latter <span class="token operator">=</span> latter<span class="token operator">-</span><span class="token operator">></span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> latter<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220504181816417.png" alt="image-20220504181816417"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十一天-双指针-简单&quot;&gt;&lt;a href=&quot;#第十一天-双指针-简单&quot; class=&quot;headerlink&quot; title=&quot;第十一天_双指针(简单)&quot;&gt;&lt;/a&gt;第十一天_双指针(简单)&lt;/h1&gt;&lt;h2 id=&quot;一-知识学习&quot;&gt;&lt;a href=&quot;#一-知识学习&quot; c</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV学习笔记一</title>
    <link href="https://roranrui.cn/2022/05/03/opencv-xue-xi-bi-ji-yi/"/>
    <id>https://roranrui.cn/2022/05/03/opencv-xue-xi-bi-ji-yi/</id>
    <published>2022-05-03T14:48:29.000Z</published>
    <updated>2022-05-03T15:13:24.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenCV学习笔记"><a href="#OpenCV学习笔记" class="headerlink" title="OpenCV学习笔记"></a>OpenCV学习笔记</h1><blockquote><p>  基于OpenCV 4.5.4</p><p>  参考自: 《OpenCV3编程入门——毛星云》</p></blockquote><h2 id="一-OpenCV基础"><a href="#一-OpenCV基础" class="headerlink" title="一. OpenCV基础"></a>一. OpenCV基础</h2><h3 id="1-基础图像容器Mat"><a href="#1-基础图像容器Mat" class="headerlink" title="1. 基础图像容器Mat"></a>1. 基础图像容器Mat</h3><blockquote><p>  Mat 是一个类，有两个数据部分组成，矩阵头（包含矩阵尺寸、存储方法、存储地址等信息）和一个指向所有存储像素值的矩阵。</p></blockquote><p>拷贝构造函数和赋值运算符只复制信息头，与原对象共用一个矩阵，若改一个，则都受影响。<br>使用函数<code>clone()</code>或<code>copyTo()</code>可以复制矩阵。</p><p><strong>使用Mat创建图像</strong><br><code>Mat M = (2, 2, CV_8UC3, Scalar(0, 0, 255));</code></p><p>参数解释:</p><ul><li>2，2为二维矩阵的大小</li><li>CV_[位数][带符号与否][类型前缀]C[通道数]</li><li>Scalar(a,b,c,d)四个参数，是一个类。表示颜色</li><li>在RGB中，前三个依次为B,G,R，最后一个可不写。</li></ul><h3 id="2-常用数据结构"><a href="#2-常用数据结构" class="headerlink" title="2. 常用数据结构"></a>2. 常用数据结构</h3><h4 id="Point类"><a href="#Point类" class="headerlink" title="Point类"></a>Point类</h4><blockquote><p>  用于表示一个点</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">Point point<span class="token punctuation">;</span>point<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>point<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>Point <span class="token function">point</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Scalar类"><a href="#Scalar类" class="headerlink" title="Scalar类"></a>Scalar类</h4><blockquote><p>  颜色表示</p></blockquote><p><code>Scalar（0，0，255）</code> 依次是B, G, R的值(OpenCV存储RGB的顺序是BGR)</p><h4 id="Size类"><a href="#Size类" class="headerlink" title="Size类"></a>Size类</h4><blockquote><p>  用于表示图像的宽和高</p></blockquote><p><code>Size（5，5）</code>表示宽高都为5</p><h4 id="Rect类"><a href="#Rect类" class="headerlink" title="Rect类"></a>Rect类</h4><p>Rect类的成员变量有下:</p><ul><li><strong>x, y, width, height, 分别为左上角点的坐标和矩形的宽和高。</strong></li></ul><p>常用的成员函数有：</p><ul><li>Size()返回值为Size();</li><li>area()返回矩形的面积。</li><li>Constrins(Point)判断点是否在矩形内；</li><li>inside（Rect）函数判断矩形是否在矩形内；</li><li>tl()返回左上角点的坐标；</li><li>br()返回右下角点的坐标。还可对矩形进行交集、并集、平移和缩放操作。</li></ul><h4 id="RotateRect类"><a href="#RotateRect类" class="headerlink" title="RotateRect类*"></a>RotateRect类*</h4><blockquote><p>  RotatedRect是一个存储旋转矩形的类，通常用来存储最小外包矩形函数minAreaRect( )和椭圆拟合函数fitEllipse( )返回的结果。存储的值，完全取决在于函数的返回</p></blockquote><p><strong>类的声明:</strong>              </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">RotatedRect</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span><span class="token operator">:</span>                    <span class="token function">RotatedRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//构造函数</span>        <span class="token function">RotatedRect</span><span class="token punctuation">(</span><span class="token keyword">const</span> Point2f<span class="token operator">&amp;</span> center<span class="token punctuation">,</span> <span class="token keyword">const</span> Size2f<span class="token operator">&amp;</span> size<span class="token punctuation">,</span> <span class="token keyword">float</span> angle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">RotatedRect</span><span class="token punctuation">(</span><span class="token keyword">const</span> CvBox2D<span class="token operator">&amp;</span> box<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token keyword">void</span> <span class="token function">points</span><span class="token punctuation">(</span>Point2f pts<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//返回矩形的4个顶点      </span>        Rect <span class="token function">boundingRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//返回包含旋转矩形的最小矩形     </span>        <span class="token keyword">operator</span> <span class="token function">CvBox2D</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//转换到旧式的cvbox2d结构</span>            <span class="token keyword">float</span> angle<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//旋转角度，当角度为0、90、180、270等时，矩形就成了一个直立的矩形  </span>        Point2f center<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//矩形的质心      </span>        Size2f size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//矩形的边长      </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OpenCV中，坐标的原点在左上角，与x轴平行的方向为角度为0，逆时针旋转角度为负，顺时针旋转角度为正 </p><h5 id="minAreaRect"><a href="#minAreaRect" class="headerlink" title="minAreaRect( )"></a>minAreaRect( )</h5><p>函数返回的参数，请看下图：</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/20170712170137455" alt="img"></p><p>角度参数angle 是矩形最下面的点（y坐标最大）P[0]发出的平行于x轴的射线，逆时针旋转，与碰到的第一个边的夹角（这个边的边长就作为width），取值范围[-90~0]。</p><h5 id="points-Point2f-pts"><a href="#points-Point2f-pts" class="headerlink" title="points(Point2f pts[])"></a>points(Point2f pts[])</h5><p>可以计算出矩形的四个角点。 计算出来的角点是 固定的顺序 ，如图所示。</p><blockquote><p>  在利用minAreaRect函数去求一个外接矩形时，函数对于矩形长和宽的选择取决于这个外接矩形的边与水平轴的角度距离，即将水平轴逆时针旋转，最先与其平行的边的长度作为宽度width，另外一条边则为height，而角度则直接取该边与水平轴的夹角。应该意识到，在minAreaRect函数中，RotatedRect的width和height的选取跟矩形的尺寸无关，并非长的就是height，短的就是width。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OpenCV学习笔记&quot;&gt;&lt;a href=&quot;#OpenCV学习笔记&quot; class=&quot;headerlink&quot; title=&quot;OpenCV学习笔记&quot;&gt;&lt;/a&gt;OpenCV学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  基于OpenCV 4.5.4&lt;/p&gt;
&lt;p&gt; </summary>
      
    
    
    
    <category term="OpenCV学习笔记" scheme="https://roranrui.cn/categories/OpenCV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="OpenCv" scheme="https://roranrui.cn/tags/OpenCv/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记一</title>
    <link href="https://roranrui.cn/2022/05/03/css-xue-xi-bi-ji/"/>
    <id>https://roranrui.cn/2022/05/03/css-xue-xi-bi-ji/</id>
    <published>2022-05-03T13:25:30.000Z</published>
    <updated>2022-05-03T14:36:43.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS学习笔记一"><a href="#CSS学习笔记一" class="headerlink" title="CSS学习笔记一"></a>CSS学习笔记一</h1><blockquote><p>  文章转载至: MurphyChen’s Notes(<a href="https://docs.mphy.top/)%E4%BB%85%E4%BE%9B%E5%AD%A6%E4%B9%A0%E4%BA%A4%E6%B5%81%E4%BD%BF%E7%94%A8">https://docs.mphy.top/)仅供学习交流使用</a></p><p>  如有侵权, 请立即联系我删除!</p></blockquote><h2 id="1-CSS-简介"><a href="#1-CSS-简介" class="headerlink" title="1. CSS 简介"></a>1. CSS 简介</h2><h3 id="1-1-HTML-的局限性"><a href="#1-1-HTML-的局限性" class="headerlink" title="1.1 HTML 的局限性"></a>1.1 HTML 的局限性</h3><p>HTML 是网友的骨架，只关注内容的语义。例如<code>&lt;h1&gt;</code>表示大标题，<code>&lt;p&gt;</code>表示段落。</p><p>早期的时候，HTML 只能做一些简单的样式，网页非常丑，而且使 HTML 代码臃肿。</p><h3 id="1-2-CSS-网页的美容师"><a href="#1-2-CSS-网页的美容师" class="headerlink" title="1.2 CSS-网页的美容师"></a>1.2 CSS-网页的美容师</h3><p>CSS 是 层叠样式表（Cascading Style Sheets）的简称。</p><p>CSS 也是一种标记语言。</p><p>CSS 主要用于设置 HTML 页面中的文本内容（字体、大小、对齐方式）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。</p><p>HTML 呈现结构，CSS 决定样式，结构与样式分离。</p><h3 id="1-2-CSS-语法规范"><a href="#1-2-CSS-语法规范" class="headerlink" title="1.2 CSS 语法规范"></a>1.2 CSS 语法规范</h3><p>CSS 规则由两个部分组成：选择器和一条或多条声明。</p><h3 id="1-3-CSS-代码风格"><a href="#1-3-CSS-代码风格" class="headerlink" title="1.3 CSS 代码风格"></a>1.3 CSS 代码风格</h3><ul><li>展开式</li><li>选择器，属性名，属性关键字全部小写</li><li>空格规范</li></ul><h2 id="2-CSS-基础选择器"><a href="#2-CSS-基础选择器" class="headerlink" title="2. CSS 基础选择器"></a>2. CSS 基础选择器</h2><h3 id="2-1-选择器的作用"><a href="#2-1-选择器的作用" class="headerlink" title="2.1 选择器的作用"></a>2.1 选择器的作用</h3><p>选择器就是根据不同需求把不同标签选择出来。</p><h3 id="2-2-选择器分类"><a href="#2-2-选择器分类" class="headerlink" title="2.2 选择器分类"></a>2.2 选择器分类</h3><p>选择器分为基础选择器和复合选择器两大类。</p><ul><li>基础选择器由单个选择器组成</li><li>基础选择器包括：标签选择器、类选择器、id 选择器和通配符选择器</li></ul><h3 id="2-3-标签选择器"><a href="#2-3-标签选择器" class="headerlink" title="2.3 标签选择器"></a>2.3 标签选择器</h3><p>直接用 HTML 标签名作为选择器，按标签名称分类，<strong>为页面某一类标签指定统一的 CSS 样式。</strong></p><p>语法</p><pre class="line-numbers language-HTML"><code class="language-HTML">标签名 {    属性1： 属性值1;    属性2： 属性值2;    属性3： 属性值3;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点 标签选择器可以把某一标签全部选择出来，快速为同类型标签设置统一样式。</p><p>缺点 不能设置差异化样式，只能选择全部当前标签。</p><h3 id="2-4-类选择器"><a href="#2-4-类选择器" class="headerlink" title="2.4 类选择器"></a>2.4 类选择器</h3><p>差异化选择不同标签，单独选一个或者某个标签。</p><p>语法</p><p>使用 <code>class</code> 属性来调用 class 类，样式点定义，结构类调用，一个或多个，开发最常用。</p><p>类选择器用 <code>.</code> 号显示。</p><p>注意</p><ol><li>类选择器用 <code>.</code> 标识，紧跟类名。</li><li>小写，使用 <code>-</code> 连接单词。</li><li>不要用纯数字、中文。</li><li>命名有意义。</li></ol><h3 id="2-4-1-类选择器-多类名"><a href="#2-4-1-类选择器-多类名" class="headerlink" title="2.4.1 类选择器-多类名"></a>2.4.1 类选择器-多类名</h3><p>类名间用空格分开</p><pre class="line-numbers language-HTML"><code class="language-HTML"><p class="class-name1 class-name2"></p><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-5-id-选择器"><a href="#2-5-id-选择器" class="headerlink" title="2.5 id 选择器"></a>2.5 id 选择器</h3><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p><p>HTML 元素以 id 属性来设置 id 选择器，用 <code>#</code> 来定义。</p><pre class="line-numbers language-HTML"><code class="language-HTML">#id名 {    属性1: 属性值1;    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>样式 <code>#</code> 定义，结构 id 调用，别人切勿使用。</p><p>id 选择器与类选择器的区别</p><ol><li>类选择器可以被多个元素调用。</li><li>id 选择器只能允许一个标签调用。</li><li>类选择器使用的较多，id 选择器用于唯一特性的标签。</li></ol><h3 id="2-6-通配符选择器"><a href="#2-6-通配符选择器" class="headerlink" title="2.6 通配符选择器"></a>2.6 通配符选择器</h3><p>语法</p><pre class="line-numbers language-HTML"><code class="language-HTML">* {    属性1: 属性值1;    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>用 <code>*</code> 定义通配符选择器，选取页面中所有标签。</li><li>不需要调用，自动给所有标签。</li><li>特殊情况使用</li></ul><pre class="line-numbers language-HTML"><code class="language-HTML">* {    margin: 0;    padding: 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-基础选择器总结"><a href="#2-7-基础选择器总结" class="headerlink" title="2.7 基础选择器总结"></a>2.7 基础选择器总结</h3><table><thead><tr><th>基础选择器</th><th>作用</th><th>特点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>选中所有相同标签</td><td>不能差异化选择</td><td>较多</td><td><code>p{color:red;}</code></td></tr><tr><td>类选择器</td><td>选出一个或多个标签</td><td>可以根据需求选择</td><td>较多</td><td><code>.nav {color: red;}</code></td></tr><tr><td>id 选择器</td><td>一次只能选出一个标签</td><td>一个 id 属性在页面中只能出现一次</td><td>一般配合 js 使用</td><td><code>#nav {color: red;}</code></td></tr><tr><td>通配符选择器</td><td>选择所有标签元素</td><td>选择的太多，有部分不需要</td><td>特殊情况使用</td><td><code>* {color: red; }</code></td></tr></tbody></table><ul><li>每个选择器都有自己的使用场景，都要掌握。</li><li>如果是修改样式，类选择器是使用最多的。</li></ul><h2 id="3-CSS-字体属性"><a href="#3-CSS-字体属性" class="headerlink" title="3. CSS 字体属性"></a>3. CSS 字体属性</h2><h3 id="3-1-字体系列"><a href="#3-1-字体系列" class="headerlink" title="3.1 字体系列"></a>3.1 字体系列</h3><p>CSS 使用 <code>font-family</code> 属性定义文本字体系列。 尽量使用默认字体，保证不同浏览器的兼容性。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">body </span><span class="token punctuation">{</span>  <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">"微软雅黑"</span>, Arial, Helvetica, sans-serif<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-2-字体大小"><a href="#3-2-字体大小" class="headerlink" title="3.2 字体大小"></a>3.2 字体大小</h3><p>CSS 使用 <code>font-size</code> 属性定义字体大小。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">body </span><span class="token punctuation">{</span>  <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">16</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>px</code> 大小是我们网页常用单位</li><li>谷歌浏览器默认是 <code>16px</code></li><li>可以给 <code>body</code> 指定整个页面文字大小</li></ul><h3 id="3-3-字体粗细"><a href="#3-3-字体粗细" class="headerlink" title="3.3 字体粗细"></a>3.3 字体粗细</h3><p>CSS 使用 <code>font-weight</code> 属性设置字体粗细</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">p </span><span class="token punctuation">{</span>  <span class="token property">font-weight</span><span class="token punctuation">:</span> <span class="token number">700</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实际开发中，更常用数字来表示加粗或变细。<code>400</code>为<code>normal</code>，<code>700</code> 为 <code>bold</code>。 |属性值|描述| |-|-| |normal|默认值| |bold|定义粗体| |100-900|400 等价于 normal，700 等价于 bold，无单位|</p><h3 id="3-4-文字样式"><a href="#3-4-文字样式" class="headerlink" title="3.4 文字样式"></a>3.4 文字样式</h3><p>CSS 使用 <code>font-style</code> 属性设置文本风格。</p><pre class="line-numbers language-html"><code class="language-html">p { font-style: italic; }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>normal</td><td>正常显示</td></tr><tr><td>italic</td><td><em>斜体</em></td></tr></tbody></table><p>注意：平常很少给字体加斜体，而是给斜体标签（em,i）给位不倾斜字体。</p><h3 id="3-5-字体复合属性写法"><a href="#3-5-字体复合属性写法" class="headerlink" title="3.5 字体复合属性写法"></a>3.5 字体复合属性写法</h3><p>将各种字体属性写在同一选择器下，节约代码。</p><p>规则</p><p>严格遵守顺序，且 <code>font-sieze</code> 和 <code>font-family</code> 必须有。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">body </span><span class="token punctuation">{</span>  <span class="token property">font</span><span class="token punctuation">:</span> font-style font-weight font-size/line-hight font-family<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-6-字体属性总结"><a href="#3-6-字体属性总结" class="headerlink" title="3.6 字体属性总结"></a>3.6 字体属性总结</h3><table><thead><tr><th>字体属性</th><th>表示</th><th>注意</th></tr></thead><tbody><tr><td>font-size</td><td>字号</td><td>单位是 <code>px</code></td></tr><tr><td>font-family</td><td>字体</td><td>按照团队约定来写</td></tr><tr><td>font-weight</td><td>字体粗细</td><td>400=normal，700=bold</td></tr><tr><td>font-style</td><td>字体样式</td><td>italic，normal，常用 normal</td></tr><tr><td>font</td><td>属性连写</td><td>顺序不能变，字体和字号属性必须有</td></tr></tbody></table><h2 id="4-CSS-文本属性"><a href="#4-CSS-文本属性" class="headerlink" title="4. CSS 文本属性"></a>4. CSS 文本属性</h2><p>CSS Text（文本）属性定义文本外观，比如颜色、对齐、装饰、缩进、行间距等。</p><h3 id="4-1-文本颜色"><a href="#4-1-文本颜色" class="headerlink" title="4.1 文本颜色"></a>4.1 文本颜色</h3><p><code>color</code> 属性定义文本颜色。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div </span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>属性值 |表示颜色|属性值| |-|-| |预定义的颜色值|red,green,pink| |十六进制|#FF0000，#FF6600| |RGB 代码|rgb(255,0,0)|</p><p>实际开发中，最常用的是十六进制。</p><h3 id="4-2-对齐文本"><a href="#4-2-对齐文本" class="headerlink" title="4.2 对齐文本"></a>4.2 对齐文本</h3><p><code>text-align</code> 属性用于设置元素文本内容的对齐方式。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">div </span><span class="token punctuation">{</span>  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>属性值</th><th>解释</th></tr></thead><tbody><tr><td>left</td><td>左对齐（默认）</td></tr><tr><td>right</td><td>右对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr></tbody></table><h3 id="4-3-装饰文本"><a href="#4-3-装饰文本" class="headerlink" title="4.3 装饰文本"></a>4.3 装饰文本</h3><p><code>text-decoration</code> 属性规定添加到文本的修饰。可以给文本添加下划线、删除线、上划线等。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token property">text-decoration</span><span class="token punctuation">:</span> underline<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认，无装饰（最常用）</td></tr><tr><td>underline</td><td>下划线，a 标签自带（常用）</td></tr><tr><td>overline</td><td>上划线。（几乎不用）</td></tr><tr><td>line-through</td><td>删除线。（不常用）</td></tr></tbody></table><h3 id="4-4-文本缩进"><a href="#4-4-文本缩进" class="headerlink" title="4.4 文本缩进"></a>4.4 文本缩进</h3><p><code>text-indent</code>定义段落首行缩进。</p><pre class="line-numbers language-css"><code class="language-css"><span class="token selector">p </span><span class="token punctuation">{</span>  <span class="token property">text-indet</span><span class="token punctuation">:</span> <span class="token number">5</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>em</code> 是一个相对单位，<code>1em</code> 就是一个字符所占大小。当 <code>text-indent=2em</code>，则恰好缩进两个文字。</p><h3 id="4-5-行间距"><a href="#4-5-行间距" class="headerlink" title="4.5 行间距"></a>4.5 行间距</h3><p><code>line-height</code> 设置行间的距离，行间距=文本高度+上间距+下间距</p><h3 id="4-6-文本属性总结"><a href="#4-6-文本属性总结" class="headerlink" title="4.6 文本属性总结"></a>4.6 文本属性总结</h3><table><thead><tr><th>属性</th><th>表示</th><th>注意</th></tr></thead><tbody><tr><td>color</td><td>文本颜色</td><td>通常十六进制缩写</td></tr><tr><td>text-align</td><td>文本对齐</td><td></td></tr><tr><td>text-indent</td><td>文本缩进</td><td>记住 <code>text-indent: 2em;</code></td></tr><tr><td>text-decoration</td><td>文本装饰</td><td>记住下划线和去除下划线</td></tr><tr><td>line-height</td><td>行高</td><td></td></tr></tbody></table><h2 id="5-CSS-引用方式"><a href="#5-CSS-引用方式" class="headerlink" title="5. CSS 引用方式"></a>5. CSS 引用方式</h2><p>按照 CSS 书写的位置不同，CSS 样式表可以分为三大类：</p><ol><li>行内样式表（行内式）</li><li>内部样式表（嵌入式）</li><li>外部样式表（链接式）</li></ol><h3 id="5-1-内部样式表"><a href="#5-1-内部样式表" class="headerlink" title="5.1 内部样式表"></a>5.1 内部样式表</h3><p>将 CSS 代码写在 HTML 页面内部，单独放在一个 <code>&lt;style&gt;</code> 标签中。</p><ul><li><code>&lt;style&gt;</code> 理论上可以放在 HTML 文档中任何一个地方，一般放在 <code>&lt;head&gt;</code> 标签中。</li><li>方便控制整个页面中的元素样式。</li></ul><p>练习时使用，实际开发不用。</p><h3 id="5-2-行内样式表"><a href="#5-2-行内样式表" class="headerlink" title="5.2 行内样式表"></a>5.2 行内样式表</h3><p>行内样式表（内联样式表）是在元素标签内部的 <code>style</code> 属性中设定 CSS 样式，适合修改简单样式。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span> <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">12</span>px</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>行内样式表<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>设置当前标签样式</li><li>书写繁琐，不推荐大量使用。</li></ul><h3 id="5-3-外部样式表"><a href="#5-3-外部样式表" class="headerlink" title="5.3 外部样式表"></a>5.3 外部样式表</h3><p>实际开发中都是外部样式表，适用于样式比较多的情况。 核心：样式单独写到 CSS 文件中，再将 CSS 文件引入到 HTML 页面中。</p><p>引入格式</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>css文件路径<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS学习笔记一&quot;&gt;&lt;a href=&quot;#CSS学习笔记一&quot; class=&quot;headerlink&quot; title=&quot;CSS学习笔记一&quot;&gt;&lt;/a&gt;CSS学习笔记一&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  文章转载至: MurphyChen’s Notes(&lt;a hr</summary>
      
    
    
    
    <category term="前端学习" scheme="https://roranrui.cn/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="前端" scheme="https://roranrui.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="css" scheme="https://roranrui.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Git简单使用教程</title>
    <link href="https://roranrui.cn/2022/05/03/git-jian-dan-shi-yong-jiao-cheng/"/>
    <id>https://roranrui.cn/2022/05/03/git-jian-dan-shi-yong-jiao-cheng/</id>
    <published>2022-05-03T07:43:22.000Z</published>
    <updated>2022-05-03T07:44:51.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git简单使用教程"><a href="#Git简单使用教程" class="headerlink" title="Git简单使用教程"></a>Git简单使用教程</h1><h2 id="1-Git的安装"><a href="#1-Git的安装" class="headerlink" title="1. Git的安装"></a>1. Git的安装</h2><ul><li><p><a href="https://git-scm.com/">git安装网址</a></p></li><li><p><a href="https://git-scm.com/book/zh/v2">git官方参考手册</a></p></li><li><p>Ubuntu下安装：<code>sudo apt-get install git</code></p></li></ul><hr><h2 id="2-Git搭建本地仓库"><a href="#2-Git搭建本地仓库" class="headerlink" title="2. Git搭建本地仓库"></a>2. Git搭建本地仓库</h2><p>​选择你要搭建仓库的文件夹, <code>git bush here</code>, 出现输入终端:</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/image-20220503151044126.png" alt="image-20220503151044126"></p><p>此时, 如果是第一次使用, 应该设置一下名字和邮箱, 命令如下:</p><pre class="line-numbers language-git"><code class="language-git">git config --global user.name <span class="token string">"xxxx"</span>git config --global user.email <span class="token string">"xxxx.@xxx.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>建立仓库:</strong></p><p>先初始化仓库</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入上面的命令后, 就会出现一个文件夹<code>.git</code></p><p><strong>接下来添加文件:</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> add <span class="token keyword">.</span>  <span class="token punctuation">(</span>不要忘记后面这点<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>  这个命令是将仓库中的除了<code>.gitignore</code>中排除的其他文件都添加到缓存区</p></blockquote><p><strong>增加到版本库中:</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> commit -m <span class="token string">'备注信息'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除暂存区:</strong></p><ul><li>保证当前工作区中没有<code>add</code>过的文件</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> fileName --cached<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看版本:</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> log --oneline<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>回退版本:</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> reset --hard 后面加版本号<span class="token function">git</span> log  回滚最近的一个版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>至此, 一个本地仓库就搭建完成了, 可以在本地对代码进行版本控制</p><hr><h2 id="3-本地仓库关联到远程仓库"><a href="#3-本地仓库关联到远程仓库" class="headerlink" title="3. 本地仓库关联到远程仓库"></a>3. 本地仓库关联到远程仓库</h2><p><strong>连接远程仓库</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript">git remote add origin 仓库的地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看远程仓库</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript">git remote <span class="token operator">-</span>v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除远程仓库</strong></p><pre class="line-numbers language-javascript"><code class="language-javascript">git remote rm origin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>本地库的改动提交到远程库：</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>更新本地库至远程库的最新改动:</strong></p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> pull<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><h3 id="与查询有关的："><a href="#与查询有关的：" class="headerlink" title="与查询有关的："></a>与查询有关的：</h3><ul><li><p>查询仓库状态：<code>git status</code> </p></li><li><p>查询远程仓库状态: <code>git remote -v</code></p></li><li><p>比较文件差异（请在git add之前使用）：<code>git diff 文件名</code> </p></li><li><p>查看仓库历史记录(详细)：<code>git log</code> </p></li><li><p>查看仓库历史记录(单行)：<code>git log --pretty=online</code> 或 <code>git log --online</code> </p></li><li><p>查看所有版本的commit ID：<code>git reflog</code></p></li></ul><h3 id="与撤销有关的："><a href="#与撤销有关的：" class="headerlink" title="与撤销有关的："></a>与撤销有关的：</h3><ul><li>撤销工作区的修改：<code>git checkout -- 文件名</code> </li><li>撤销暂存区的修改：<code>git reset HEAD 文件名</code> </li><li>回退到历史版本：<code>git reset --hard 该版本ID</code> </li><li>回退到上个版本：<code>git reset --hard HEAD^</code> 上上版本是<code>HEAD^^</code>，也可用<code>HEAD~2</code>表示，以此类推</li></ul><h3 id="与标签有关的："><a href="#与标签有关的：" class="headerlink" title="与标签有关的："></a>与标签有关的：</h3><ul><li>为当前版本打标签：<code>git tag 标签名</code> </li><li>为历史版本打标签：<code>git tag 标签名 该版本ID</code> </li><li>指定标签说明：<code>git tag –a 标签名 –m "标签说明" [可选：版本ID]</code> </li><li>查看所有标签：<code>git tag</code> </li><li>查看某一标签：<code>git show 标签名</code> </li><li>删除某一标签：<code>git tag –d 标签名</code></li></ul><h3 id="与添加有关的："><a href="#与添加有关的：" class="headerlink" title="与添加有关的："></a>与添加有关的：</h3><ul><li>将当前目录变为仓库：<code>git init</code></li><li>将文件添加到暂存区：<code>git add 文件名 [可选：另一个文件名]</code></li><li>将暂存区提交到仓库：<code>git commit –m "描述"</code></li></ul><h2 id="4-分支管理"><a href="#4-分支管理" class="headerlink" title="4. 分支管理"></a>4. 分支管理</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre class="line-numbers language-javascript"><code class="language-javascript">git branch dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><pre class="line-numbers language-javascript"><code class="language-javascript">git checkout dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建分支并切换分支"><a href="#创建分支并切换分支" class="headerlink" title="创建分支并切换分支"></a>创建分支并切换分支</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> branch -d dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="上提交新的版本"><a href="#上提交新的版本" class="headerlink" title="上提交新的版本"></a>上提交新的版本</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> commit -a -m <span class="token string">'dev1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> merge dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="分支的合并后显示log"><a href="#分支的合并后显示log" class="headerlink" title="分支的合并后显示log"></a>分支的合并后显示log</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> log --oneline --graph --decorate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="在分支开发的过程中遇到其他问题需要切换其他分支"><a href="#在分支开发的过程中遇到其他问题需要切换其他分支" class="headerlink" title="在分支开发的过程中遇到其他问题需要切换其他分支"></a>在分支开发的过程中遇到其他问题需要切换其他分支</h3><ul><li>保留写好的内容在切换到主干</li><li>保留内容 <code>git stash</code></li></ul><hr><h2 id="仓库地址选择-HTTPS-or-SSH"><a href="#仓库地址选择-HTTPS-or-SSH" class="headerlink" title="仓库地址选择(HTTPS or SSH)"></a>仓库地址选择(HTTPS or SSH)</h2><p>如果选择SSH协议，必须将本地的公钥添加到相应代码托管平台上(以github为例)。</p><p><strong>SSH Key</strong></p><p>生成SSH Key：<code>ssh-keygen –t rsa –C "你的邮箱@xx.com"</code> 生成Key时弹出选项，回车选择默认即可。 Key保存位置：<code>/root/.ssh</code> 登陆GitHub，创建new SSH key，其内容为<code>/root/.ssh/id_rsa.pub</code>中文本</p><h2 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h2><h3 id="rejected"><a href="#rejected" class="headerlink" title="! [rejected]"></a>! [rejected]</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7702/2018072410120456" alt="img"></p><p>执行命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> pull origin master --allow-unrelated-histories<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="拓展-git-submodules"><a href="#拓展-git-submodules" class="headerlink" title="拓展: git submodules"></a>拓展: git submodules</h2><h3 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git简单使用教程&quot;&gt;&lt;a href=&quot;#Git简单使用教程&quot; class=&quot;headerlink&quot; title=&quot;Git简单使用教程&quot;&gt;&lt;/a&gt;Git简单使用教程&lt;/h1&gt;&lt;h2 id=&quot;1-Git的安装&quot;&gt;&lt;a href=&quot;#1-Git的安装&quot; class=&quot;</summary>
      
    
    
    
    <category term="Git" scheme="https://roranrui.cn/categories/Git/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="Git" scheme="https://roranrui.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>第十天_动态规划(中等)</title>
    <link href="https://roranrui.cn/2022/05/03/shua-ti-bi-ji-shi/"/>
    <id>https://roranrui.cn/2022/05/03/shua-ti-bi-ji-shi/</id>
    <published>2022-05-03T00:01:37.000Z</published>
    <updated>2022-05-03T06:28:24.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十天-动态规划-中等"><a href="#第十天-动态规划-中等" class="headerlink" title="第十天_动态规划(中等)"></a>第十天_动态规划(中等)</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="lt-algorithm-gt-中的最大值最小值"><a href="#lt-algorithm-gt-中的最大值最小值" class="headerlink" title="<algorithm>中的最大值最小值"></a>&lt;algorithm&gt;中的最大值最小值</h3><ul><li>max() : 返回最大值</li><li>min(): 返回最小值</li><li>max_element()返回最大值的地址, 对容器就是<code>iterator</code></li><li>min_element()返回最小值的地址, 对容器就是<code>iterator</code></li></ul><h3 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h3><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回   0</p><p>&gt; 返回   1 </p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li><li><code>int compare(const char *s) const;</code>      //与字符串s比较</li></ul><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-把数字翻译成字符串"><a href="#1-把数字翻译成字符串" class="headerlink" title="1. 把数字翻译成字符串"></a>1. 把数字翻译成字符串</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503080557064.png" alt="image-20220503080557064"></p><p>解题思路:</p><p><strong>1.动态规划</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1603462412-iUcKzA-Picture1.png" alt="Picture1.png"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1603461843-qyOiIi-Picture8.png" alt="img"></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">translateNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            string tmp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"25"</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503082321077.png" alt="image-20220503082321077"></p><p><strong>空间优化版本</strong></p><p>由于 dp[i] 只与 dp[i - 1] 有关，因此可使用两个变量 a, b 分别记录 dp[i] , dp[i - 1]，两变量交替前进即可。此方法可省去 dp 列表使用的 O(N) 的额外空间。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">translateNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            string tmp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> tmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token string">"25"</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">?</span> a <span class="token operator">+</span> b <span class="token operator">:</span> a<span class="token punctuation">;</span>            b <span class="token operator">=</span> a<span class="token punctuation">;</span>            a <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.数字求余</strong></p><blockquote><p>  上述方法虽然已经节省了 dp列表的空间占用，但字符串 s仍使用了 O(N)大小的额外空间。</p><p>  <strong>空间复杂度优化：</strong><br>  利用求余运算 num%10 和求整运算 num // 10 ，可获取数字 num 的各位数字（获取顺序为个位、十位、百位…）。<br>  运用 求余 和 求整 运算实现，可实现 从右向左 的动态规划计算。而根据上述动态规划 “对称性” ，可知从右向左计算是正确的。<br>  自此，字符串 s 的空间占用也被省去，空间复杂度从 O(N)降至 O(1) 。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">translateNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y <span class="token operator">=</span> num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            num <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>            x <span class="token operator">=</span> num <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>tmp <span class="token operator">>=</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> tmp <span class="token operator">&lt;=</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">?</span> a <span class="token operator">+</span> b <span class="token operator">:</span> a<span class="token punctuation">;</span>            b <span class="token operator">=</span> a<span class="token punctuation">;</span>            a <span class="token operator">=</span> c<span class="token punctuation">;</span>            y <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-最长不含重复字符的子字符串"><a href="#2-最长不含重复字符的子字符串" class="headerlink" title="2. 最长不含重复字符的子字符串"></a>2. 最长不含重复字符的子字符串</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503083055523.png" alt="image-20220503083055523"></p><p><strong>解题思路</strong>:</p><p>1.动态规划</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503083340522.png" alt="image-20220503083340522"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599287290-mTdFye-Picture1.png" alt="Picture1.png"></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> i<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> j <span class="token operator">-</span> i <span class="token operator">?</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">max_element</span><span class="token punctuation">(</span>dp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503085923960.png" alt="image-20220503085923960"></p><p>2.结合Hashmap</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">;</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> dic<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> dic<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 未找到相同元素 </span>            <span class="token keyword">else</span> i <span class="token operator">=</span> dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> second<span class="token punctuation">;</span>            dic<span class="token punctuation">[</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> j <span class="token operator">-</span> i <span class="token operator">?</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> j <span class="token operator">-</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token function">max_element</span><span class="token punctuation">(</span>dp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220503091249798.png" alt="image-20220503091249798"></p><blockquote><p>  我们学习这些东西的目的并不是，要把他们都用到实际开发中。</p><blockquote><blockquote><p>  相反，如果我们能够用最少的东西写出一个稳定的，高效的多线程程序，更值得赞赏。</p></blockquote><blockquote><blockquote><p>   我们为了成长必须阅读一些高手写的代码，从而实现自己代码的积累；</p></blockquote></blockquote></blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十天-动态规划-中等&quot;&gt;&lt;a href=&quot;#第十天-动态规划-中等&quot; class=&quot;headerlink&quot; title=&quot;第十天_动态规划(中等)&quot;&gt;&lt;/a&gt;第十天_动态规划(中等)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href=&quot;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第九天_动态规划(中等)</title>
    <link href="https://roranrui.cn/2022/05/02/shua-ti-bi-ji-jiu/"/>
    <id>https://roranrui.cn/2022/05/02/shua-ti-bi-ji-jiu/</id>
    <published>2022-05-02T06:33:07.000Z</published>
    <updated>2022-05-02T10:43:54.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九天-动态规划-中等"><a href="#第九天-动态规划-中等" class="headerlink" title="第九天_动态规划(中等)"></a>第九天_动态规划(中等)</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-连续子数组的最大和"><a href="#1-连续子数组的最大和" class="headerlink" title="1. 连续子数组的最大和"></a>1. 连续子数组的最大和</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502150950334.png" alt="image-20220502150950334"></p><p><strong>解题思路:</strong></p><p>动态规划是本题的最优解法，以下按照标准流程解题。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502151330317.png" alt="解题流程"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/77d1aa6a444743d3c8606ac951cd7fc38faf68a62064fd2639df517cd666a4d0-Picture1.png" alt="Picture1.png"></p><p>实现</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dp<span class="token punctuation">;</span>        dp<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&lt;</span> temp<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                res <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502153026571.png" alt="image-20220502153026571"></p><p><strong>空间内存优化版本:</strong></p><p>空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxSubArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> res<span class="token punctuation">)</span> res <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502153702191.png" alt="image-20220502153702191"></p><hr><h3 id="2-礼物的最大价值"><a href="#2-礼物的最大价值" class="headerlink" title="2. 礼物的最大价值"></a>2. 礼物的最大价值</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1662cdf7aafd8c9ed6e1eadc41bfc9adf58ea808e11f1a3dd2e8ba4632b9d1ac-Picture1.png" alt="Picture1.png"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502154533328.png" alt="image-20220502154533328"></p><p>实现: </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxValue</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> i <span class="token operator">&amp;&amp;</span> <span class="token number">0</span> <span class="token operator">==</span> j<span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                    grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                        grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> grid<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502164846692.png" alt="image-20220502164846692"></p><p>使dp数组比grid数组多一行一列，初始化为0，这样既可避免判断是不是在边界的问题:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxValue</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                         <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502165012493.png" alt="image-20220502165012493"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第九天-动态规划-中等&quot;&gt;&lt;a href=&quot;#第九天-动态规划-中等&quot; class=&quot;headerlink&quot; title=&quot;第九天_动态规划(中等)&quot;&gt;&lt;/a&gt;第九天_动态规划(中等)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href=&quot;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu美化教程</title>
    <link href="https://roranrui.cn/2022/05/01/ubuntu-mei-hua-jiao-cheng/"/>
    <id>https://roranrui.cn/2022/05/01/ubuntu-mei-hua-jiao-cheng/</id>
    <published>2022-05-01T13:26:36.000Z</published>
    <updated>2022-05-02T10:39:32.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu美化教程"><a href="#Ubuntu美化教程" class="headerlink" title="Ubuntu美化教程"></a>Ubuntu美化教程</h1><blockquote><p>  基于Ubuntu20.04.4LTS</p></blockquote><h2 id="一-壁纸美化"><a href="#一-壁纸美化" class="headerlink" title="一. 壁纸美化"></a>一. 壁纸美化</h2><h3 id="壁纸设置"><a href="#壁纸设置" class="headerlink" title="壁纸设置:"></a>壁纸设置:</h3><p>右键桌面-&gt;设置壁纸即可</p><p>效果: </p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/dsad.png" alt="dsad"></p><h3 id="登录背景修改"><a href="#登录背景修改" class="headerlink" title="登录背景修改"></a>登录背景修改</h3><p><strong>到这个网址下载一个包</strong>: <strong><a href="https://github.com/thiggy01/gdm-background">https://github.com/thiggy01/gdm-background</a></strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116230551731.png" alt="在这里插入图片描述"></p><p>解压</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/2021011623071684.png" alt="在这里插入图片描述"></p><p><strong>点击打开这个文件夹有以下文件 , 会看到有以下文件 :</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116230909852.png" alt="在这里插入图片描述"></p><p>终端中打开这个文件夹</p><p>安装编译包:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> <span class="token function">make</span> gcc libgtk-3-dev libpolkit-gobject-1-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116231935597.png" alt="在这里插入图片描述"></p><p>输入:</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查版本</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116232037877.png" alt="在这里插入图片描述"></p><p>编译之前下载好的包:</p><pre class="line-numbers language-bash"><code class="language-bash"> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后就能找到<strong>GDM Background 这个软件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501224321364.png" alt="image-20220501224321364"></p><p><strong>然后将你喜欢的背景图片拖入到这个窗口里:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20210116232737497.png" alt="在这里插入图片描述"></p><p>之后就替换成功;</p><p>效果:</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/2022-05-02_18-37.png" alt="2022-05-02_18-37"></p><hr><h2 id="二-终端美化"><a href="#二-终端美化" class="headerlink" title="二. 终端美化"></a>二. 终端美化</h2><h3 id="配置安装oh-my-zsh"><a href="#配置安装oh-my-zsh" class="headerlink" title="配置安装oh-my-zsh"></a>配置安装oh-my-zsh</h3><blockquote><p>  人生苦短，我用zsh…<br>  zsh完全兼容bash，并且<a href="https://so.csdn.net/so/search?q=oh-my-zsh&amp;spm=1001.2101.3001.7020">oh-my-zsh</a>的功能比bash强大很多，赶紧来试试！</p></blockquote><p><strong>下载安装oh-my-zsh</strong></p><pre class="line-numbers language-bash"><code class="language-bash">sh -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">wget</span> -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh<span class="token variable">)</span></span>"</span>1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若提示无法建立SSL连接，末尾再加上<code>--no-check-certificate</code>。原因是wget在使用HTTPS协议时，默认会去验证网站的证书，而这个证书验证经常会失败。加上该选项，就表示不检查。</p><p><strong>bash切换为zsh</strong><br>把默认bash更换为默认zsh，输入<code>chsh -s /bin/zsh</code>，不会立即生效，需要重启系统</p><p><strong>oh-my-zsh插件配置</strong><br>下载的插件都放在.oh-my-zsh/plugins/目录下，下面是几个常用的非常不错的插件。</p><p>autojump: <code>apt-get install autojump</code></p><p>autosuggestions: <code>git clone git://github.com/zsh-users/zsh-autosuggestions</code></p><p>自动语法高亮：<a href="https://github.com/zsh-users/zsh-syntax-highlighting">https://github.com/zsh-users/zsh-syntax-highlighting</a><br>自动输入建议：<a href="https://github.com/zsh-users/zsh-autosuggestions">https://github.com/zsh-users/zsh-autosuggestions</a><br>打开远程仓库：<a href="https://github.com/paulirish/git-open">https://github.com/paulirish/git-open</a></p><p>下载到指定目录后，编辑.zshrc文件如下，找到plugins字段：</p><pre class="line-numbers language-bash"><code class="language-bash">plugins<span class="token operator">=</span><span class="token punctuation">(</span>其他的插件 zsh-syntax-highlighting zsh-autosuggestions git-open autojump zsh-syntax-highlighting zsh-autosuggestions<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再<code>source ~/.zshrc</code>使配置生效</p><h3 id="安装xfce4"><a href="#安装xfce4" class="headerlink" title="安装xfce4"></a>安装xfce4</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update <span class="token comment" spellcheck="true">#更新软件源</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> xfce4-terminal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>配置</p><ul><li>在右下角的dash菜单栏中找到Xfce4终端；打开</li><li>在“编辑”—&gt;“首选项”—-&gt;“外观”—-&gt;”背景图片”选择你想设置的图片；</li><li>更多终端设置，自行探索；</li></ul><blockquote><p>  设置快捷键<br>  正常使用是我们按ctr(常用^表示)+Alt+T打开我们使用的终端；现在我们设置新终端的快捷方式；</p></blockquote><ul><li>在右上角–&gt;有线连接—-&gt;有线设置—-&gt;设备—&gt;键盘 将其选中</li><li>在键盘的最下面有个”+”加号；点击</li><li>然后输入：<br>名称：你想对快捷键设置的名字<br>命令：xfce4-terminal</li></ul><p>效果:</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502181409943.png" alt="image-20220502181409943"></p><hr><h2 id="三-软件生态"><a href="#三-软件生态" class="headerlink" title="三. 软件生态"></a>三. 软件生态</h2><h3 id="星火商店"><a href="#星火商店" class="headerlink" title="星火商店"></a>星火商店</h3><p>首先我们到官网下载星火商店以及依赖(20.04)：<a href="https://spark-app.store/">https://spark-app.store/</a></p><p>先安装依赖</p><p>然后再安装包</p><h3 id="deepin-wine"><a href="#deepin-wine" class="headerlink" title="deepin-wine"></a>deepin-wine</h3><p>可在星火商店下载</p><hr><h2 id="四-Dock栏优化"><a href="#四-Dock栏优化" class="headerlink" title="四. Dock栏优化"></a>四. Dock栏优化</h2><p>安装</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> dconf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>依次打开:</p><pre><code>/org/gnome/shell/extensions/dash-to-dock/</code></pre><p>个人配置:</p><pre class="line-numbers language-bash"><code class="language-bash">background-opacity 0  // 透明custom-background-color <span class="token boolean">true</span>customize-alphas <span class="token boolean">true</span>dock-fixed <span class="token boolean">true</span>dock-position <span class="token string">'BOTTOM'</span>extend-height <span class="token boolean">false</span>show-apps-at-top <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果:</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220502182034386.png" alt="image-20220502182034386"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Ubuntu美化教程&quot;&gt;&lt;a href=&quot;#Ubuntu美化教程&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu美化教程&quot;&gt;&lt;/a&gt;Ubuntu美化教程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  基于Ubuntu20.04.4LTS&lt;/p&gt;
</summary>
      
    
    
    
    <category term="美化教程" scheme="https://roranrui.cn/categories/%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="桌面美化" scheme="https://roranrui.cn/tags/%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/"/>
    
    <category term="经验分享" scheme="https://roranrui.cn/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>关于jetbrainsIDE的设置</title>
    <link href="https://roranrui.cn/2022/05/01/guan-yu-jetbrainside-de-gao-xiao-she-zhi/"/>
    <id>https://roranrui.cn/2022/05/01/guan-yu-jetbrainside-de-gao-xiao-she-zhi/</id>
    <published>2022-05-01T06:36:22.000Z</published>
    <updated>2022-05-01T13:33:42.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jetbrains-IDE设置"><a href="#jetbrains-IDE设置" class="headerlink" title="jetbrains IDE设置"></a>jetbrains IDE设置</h1><h2 id="一-美化"><a href="#一-美化" class="headerlink" title="一. 美化"></a>一. 美化</h2><h3 id="背景图像美化"><a href="#背景图像美化" class="headerlink" title="背景图像美化"></a>背景图像美化</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501143718297.png" alt="外观->背景图像"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501143841490.png" alt="效果"></p><h3 id="字体配色方案"><a href="#字体配色方案" class="headerlink" title="字体配色方案"></a>字体配色方案</h3><p><a href="https://github.com/topics/jetbrains-theme">指路</a></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501144625849.png" alt="编辑器->配色方案"></p><hr><h2 id="二-高效设置"><a href="#二-高效设置" class="headerlink" title="二. 高效设置"></a>二. 高效设置</h2><h3 id="调整窗口字体显示大小"><a href="#调整窗口字体显示大小" class="headerlink" title="调整窗口字体显示大小"></a>调整窗口字体显示大小</h3><p>巨好用的一个功能！强烈安利！</p><p>勾选上 <em>Preferences / Settings | Editor | General</em> 下的 <em>Change font size with Command + Mouse Wheel</em> 选项之后，我们就可以直接使用 <code>Ctrl+鼠标滚轮</code>(Windows&amp;Linux)来更改窗口字体的大小</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501145041883.png" alt="image-20220501145041883"></p><p>开启更改所有选项卡的字体大小功能</p><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>修改 <em>Preferences / Settings | Editor | Font</em> 选项下的字体设置，字体推荐使用 JetBrains Mono ，字体大小建议 16/18，根据个人需要选择是否需要开启连字。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501145148929.png" alt="image-20220501145148929"></p><h3 id="配置类注释模板"><a href="#配置类注释模板" class="headerlink" title="配置类注释模板"></a>配置类注释模板</h3><p>修改 <em>Preferences / Settings | Editor | File adn Code Templates</em> 下的 <code>Class</code> 和 <code>Enum</code> 的模板。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501150659503.png" alt="image-20220501150659503"></p><p>你可以根据自己的习惯对 IDEA 自带的编码模板进行修改，并且，你还可以添加新的编码模板来提高编码速度。非常实用！</p><h3 id="显示方法分割线"><a href="#显示方法分割线" class="headerlink" title="显示方法分割线"></a>显示方法分割线</h3><p>勾选上 <em>Preferences / Settings | Editor | General | Appearance</em> 下的 Show method separators 选项之后，方法分割线就有了，这会小幅提高代码的可读性。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501151302639.png" alt="image-20220501151302639"></p><hr><h2 id="三-插件推荐"><a href="#三-插件推荐" class="headerlink" title="三. 插件推荐"></a>三. 插件推荐</h2><p>在此仅推荐两个</p><h3 id="Tabnine：基于-AI-的代码提示"><a href="#Tabnine：基于-AI-的代码提示" class="headerlink" title="Tabnine：基于 AI 的代码提示"></a>Tabnine：基于 AI 的代码提示</h3><p>Tabnine 这个插件用于智能代码补全，它基于数百万 Java 程序，能够根据程序上下文提示补全代码。Tabnine 和 IDEA 自带的智能提示两者互补。</p><h3 id="Rainbow-Brackets-彩虹括号"><a href="#Rainbow-Brackets-彩虹括号" class="headerlink" title="Rainbow Brackets : 彩虹括号"></a>Rainbow Brackets : 彩虹括号</h3><p>使用各种鲜明的颜色来展示你的括号，效果图如下。可以看出代码层级变得更加清晰了，可以说非常实用友好了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jetbrains-IDE设置&quot;&gt;&lt;a href=&quot;#jetbrains-IDE设置&quot; class=&quot;headerlink&quot; title=&quot;jetbrains IDE设置&quot;&gt;&lt;/a&gt;jetbrains IDE设置&lt;/h1&gt;&lt;h2 id=&quot;一-美化&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="美化教程" scheme="https://roranrui.cn/categories/%E7%BE%8E%E5%8C%96%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="经验分享" scheme="https://roranrui.cn/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    <category term="IDE美化" scheme="https://roranrui.cn/tags/IDE%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程进阶</title>
    <link href="https://roranrui.cn/2022/05/01/cpp-duo-xian-cheng-jin-jie/"/>
    <id>https://roranrui.cn/2022/05/01/cpp-duo-xian-cheng-jin-jie/</id>
    <published>2022-05-01T05:24:50.000Z</published>
    <updated>2022-05-03T06:20:28.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程进阶"><a href="#多线程进阶" class="headerlink" title="多线程进阶"></a>多线程进阶</h1><h2 id="一-条件变量"><a href="#一-条件变量" class="headerlink" title="一. 条件变量"></a>一. 条件变量</h2><blockquote><p>  重复加锁, 影响效率, 可通过双重锁定的方式, 减少加锁, 提升效率</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">IsoutMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 双重锁定, 提升效率</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">ulock1</span><span class="token punctuation">(</span>mtx1<span class="token punctuation">)</span><span class="token punctuation">;</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">ulock2</span><span class="token punctuation">(</span>mtx2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                cout <span class="token operator">&lt;&lt;</span> <span class="token string">"删除元素 "</span> <span class="token operator">&lt;&lt;</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>                msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                mtx1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                mtx2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本方法仍不够完美, 以下给出更优的解决办法</p><h3 id="1-condition-variable"><a href="#1-condition-variable" class="headerlink" title="1. condition_variable"></a>1. condition_variable</h3><blockquote><p>  std::condition_variable实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">outMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> command <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">ulock1</span><span class="token punctuation">(</span>mtx1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果第二个参数lambda表达式返回值是false, 那么wait()将解锁互斥量, 并堵塞本行</span>            <span class="token comment" spellcheck="true">// 直到其他线程调用notify_one()为止</span>            my_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>ulock1<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            command <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ulock1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"删除元素 "</span> <span class="token operator">&lt;&lt;</span> command <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"END"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>wait()用来等一个东西</p><p>如果第二个参数的lambda表达式返回值是false，那么wait()将解锁互斥量，并阻塞到本行<br>如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行。</p><p>阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止；</p><p>如果没有第二个参数，那么效果跟第二个参数lambda表达式返回false效果一样</p><p>wait()将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用notify_one()成员函数为止。</p><p>当其他线程用<code>notify_one()</code>将本线程wait()唤醒后，这个wait恢复后</p><ol><li><p>wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待获取，如果获取到了，那么wait()就继续执行，获取到了锁</p></li><li><p>如果wait有第二个参数就判断这个lambda表达式。</p><p>a)如果表达式为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify_one()唤醒<br>b)如果lambda表达式为true，则wait返回，流程可以继续执行（此时互斥量已被锁住）。</p></li><li><p>如果wait没有第二个参数，则wait返回，流程走下去。</p></li></ol><blockquote><p>  <strong>流程只要走到了wait()下面则互斥量一定被锁住了。</strong></p></blockquote><p>完整代码:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Msg "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" got."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">myGuard</span><span class="token punctuation">(</span>mtx1<span class="token punctuation">,</span> adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//            lock(mtx1, mtx2);</span>            msgRecvQueue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            my_cond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//            mtx1.unlock();</span><span class="token comment" spellcheck="true">//            mtx2.unlock();</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">outMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> command <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">ulock1</span><span class="token punctuation">(</span>mtx1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果第二个参数lambda表达式返回值是false, 那么wait()将解锁互斥量, 并堵塞本行</span>            <span class="token comment" spellcheck="true">// 直到其他线程调用notify_one()为止</span>            my_cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>ulock1<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            command <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ulock1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"删除元素 "</span> <span class="token operator">&lt;&lt;</span> command <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"END"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> msgRecvQueue<span class="token punctuation">;</span>    mutex mtx1<span class="token punctuation">;</span>    mutex mtx2<span class="token punctuation">;</span>    condition_variable my_cond<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 生成一个条件变量对象</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    A my_a<span class="token punctuation">;</span>    thread <span class="token function">ts1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>outMsg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>my_a<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">ts2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>getMsg<span class="token punctuation">,</span> <span class="token operator">&amp;</span>my_a<span class="token punctuation">)</span><span class="token punctuation">;</span>    ts1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ts2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、深入思考</p><p>上面的代码可能导致出现一种情况：<br>因为outMsg()与getMsg()并不是一对一执行的，所以当程序循环执行很多次以后，可能在msgRecvQueue 中已经有了很多消息，但是，outMsg()还是被唤醒一次只处理一条数据。这时可以考虑把outMsg()多执行几次，或者对getMsg()进行限流。</p><h4 id="notify-all"><a href="#notify-all" class="headerlink" title="notify_all()"></a>notify_all()</h4><blockquote><p>  notify_one()：通知一个线程的wait()</p><p>  notify_all()：通知所有线程的wait()</p></blockquote><h2 id="二-创建后台任务并返回值"><a href="#二-创建后台任务并返回值" class="headerlink" title="二. 创建后台任务并返回值"></a>二. 创建后台任务并返回值</h2><h3 id="std-asyncstd-future"><a href="#std-asyncstd-future" class="headerlink" title="std::asyncstd::future"></a>std::asyncstd::future</h3><p><strong>std::async</strong>是一个函数模板，用来启动一个异步任务，启动起来一个异步任务之后，它返回一个<strong>std::future</strong>对象，这个对象是个类模板。</p><p>异步任务的定义:</p><blockquote><p>  启动一个异步任务就是自动创建一个线程，并开始 执行对应的线程入口函数，它返回一个std::future对象，这个std::future对象中就含有线程入口函数所返回的结果，我们可以通过调用future对象的成员函数get()来获取结果。</p></blockquote><p>“future”将来的意思，也有人称呼std::future提供了一种访问异步操作结果的机制，就是说这个结果你可能没办法马上拿到，但是在不久的将来，这个线程执行完毕的时候，你就能够拿到结果了，所以，大家这么理解：future中保存着一个值，这个值是在将来的某个时刻能够拿到。</p><ul><li><p>std::future对象的get()成员函数会等待线程执行结束并返回结果，拿不到结果它就会一直等待，感觉有点像join()。但是，它是可以获取结果的。</p></li><li><p>std::future对象的wait()成员函数，用于等待线程返回，本身并不返回结果，这个效果和 std::thread 的join()更像。</p></li></ul><p>使用get()返回:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;future></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5s</span>    this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread finished"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main thread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// get()获取返回值</span>    cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  get()只能调用一次!!!!</p></blockquote><hr><h3 id="std-launch类型（枚举类型）"><a href="#std-launch类型（枚举类型）" class="headerlink" title="std::launch类型（枚举类型）"></a>std::launch类型（枚举类型）</h3><p>我们通过向std::async()传递一个参数，该参数是std::launch类型（枚举类型），来达到一些特殊的目的：</p><ol><li><strong>std::lunch::deferred：</strong><br>（defer推迟，延期）表示线程入口函数的调用会被延迟，一直到std::future的wait()或者get()函数被调用时（由主线程调用）才会执行；如果wait()或者get()没有被调用，则不会执行。<br>实际上根本就没有创建新线程。std::launch::deferred意思时延迟调用，并没有创建新线程，是在主线程中调用的线程入口函数。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp">main thread startedthread id<span class="token operator">:</span> <span class="token number">1</span>num<span class="token operator">:</span> <span class="token number">230</span>mythread startedthread id<span class="token operator">:</span> <span class="token number">1</span>mythread finishedthread id<span class="token operator">:</span> <span class="token number">1</span><span class="token number">5</span><span class="token keyword">continue</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p><strong>std::launch::async</strong>:</p><p>在调用async函数的时候就开始创建新线程。</p></li></ol><pre class="line-numbers language-cpp"><code class="language-cpp">main thread startedthread id<span class="token operator">:</span> <span class="token number">1</span><span class="token keyword">continue</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>num<span class="token operator">:</span> <span class="token number">230</span>mythread startedthread id<span class="token operator">:</span> <span class="token number">2</span>mythread finishedthread id<span class="token operator">:</span> <span class="token number">2</span><span class="token number">5</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h3><blockquote><p>  <strong>std::packaged_task：打包任务，把任务包装起来。</strong></p></blockquote><p>类模板，它的模板参数是各种可调用对象，通过packaged_task把各种可调用对象包装起来，方便将来作为线程入口函数来调用。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">230</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main thread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">mypt</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token function">ref</span><span class="token punctuation">(</span>mypt<span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// res 保存mypt将要返回的值</span>    future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res <span class="token operator">=</span> mypt<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"continue..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// get()获取返回值</span>    cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// wait()不返回结果</span><span class="token comment" spellcheck="true">//    res.wait();</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  packaged_task包装起来的可调用对象还可以直接调用，从这个角度来讲，packaged_task对象也是一个可调用对象</p></blockquote><p><strong>lambda的直接调用:</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token number">230</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main thread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">mypt</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread started"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 5s</span>        this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread finished"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\tthread id: "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">t1</span><span class="token punctuation">(</span><span class="token function">ref</span><span class="token punctuation">(</span>mypt<span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// res 保存mypt将要返回的值</span>    future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res <span class="token operator">=</span> mypt<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"continue..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// get()获取返回值</span>    cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/// wait()不返回结果</span><span class="token comment" spellcheck="true">//    res.wait();</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a>std::promise</h3><blockquote><p>  <em>std::promise，类模板</em><br>  我们能够在某个线程中给它赋值，然后我们可以在其他线程中，把这个值取出来</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;future></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">mythread</span><span class="token punctuation">(</span>std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">,</span> <span class="token keyword">int</span> clac<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread() start"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"threadid = "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread() end"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"threadid = "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> clac<span class="token punctuation">;</span>    tmp<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//结果保存到了tmp这个对象中</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span> vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span> task_vec<span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> myprom<span class="token punctuation">;</span>    std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>mythread<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>myprom<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在这里线程已经执行完了</span>    std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> fu1 <span class="token operator">=</span> myprom<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//promise和future绑定，用于获取线程返回值</span>    <span class="token keyword">auto</span> result <span class="token operator">=</span> fu1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"result = "</span> <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程进阶&quot;&gt;&lt;a href=&quot;#多线程进阶&quot; class=&quot;headerlink&quot; title=&quot;多线程进阶&quot;&gt;&lt;/a&gt;多线程进阶&lt;/h1&gt;&lt;h2 id=&quot;一-条件变量&quot;&gt;&lt;a href=&quot;#一-条件变量&quot; class=&quot;headerlink&quot; title=&quot;一</summary>
      
    
    
    
    <category term="语言学习" scheme="https://roranrui.cn/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>第八天_动态规划（简单）</title>
    <link href="https://roranrui.cn/2022/05/01/shua-ti-bi-ji-ba/"/>
    <id>https://roranrui.cn/2022/05/01/shua-ti-bi-ji-ba/</id>
    <published>2022-05-01T02:14:35.000Z</published>
    <updated>2022-05-01T03:50:09.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八天-动态规划（简单）"><a href="#第八天-动态规划（简单）" class="headerlink" title="第八天_动态规划（简单）"></a>第八天_动态规划（简单）</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote><p>  动态规划是算法与数据结构的重难点之一，其包含了「分治思想」、「空间换时间」、「最优解」等多种基石算法思想</p></blockquote><p><strong>动态规划特点</strong><br>「分治」是算法中的一种基本思想，其通过将<strong>原问题分解为子问题</strong>，不断递归地将子问题分解为更小的子问题，并通过<strong>组合子问题的解</strong>来得到原问题的解。</p><p>类似于分治算法，「动态规划」也通过组合子问题的解得到原问题的解。不同的是，适合用动态规划解决的问题具有「重叠子问题」和「最优子结构」两大特性。</p><p><strong>重叠子问题</strong><br>动态规划的子问题是有重叠的，即各个子问题中包含重复的更小子问题。若使用暴力法穷举，求解这些相同子问题会产生大量的重复计算，效率低下。</p><h4 id="重叠子问题示例：斐波那契数列"><a href="#重叠子问题示例：斐波那契数列" class="headerlink" title="重叠子问题示例：斐波那契数列"></a><strong>重叠子问题示例：斐波那契数列</strong></h4><blockquote><p>  斐波那契数形成的数列为 [0,1,1,2,3,5,8,13,⋯] ，数学定义如下：</p><p>  F_0 = 0  </p><p>  F_1 = 1 </p><p>  F_n = F{n-1} + F{n-2} </p></blockquote><p><strong>解题思路:</strong></p><p><strong>1.暴力递归</strong></p><p>设斐波那契数列第 n 个数字为 f(n) 。根据数列定义，可得 f(n) = f(n - 1) + f(n - 2)，且第 0 , 1 个斐波那契数分别为 f(0) = 0, f(1) = 1 。</p><p>我们很容易联想到使用分治思想来求取 f(n)f(n) ，即将求原问题 f(n) 分解为求子问题 f(n-1)和 f(n-2)，向下递归直至已知的 f(0) 和 f(1) ，最终组合这些子问题求取原问题 f(n)</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 f(0)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回 f(1)</span>    <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 分解为两个子问题求解</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 超时</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1635075778-GADtbi-Picture1.png" alt="Picture1.png"></p><p>如上图所示，为暴力递归求斐波那契数 f(5)形成的二叉树，树中的每个节点代表着执行了一次 fibonacci() 函数，且有：</p><ul><li>执行一次 fibonacci() 函数的时间复杂度为 O(1) ；</li></ul><p>二叉树节点数为指数级 O(2^n)<br>因此，暴力递归的总体时间复杂度为 O(2^n) 。此方法效率低下，随着 nn的增长产生指数级爆炸。</p><p><strong>2.记忆化递归</strong></p><p>观察发现，暴力递归中的子问题多数都是重叠子问题，即：</p><blockquote><p>  f(n)=f(n−1)+f(n−2)<br>  f(n−1)=f(n−2)+f(n−3)<br>  f(n−2)=f(n−3)+f(n−4)<br>  ⋯<br>  以此类推</p></blockquote><p>这些重叠子问题产生了大量的递归树节点，其不应被重复计算。实际上，可以在递归中第一次求解子问题时，就将它们保存；后续递归中再次遇到相同子问题时，直接访问内存赋值即可。</p><pre><code>int fibonacci(int n, vector&lt;int&gt; dp) {    if (n == 0) return 0;           // 返回 f(0)    if (n == 1) return 1;           // 返回 f(1)    if (dp[n] != 0) return dp[n];   // 若 f(n) 以前已经计算过，则直接返回记录的解    dp[n] = fibonacci(n - 1, dp) + fibonacci(n - 2, dp); // 将 f(n) 则记录至 dp    return dp[n];}// 求第 n 个斐波那契数int fibonacciMemorized(int n) {    vector&lt;int&gt; dp(n + 1, 0); // 用于保存 f(0) 至 f(n) 问题的解    return fibonacci(n, dp);}</code></pre><p>如下图所示，应用记忆化递归方法后，递归树中绝大部分节点被剪枝。此时，fibonacci() 函数的调用次数从 O(2^n)指数级别降低至 O(n) 线性级别，时间复杂度大大降低。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1635075778-pJXkPc-Picture2.png" alt="Picture2.png"></p><p>3.动态规划</p><p>递归本质上是基于分治思想的从顶至底的解法。借助记忆化递归思想，可应用动态规划从底至顶求取 f(n)，代码如下所示。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 求第 n 个斐波那契数</span><span class="token keyword">int</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 若求 f(0) 则直接返回 0</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 初始化 dp 列表</span>    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 初始化 f(0), f(1)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 状态转移求取 f(2), f(3), ..., f(n) </span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 返回 f(n)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>动态规划在第一次求解某子问题时，会将子问题的解保存；后续遇到重叠子问题时，则直接通过查表获取解，保证每个<strong>独立子问题只被计算一次</strong>，从而降低算法的时间复杂度。</p><hr><p><strong>最优子结构</strong><br>如果一个问题的最优解可以由其子问题的最优解组合构成，并且这些子问题可以独立求解，那么称此问题具有最优子结构。</p><p>动态规划从基础问题的解开始，不断迭代<strong>组合、选择子问题的最优解</strong>，最终得到原问题最优解。</p><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1. 斐波那契数列"></a>1. 斐波那契数列</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501102703899.png" alt="image-20220501102703899"></p><p>解题思路:</p><p>采用<strong>动态规划</strong></p><p>循环求余法：<br>大数越界： 随着 n 增大, f(n) 会超过 Int32 甚至 Int64 的取值范围，导致最终的返回值错误。</p><p>求余运算规则： 设正整数 x, y, p，求余符号为⊙ ，则有 (x+y)⊙p=(x⊙p+y⊙p)⊙p 。</p><p>解析： 根据以上规则，可推出f(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙p ，从而可以在循环过程中每次计算 sum=(a+b)⊙1000000007 ，此操作与最终返回前取余等价。</p><p>复杂度分析：</p><p>时间复杂度 O(n) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。<br>空间复杂度 O(N) ： 数组dp使用N的空间;</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 若求 f(0) 则直接返回 0</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 初始化 dp 列表</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 初始化 f(0), f(1)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 状态转移求取 f(2), f(3), ..., f(n) </span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501110203286.png" alt="image-20220501110203286"></p><p><strong>空间内存优化版本:</strong></p><p>空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> sum<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sum <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>            a <span class="token operator">=</span> b<span class="token punctuation">;</span>            b <span class="token operator">=</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501110420369.png" alt="image-20220501110420369"></p><hr><h3 id="2-青蛙跳台阶问题"><a href="#2-青蛙跳台阶问题" class="headerlink" title="2. 青蛙跳台阶问题"></a>2. 青蛙跳台阶问题</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501110605583.png" alt="image-20220501110605583"></p><p><strong>解题思路:</strong><br>设跳上 n 级台阶有 f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2 级台阶。</p><p>当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n-1) 种跳法；<br>当为 2 级台阶： 剩 n-2 个台阶，此情况共有 f(n-2)种跳法。</p><p>由此, 可转化为<strong>斐波那契数列问题</strong></p><blockquote><p>  区别:</p><ul><li>青蛙跳台阶问题： f(0)=1 f(1)=1 , f(2)=2 ；</li><li>斐波那契数列问题： f(0)=0 , f(1)=1 , f(2)=1 。</li></ul></blockquote><p>复杂度分析：</p><p>时间复杂度 O(n) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。<br>空间复杂度 O(N) ： 数组dp使用N的空间;</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599883153-UckfTw-Picture1.png" alt="Picture1.png"></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numWays</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501114501605.png" alt="image-20220501114501605"></p><p><strong>空间内存优化版本:</strong></p><p>空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">numWays</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> sum<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sum <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>            a <span class="token operator">=</span> b<span class="token punctuation">;</span>            b <span class="token operator">=</span> sum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-股票的最大利润"><a href="#3-股票的最大利润" class="headerlink" title="3. 股票的最大利润"></a>3. 股票的最大利润</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501111755367.png" alt="image-20220501111755367"></p><p><strong>解题思路:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501112220955.png" alt="image-20220501112220955"></p><blockquote><p>  动态规划解析：</p><p>  状态定义： 设动态规划列表 dp ，dp[i]代表以 prices[i]为结尾的子数组的最大利润（以下简称为 前 i 日的最大利润 ）。<br>  转移方程： 由于题目限定 “买卖该股票一次” ，因此前 i日最大利润 dp[i]等于前 i - 1日最大利润 dp[i-1] 和第 i日卖出的最大利润中的最大值。<br>  dp[i] = max(dp[i - 1], prices[i] - min(prices[0:i])) </p><p>  前 i 日最大利润 = max(前 (i-1) 日最大利润, 第 i 日价格 - 前 i 日最低价格)</p><p>  初始状态： dp[0] = 0，即首日利润为 0 ；<br>  返回值： dp[n - 1]，其中 n 为 dp列表长度。</p></blockquote><p>复杂度分析：</p><p>时间复杂度 O(n) ： 计算 f(n) 需循环 n 次，每轮循环内计算操作使用 O(1) 。<br>空间复杂度 O(N) ： 数组dp使用N的空间;</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 只有1天怎么买卖?</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> dp<span class="token punctuation">;</span>        dp<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> cost <span class="token operator">=</span> prices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            cost <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>cost<span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>prices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501114517412.png" alt="image-20220501114517412"></p><p><strong>空间内存优化版本:</strong></p><p>空间复杂度 O(1) ： 几个标志变量使用常数大小的额外空间。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cost <span class="token operator">=</span> INT_MAX<span class="token punctuation">,</span> profit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> price <span class="token operator">:</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cost <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>cost<span class="token punctuation">,</span> price<span class="token punctuation">)</span><span class="token punctuation">;</span>            profit <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>profit<span class="token punctuation">,</span> price <span class="token operator">-</span> cost<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> profit<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220501114529197.png" alt="image-20220501114529197"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第八天-动态规划（简单）&quot;&gt;&lt;a href=&quot;#第八天-动态规划（简单）&quot; class=&quot;headerlink&quot; title=&quot;第八天_动态规划（简单）&quot;&gt;&lt;/a&gt;第八天_动态规划（简单）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第七天_搜索与回溯算法（简单）</title>
    <link href="https://roranrui.cn/2022/04/30/shua-ti-bi-ji-qi/"/>
    <id>https://roranrui.cn/2022/04/30/shua-ti-bi-ji-qi/</id>
    <published>2022-04-30T07:09:52.000Z</published>
    <updated>2022-04-30T09:21:07.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七天-搜索与回溯算法（简单）"><a href="#第七天-搜索与回溯算法（简单）" class="headerlink" title="第七天_搜索与回溯算法（简单）"></a>第七天_搜索与回溯算法（简单）</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><blockquote><p>  <strong>深度优先搜索算法</strong>（Depth First Search，简称<a href="https://so.csdn.net/so/search?q=DFS&amp;spm=1001.2101.3001.7020">DFS</a>）：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况算法时间复杂度为O(N!)。</p><p>  <strong>所谓DFS就是指：优先考虑深度，换句话说就是一条路走到黑，直到无路可走的情况下，才会选择回头，然后重新选择一条路</strong></p></blockquote><p>例子:</p><p>全排列: 输入一个数n，输出n的全排列</p><p>假如有编号为1,2,3的3张扑克牌和编号为1,2,3的3个盒子。将这3张扑克牌分别放入3个盒子一共有几种不同的放法呢？</p><p>约定：每次到一个盒子面前时，都先放1号，2号，最后放3号</p><p><strong>1.第一种：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20200815181435796.png" alt="首先呢，小明手中有3张扑克牌"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20200815181540751.png" alt="先到第1个盒子，将1号扑克牌放在第1个盒子。"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20200815181625696.png" alt="放好后，小明继续向前走一步，来到了2号盒子，按照之前的约定放2号扑克牌。"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20200815181745240.png" alt="放好后，小明又继续向前一步，把3号扑克牌放入3号盒子。此时就已经完成了一种排列。"></p><p>完成第一种后,还没有结束！小明便要回头了，开始重新选择（DFS的思想），这里要注意的，不是把所有的牌都取出来重新放，这样就不符合<strong>DFS</strong>的思想了。</p><p><strong>2.第2种</strong><br>好的！按照上面的逻辑。小明将3号盒子的3号扑克牌取出，但手上仍然只有3号扑克牌。<br>所以小明只好回到2号盒子，收回2号扑克牌，此时手中有2,3号扑克牌。<br>按照之前的约定，往2号盒子放3号扑克牌，然后小明又继续往前走，此时手里只有2号扑克牌，把2号扑克牌放入3号盒子里，此时完成了第二种排序。*<br>按照这种逻辑，我们不难求出所有排列“123”，“132”，“213”，“231”，“312”，“321”;</p><blockquote><p>  BFS是按照层来遍历，“ 如果你愿意一层一层一层的剥开我的心”对！就像洋葱，一层层地遍历。那还有其他的遍历方式吗？当然还有，就是<strong>递归遍历</strong></p></blockquote><p><strong>DFS—深度优先遍历</strong><br>二叉树的深度优先遍历方式有三个：</p><ul><li>前序遍历<br>PreOrder(T) = T的根结点+PreOrder（T的左子树）+PreOrder（T的右子树）</li><li>-中序遍历<br>InOrder(T) = InOrder（T的左子树）+ T的根结点 + InOrder（T的右子树）</li><li>-后序遍历<br>PostOrder(T) =PostOrder（T的左子树）+ PostOrder（T的右子树）+ T的根结点</li></ul><p><strong>可见这些遍历的方式都运用了递归的方式。</strong></p><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">LeetCode144. 二叉树的前序遍历链接入口</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">LeetCode94. 二叉树的中序遍历链接入口</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">LeetCode145. 二叉树的后序遍历链接入口</a></p><h3 id="二叉树镜像"><a href="#二叉树镜像" class="headerlink" title="二叉树镜像"></a><strong>二叉树镜像</strong></h3><blockquote><p>  二叉树镜像定义： 对于二叉树中任意节点 root，设其左 / 右子节点分别为 left, right；则在二叉树的镜像中的对应 root节点，其左 / 右子节点分别为 right, left。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20717714d97fa04d509e4f0525a3089efefc2ea02cc08ce92b77978e9b51f15f-Picture1.png" alt="Picture1.png"></p><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><blockquote><p>  <strong>对称二叉树定义：</strong> 对于树中 任意两个对称节点 L 和 R ，一定有：</p><p>  L.val = R.val ：即此两对称节点值相等。<br>  L.left.val = R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；<br>  L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599398062-PbkpuX-Picture1.png" alt="Picture1.png"></p><hr><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-树的子结构"><a href="#1-树的子结构" class="headerlink" title="1. 树的子结构"></a>1. 树的子结构</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430155705066.png" alt="image-20220430155705066"></p><p><strong>解题思路:</strong></p><p>若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p><p>先序遍历树 A 中的每个节点 n_A；（对应函数 <code>isSubStructure(A, B)</code>）<br>判断树<strong>以 n_A为根节点的子树</strong> 是否包含树 <code>B</code> 。（对应函数 <code>recur(A, B)</code>）</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599290566-VhWsiQ-Picture1.png" alt="Picture1.png"></p><blockquote><p>  <strong>算法流程：</strong></p><p>  recur(A, B) 函数：</p><ol><li>终止条件：<ol><li>当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回 true ；</li><li>当节点 A 为空：说明已经越过树 A 的叶节点，即匹配失败，返回 false ；</li><li>当节点 A 和 B 的值不同：说明匹配失败，返回 false ；</li></ol></li><li>返回值：<ol><li>判断 A 和 B 的 左子节点 是否相等，即 recur(A.left, B.left) ；</li><li>判断 A 和 B 的 右子节点 是否相等，即 recur(A.right, B.right) ；</li></ol></li></ol><p>  isSubStructure(A, B) 函数：</p><ol><li>特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false ；</li><li>返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 || 连接；<ol><li>以 节点 A 为根节点的子树 包含树 B ，对应 recur(A, B)；</li><li>树 B 是 树 A 左子树 的子结构，对应 isSubStructure(A.left, B)；</li><li>树 B 是 树 A 右子树 的子结构，对应 isSubStructure(A.right, B)；</li></ol></li></ol><blockquote><p>  以上 2. 3. 实质上是在对树 A 做 先序遍历 。</p></blockquote></blockquote><p><strong>复杂度分析：</strong><br>时间复杂度 O(MN) ： 其中 M, N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N) 。<br>空间复杂度 O(M) ： 当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M&gt;N时，最差情况为遍历至树 A 的叶节点，此时总递归深度为 M。</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> A<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> B<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>A <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> B <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>A<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubStructure</span><span class="token punctuation">(</span>A<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">recur</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> A<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> B<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>B <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>A <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> A<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">!=</span> B<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// return (A->left == B->left &amp;&amp; A->right == B->right) ? true : false;</span>        <span class="token comment" spellcheck="true">// 以下是高级写法</span>        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>A<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> B<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">recur</span><span class="token punctuation">(</span>A<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> B<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430162344187.png" alt="image-20220430162344187"></p><hr><h3 id="2-二叉树的镜像"><a href="#2-二叉树的镜像" class="headerlink" title="2. 二叉树的镜像"></a>2. 二叉树的镜像</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430162543617.png" alt="image-20220430162543617"></p><p><strong>解题思路:</strong></p><p><strong>1.递归法</strong></p><ul><li>根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 / 右子节点，即可生成二叉树的镜像。</li></ul><blockquote><p>  递归解析：</p><ol><li>终止条件： 当节点 root为空时（即越过叶节点），则返回 null；</li><li>递推工作：<ol><li>初始化节点 tmp，用于暂存 root的左子节点；</li><li>开启递归 右子节点 mirrorTree(root.right)，并将返回值作为 root的 左子节点 。</li><li>开启递归 左子节点 mirrorTree(tmp)，并将返回值作为 root的 右子节点 。</li></ol></li><li>返回值： 返回当前节点 root；</li></ol><blockquote><p>  Q： 为何需要暂存 root 的左子节点？<br>  A： 在递归右子节点 “root.left = mirrorTree(root.right);” 执行完毕后， root.left 的值已经发生改变，此时递归左子节点 mirrorTree(root.left)则会出问题。</p></blockquote></blockquote><p>复杂度分析：<br>时间复杂度 O(N)： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N)时间。<br>空间复杂度 O(N)： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(N)大小的栈空间。</p><p><strong>2.辅助栈（或队列）</strong></p><ul><li>利用栈（或队列）遍历树的所有节点 node，并交换每个 node的左 / 右子节点。</li></ul><blockquote><p>  <strong>算法流程：</strong></p><ol><li>特例处理： 当 root 为空时，直接返回 null ；</li><li>初始化： 栈（或队列），本文用栈，并加入根节点 root 。</li><li>循环交换： 当栈 stack 为空时跳出；<ol><li>出栈： 记为 node；</li><li>添加子节点： 将 node 左和右子节点入栈；</li><li>交换： 交换 node 的左 / 右子节点。</li></ol></li><li>返回值： 返回根节点 root 。</li></ol></blockquote><p>复杂度分析：<br>时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。<br>空间复杂度 O(N) ： 如下图所示，最差情况下，栈 stack 最多同时存储 (N+1)/2个节点，占用 O(N)额外空间。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1614450330-bTAcyj-Picture0.png" alt="Picture0.png"></p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">*</span> temp <span class="token operator">=</span> root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430165722375.png" alt="image-20220430165722375"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    TreeNode<span class="token operator">*</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>        stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span> <span class="token operator">></span> stk<span class="token punctuation">;</span>        stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stk<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> stk<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stk<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> stk<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            TreeNode<span class="token operator">*</span> temp <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">;</span>            node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">;</span>            node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430170935957.png" alt="image-20220430170935957"></p><hr><h3 id="3-对称的二叉树"><a href="#3-对称的二叉树" class="headerlink" title="3. 对称的二叉树"></a>3. 对称的二叉树</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430171015514.png" alt="image-20220430171015514"></p><p><strong>解题思路:</strong></p><p>根据对称二叉树的规律，考虑从顶至底递归，判断每对左右节点是否对称，从而判断树是否为对称二叉树。</p><blockquote><p>  算法流程：<br>  isSymmetric(root) ：</p><ul><li>特例处理： 若根节点 root 为空，则直接返回 true 。</li><li>返回值： 即 recur(root.left, root.right) ;</li></ul><p>  recur(L, R) ：</p><ul><li>终止条件：<ul><li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li><li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；</li><li>当节点 L 值 != 节点 R 值： 此树不对称，因此返回 false ；</li></ul></li><li>递推工作：<ul><li>判断两节点 L.left 和 R.right 是否对称，即 recur(L.left, R.right) ；</li><li>判断两节点 L.right 和 R.left 是否对称，即 recur(L.right, R.left) ；</li></ul></li><li>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp;&amp; 连接。</li></ul></blockquote><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> root<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">recur</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> L<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> R<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> R <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> R <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> L<span class="token operator">-</span><span class="token operator">></span>val <span class="token operator">!=</span> R<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>L<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">,</span> R<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">recur</span><span class="token punctuation">(</span>L<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">,</span> R<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220430172100882.png" alt="image-20220430172100882"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第七天-搜索与回溯算法（简单）&quot;&gt;&lt;a href=&quot;#第七天-搜索与回溯算法（简单）&quot; class=&quot;headerlink&quot; title=&quot;第七天_搜索与回溯算法（简单）&quot;&gt;&lt;/a&gt;第七天_搜索与回溯算法（简单）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第六天_搜索与回溯算法（简单）</title>
    <link href="https://roranrui.cn/2022/04/29/shua-ti-bi-ji-liu/"/>
    <id>https://roranrui.cn/2022/04/29/shua-ti-bi-ji-liu/</id>
    <published>2022-04-29T12:11:27.000Z</published>
    <updated>2022-04-30T08:53:15.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六天-搜索与回溯算法（简单）"><a href="#第六天-搜索与回溯算法（简单）" class="headerlink" title="第六天_搜索与回溯算法（简单）"></a>第六天_搜索与回溯算法（简单）</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><blockquote><p>  广度优先搜索算法（Breadth-First Search，BFS）是一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。BFS并不使用经验法则算法。</p></blockquote><p>广度优先搜索让你能够找出两样东西之间的最短距离，不过最短距离的含义有很多！使用广度优先搜索可以：</p><ol><li>编写国际跳棋AI，计算最少走多少步就可获胜；</li><li>编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词，如将READED改为READER需要编辑一个地方；</li><li>根据你的人际关系网络找到关系最近的医生。</li></ol><p>你经常要找出最短路径，这可能是前往朋友家的最短路径，也可能是国际象棋中把对方将死的最少步数。解决最短路径问题的算法被称为<strong>广度优先搜索</strong>。要确定如何从双子峰前往金门大桥，需要两个步骤。</p><ol><li>使用图来建立问题模型。</li><li>使用广度优先搜索解决问题。</li></ol><blockquote><p>  例子:<br>  假设你经营着一个芒果农场，需要寻找芒果销售商，以便将芒果卖给他。在Facebook，你与芒果销售商有联系吗？为此，你可在朋友中查找。</p><p>  <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20190425130541285.png" alt="img"></p><p>  这种查找很简单。首先，创建一个朋友名单。</p><p>  <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20190425130557936.png"></p><p>   然后，依次检查名单中的每个人，看看他是否是芒果销售商。</p><p>  <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20190425130627134.png" alt="img"></p><p>   假设你没有朋友是芒果销售商，那么你就必须在朋友的朋友中查找。</p><p>  <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20190425130708732.png" alt="img"></p><p>   检查名单中的每个人时，你都将其朋友加入名单。</p><p>  <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/20190425130746766.png" alt="img"></p><p>   这样一来，你不仅在朋友中查找，还在朋友的朋友中查找。别忘了，你的目标是在你的人际关系网中找到一位芒果销售商。因此，如果Alice不是芒果销售商，就将其朋友也加入到名单中。这意味着你将在她的朋友、朋友的朋友等中查找。使用这种算法将搜遍你的整个人际关系网，直到找到芒果销售商。这就是广度优先搜索算法。</p></blockquote><hr><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-从上到下打印二叉树"><a href="#1-从上到下打印二叉树" class="headerlink" title="1. 从上到下打印二叉树"></a>1. 从上到下打印二叉树</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429203424978.png" alt="image-20220429203424978"></p><p><strong>解题思路</strong>：</p><p>题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。<br>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/a872b50fa42011748437ec9123d8f77a104b3d528880efca8b212f91d115f835-Picture1.png" alt="Picture1.png"></p><blockquote><p>  <strong>算法流程：</strong><br>  特例处理： 当树的根节点为空，则直接返回空列表 [] ；<br>  初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；<br>  BFS 循环： 当队列 queue 为空时跳出；<br>  出队： 队首元素出队，记为 node；<br>  打印： 将 node.val 添加至列表 tmp 尾部；<br>  添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；<br>  返回值： 返回打印结果列表 res 即可。</p></blockquote><p><strong>复杂度分析：</strong><br>时间复杂度 O(N)： N 为二叉树的节点数量，即 BFS 需循环 N次。<br>空间复杂度 O(N) ： 最差情况下，即当树为平衡二叉树时，最多有 N/2 个树节点同时在 queue 中，使用 O(N)大小的额外空间。</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429205407937.png" alt="image-20220429205407937"></p><hr><h3 id="2-从上到下打印二叉树-II"><a href="#2-从上到下打印二叉树-II" class="headerlink" title="2. 从上到下打印二叉树 II"></a>2. 从上到下打印二叉树 II</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429205019586.png" alt="image-20220429205019586"></p><p><strong>解题思路:</strong></p><p>本题与上一题仅有微小区别: 即本题需将 <strong>每一层打印到一行</strong> 。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/a58477c74c96779c265ce3028def7625d16042895d2c21f7fb0293df7b213276-Picture1.png" alt="Picture1.png"></p><p><strong>每层打印到一行：</strong> 将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</p><blockquote><p>  算法流程：<br>  特例处理： 当根节点为空，则返回空列表 [] ；<br>  初始化： 打印结果列表 res = [] ，包含根节点的队列 queue = [root] ；<br>  BFS 循环： 当队列 queue 为空时跳出；<br>  新建一个临时列表 tmp ，用于存储当前层打印结果；<br>  当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）；<br>  出队： 队首元素出队，记为 node；<br>  打印： 将 node.val 添加至 tmp 尾部；<br>  添加子节点： 若 node 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；<br>  将当前层结果 tmp 添加入 res 。</p><p>  <strong>返回值：</strong> 返回打印结果列表 <code>res</code> 即可。</p></blockquote><p>复杂度分析：<br>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次。<br>空间复杂度 O(N) ： 最差情况下，即当树为平衡二叉树时，最多有 N/2个树节点同时在 queue 中，使用 O(N)大小的额外空间。</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> que<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> temp<span class="token punctuation">;</span>        que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>que<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                TreeNode<span class="token operator">*</span> node <span class="token operator">=</span> que<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                que<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                temp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> que<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            temp<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> temp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  如果写成for(int i = 0;i&lt;queue.size();i++),则每次进行for循环时，条件判断都会算一下queue.size()，但是每次for循环后queue长度可能会发生变化（添加左右节点），queue.size()一直在变化；</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429210627203.png" alt="image-20220429210627203"></p><hr><h3 id="3-从上到下打印二叉树-III"><a href="#3-从上到下打印二叉树-III" class="headerlink" title="3. 从上到下打印二叉树 III"></a>3. 从上到下打印二叉树 III</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429210759722.png" alt="image-20220429210759722"></p><p><strong>解题思路:</strong></p><p>本题额外要求 <strong>打印顺序交替变化</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/9513dcb034f5dcdea947a2f667b3d380df4f8732da6397778e00718b77584010-Picture1.png" alt="Picture1.png"></p><p>层序遍历 + 双端队列</p><ul><li>利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列）temp，并规定：<ul><li>奇数层 则添加至 <code>tmp</code> <strong>尾部</strong> ，</li><li>偶数层 则添加至 <code>tmp</code> <strong>头部</strong> 。</li></ul></li></ul><blockquote><p>  算法流程：<br>  特例处理： 当树的根节点为空，则直接返回空列表 [] ；<br>  初始化： 打印结果空列表 res ，包含根节点的双端队列 deque ；<br>  BFS 循环： 当 deque 为空时跳出；<br>  新建列表 tmp ，用于临时存储当前层打印结果；<br>  当前层打印循环： 循环次数为当前层节点数（即 deque 长度）；<br>  出队： 队首元素出队，记为 node；<br>  打印： 若为奇数层，将 node.val 添加至 tmp 尾部；否则，添加至 tmp 头部；<br>  添加子节点： 若 node 的左（右）子节点不为空，则加入 deque ；<br>  将当前层结果 tmp 转化为 list 并添加入 res ；<br>  返回值： 返回打印结果列表 res 即可；</p></blockquote><p><strong>复杂度分析：</strong><br>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) ；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。<br>空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点 同时 在 deque 中，使用 O(N) 大小的额外空间。</p><blockquote><p>  需要判断每个节点的所在层奇偶性，即冗余了 N 次判断。</p><p>  优化: 通过将奇偶层逻辑拆分，可以消除冗余的判断。</p></blockquote><blockquote><p>  <strong>算法流程(优化)：</strong><br>  与方法一对比，仅 BFS 循环不同。</p><p>  BFS 循环： 循环打印奇 / 偶数层，当 deque 为空时跳出；<br>  打印奇数层： 从左向右 打印，先左后右 加入下层节点；<br>  若 deque 为空，说明向下无偶数层，则跳出；<br>  打印偶数层： 从右向左 打印，先右后左 加入下层节点；</p></blockquote><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>        deque <span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> dque<span class="token punctuation">;</span>        vector <span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> temp<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            dque<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>dque<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 打印奇数层</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> dque<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 左到y</span>                TreeNode <span class="token operator">*</span> node <span class="token operator">=</span> dque<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dque<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                temp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> dque<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> dque<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dque<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            temp<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 打印偶数层</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> dque<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 右到左</span>                TreeNode <span class="token operator">*</span> node <span class="token operator">=</span> dque<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dque<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                temp<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span> dque<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span> dque<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>node<span class="token operator">-</span><span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>            temp<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第六天-搜索与回溯算法（简单）&quot;&gt;&lt;a href=&quot;#第六天-搜索与回溯算法（简单）&quot; class=&quot;headerlink&quot; title=&quot;第六天_搜索与回溯算法（简单）&quot;&gt;&lt;/a&gt;第六天_搜索与回溯算法（简单）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第五天_查找算法(中等)</title>
    <link href="https://roranrui.cn/2022/04/29/shua-ti-bi-ji-wu/"/>
    <id>https://roranrui.cn/2022/04/29/shua-ti-bi-ji-wu/</id>
    <published>2022-04-29T05:31:40.000Z</published>
    <updated>2022-04-30T08:41:41.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五天-查找算法-中等"><a href="#第五天-查找算法-中等" class="headerlink" title="第五天_查找算法(中等)"></a>第五天_查找算法(中等)</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><blockquote><p>  树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> TreeNode <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 节点值</span>    TreeNode <span class="token operator">*</span>left<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 左子节点</span>    TreeNode <span class="token operator">*</span>right<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 右子节点</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如下图所示，建立此二叉树需要实例化每个节点，并构建各节点的引用指向。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 初始化节点</span>TreeNode <span class="token operator">*</span>n1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 根节点 root</span>TreeNode <span class="token operator">*</span>n2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>TreeNode <span class="token operator">*</span>n3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>TreeNode <span class="token operator">*</span>n4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>TreeNode <span class="token operator">*</span>n5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 构建引用指向</span>n1<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> n2<span class="token punctuation">;</span>n1<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> n3<span class="token punctuation">;</span>n2<span class="token operator">-</span><span class="token operator">></span>left <span class="token operator">=</span> n4<span class="token punctuation">;</span>n2<span class="token operator">-</span><span class="token operator">></span>right <span class="token operator">=</span> n5<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599579136-bBARpC-Picture6.png" alt="Picture6.png"></p><h3 id="二叉树查找算法"><a href="#二叉树查找算法" class="headerlink" title="二叉树查找算法"></a>二叉树查找算法</h3><blockquote><p>  ​       二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。</p></blockquote><p>原理：<br>    二叉查找树（BinarySearch Tree，也叫二叉搜索树 BST，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：</p><p> 　1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br> 　2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>　3. 任意节点的左、右子树也分别为二叉查找树；</p><ol start="4"><li>没有键值相等的节点（no duplicate nodes)。</li></ol><p>BST 中实现查找元素：<br>根据BST的特性，对于每个节点：</p><ol><li>如果目标值等于节点的值，则返回节点</li><li>如果目标值小于节点的值，则继续在左子树中搜索</li><li>如果目标值大于节点的值，则继续在右子树中搜索</li></ol><p>在上面的二叉搜索树中搜索目标值为 4 的节点<br><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/bst_search-a1.png" alt="img"></p><hr><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1. 二维数组中的查找"></a>1. 二维数组中的查找</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429133221263.png" alt="image-20220429133221263"></p><p><strong>解题思路:</strong></p><p>1.暴力遍历</p><p><strong>时间复杂度: O(NM)</strong></p><p>2.二叉树查找</p><p>如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 <code>target</code> 大的元素就向左，反之向右，即可找到目标值 <code>target</code> 。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png" alt="Picture1.png"></p><blockquote><p>  “根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 标志数 ，以 matrix 中的 左下角元素 为标志数 flag ，则有:</p><p>  若 flag &gt; target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。<br>  若 flag &lt; target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。</p></blockquote><blockquote><p>  算法流程：<br>  从矩阵 matrix 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比：<br>  当 matrix[i][j] &gt; target 时，执行 i– ，即消去第 i 行元素；<br>  当 matrix[i][j] &lt; target 时，执行 j++ ，即消去第 j 列元素；<br>  当 matrix[i][j] = target 时，返回 true ，代表找到目标值。</p></blockquote><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429165026207.png" alt="image-20220429165026207"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">findNumberIn2DArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span> i <span class="token operator">=</span> matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>           <span class="token punctuation">{</span>               j<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span>            <span class="token punctuation">{</span>               i<span class="token operator">--</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:/Users/13993/AppData/Roaming/Typora/typora-user-images/image-20220429165645971.png" alt="image-20220429165645971"></p><hr><h3 id="2-旋转数组的最小数字"><a href="#2-旋转数组的最小数字" class="headerlink" title="2.  旋转数组的最小数字"></a>2.  旋转数组的最小数字</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429170934614.png" alt="image-20220429170934614"></p><p><strong>解题思路</strong>:</p><p>1.暴力查找</p><p><strong>时间复杂度</strong>: O(N)</p><p>2.二分查找</p><p>如下图所示，寻找旋转数组的最小元素即为寻找 <strong>右排序数组</strong> 的首个元素 nums[x] ，称 x 为 <strong>旋转点</strong> 。</p><blockquote><p>  排序数组的查找问题首先考虑使用 <strong>二分法</strong> 解决，其可将 <strong>遍历法</strong> 的 <strong>线性级别</strong> 时间复杂度降低至 <strong>对数级别</strong> 。</p></blockquote><blockquote><p>  算法流程：<br>  初始化： 声明 i, j 双指针分别指向 nums 数组左右两端；<br>  循环二分： 设 m = (i + j) / 2为每次二分的中点（ “/“ 代表向下取整除法，因此恒有 i≤m&lt;j ），可分为以下三种情况：</p><ol><li>当 nums[m] &gt; nums[j] 时： m 一定在 左排序数组 中，即旋转点 x 一定在 [m + 1, j] 闭区间内，因此执行 i=m+1；</li><li>当 nums[m] &lt; nums[j] 时： m 一定在 右排序数组 中，即旋转点 x 一定在[i, m] 闭区间内，因此执行 j=m；</li><li>当 nums[m] = nums[j] 时： 无法判断 m 在哪个排序数组中，即无法判断旋转点 x 在 [i, m] 还是 [m + 1, j]区间中。解决方案： 执行 j = j - 1 缩小判断范围，分析见下文。<br>返回值： 当 i = j时跳出二分循环，并返回 旋转点的值 nums[i]即可。</li></ol></blockquote><p>复杂度分析：<br>时间复杂度 O(log 2N) ： 在特例情况下（例如 [1, 1, 1, 1]），会退化到 O(N)。<br>空间复杂度 O(1) ： i , j , m 变量使用常数大小的额外空间。</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> numbers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>num <span class="token operator">:</span> numbers<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> res<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                res <span class="token operator">=</span> num<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 低级写法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> numbers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> numbers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                res <span class="token operator">=</span> numbers<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429174629219.png" alt="image-20220429174629219"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> r<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429174611872.png" alt="image-20220429174611872"></p><hr><h3 id="3-第一个只出现一次的字符"><a href="#3-第一个只出现一次的字符" class="headerlink" title="3. 第一个只出现一次的字符"></a>3. 第一个只出现一次的字符</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429174721949.png" alt="image-20220429174721949"></p><p><strong>解题思路</strong>:</p><p>1.哈希表</p><ol><li>遍历字符串 <code>s</code> ，使用哈希表统“各字符数量是否 &gt; 1&gt;1 ”。</li><li>再遍历字符串 <code>s</code> ，在哈希表中找到首个 “数量为 11 的字符”，并返回。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/ed093aabc9195caff6d088454eaebe3cad875e8ca4a643c004ef25e4e5e9e174-Picture1.png" alt="Picture1.png"></p><blockquote><p>  算法流程：<br>  初始化： map，记为 dic ；<br>  字符统计： 遍历字符串 s 中的每个字符 c ；<br>  若 dic 中 不包含 键(key) c ：则向 dic 中添加键值对 (c, True) ，代表字符 c 的数量为 1 ；<br>  若 dic 中 包含 键(key) c ：则修改键 c 的键值对为 (c, False) ，代表字符 c 的数量 &gt; 1。<br>  查找数量为 1 的字符： 遍历字符串 s 中的每个字符 c ；<br>  若 dic中键 c 对应的值为 True ：，则返回 c 。<br>  返回 ‘ ‘ ，代表字符串无数量为 1 的字符。</p></blockquote><p><strong>时间复杂度</strong>: O(N) ： N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N)；HashMap 查找操作的复杂度为 O(1) ；<br><strong>空间复杂度</strong> O(1) ： 由于题目指出 s 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用 O(26) = O(1)的额外空间。</p><p>2.<strong>有序哈希表</strong></p><p>在哈希表的基础上，有序哈希表中的键值对是 按照插入顺序排序 的。基于此，可通过遍历有序哈希表，实现搜索首个 “数量为 11 的字符”。</p><p>哈希表是 去重 的，即哈希表中键值对数量 \leq≤ 字符串 s 的长度。因此，相比于方法一，方法二减少了第二轮遍历的循环次数。当字符串很长（重复字符很多）时，方法二则效率更高。</p><p>复杂度分析：<br>时间和空间复杂度均与 “方法一” 相同，而具体分析：方法一 需遍历 s 两轮；方法二 遍历 s 一轮，遍历 dic 一轮（ dic 的长度不大于 26 ）。</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">char</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> dic<span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span>       <span class="token punctuation">{</span>            dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> dic<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 向dic中添加键值对(c, True)，代表字符c的数量为 1 , 若 dic 中 包含 键(key) c ：则修改键 c 的键值对为 (c, False) ，代表字符 c 的数量 > 1。</span>       <span class="token punctuation">}</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span>       <span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> c<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 若 dic中键 c 对应的值为 True ：，则返回 c 。</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429180019234.png" alt="image-20220429180019234"></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">char</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> dic<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vec<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> s<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> dic<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 未找到, 可能是target</span>            <span class="token punctuation">{</span>                vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> dic<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> vec<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> c<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 若 dic中键 c 对应的值为 True ：，则返回 c 。</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220429180917945.png" alt="image-20220429180917945"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第五天-查找算法-中等&quot;&gt;&lt;a href=&quot;#第五天-查找算法-中等&quot; class=&quot;headerlink&quot; title=&quot;第五天_查找算法(中等)&quot;&gt;&lt;/a&gt;第五天_查找算法(中等)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href=&quot;</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第四天_查找算法（简单）</title>
    <link href="https://roranrui.cn/2022/04/27/shua-ti-bi-ji-si/"/>
    <id>https://roranrui.cn/2022/04/27/shua-ti-bi-ji-si/</id>
    <published>2022-04-27T00:00:50.000Z</published>
    <updated>2022-04-30T08:41:40.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四天-查找算法（简单）"><a href="#第四天-查找算法（简单）" class="headerlink" title="第四天_查找算法（简单）"></a>第四天_查找算法（简单）</h1><blockquote><p>  刷题日程指引: <a href="https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/px2ds5/">行百里者半九十。坚持一个月刷完，一起加油！</a></p></blockquote><h2 id="一-知识学习"><a href="#一-知识学习" class="headerlink" title="一. 知识学习"></a>一. 知识学习</h2><h3 id="散列表-HashSet"><a href="#散列表-HashSet" class="headerlink" title="散列表(HashSet)"></a>散列表(HashSet)</h3><p>散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 <code>key</code>」映射至对应的「值 <code>value</code>」，以实现高效的元素查找。</p><blockquote><p>  设想一个简单场景：小力、小特、小扣的学号分别为 10001, 10002, 10003 。<br>  现需求从「姓名」查找「学号」。</p></blockquote><p>则可通过建立姓名为 key ，学号为 value 的散列表实现此需求，代码如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 初始化散列表</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> dic<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 添加 key -> value 键值对</span>dic<span class="token punctuation">[</span><span class="token string">"小力"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10001</span><span class="token punctuation">;</span>dic<span class="token punctuation">[</span><span class="token string">"小特"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10002</span><span class="token punctuation">;</span>dic<span class="token punctuation">[</span><span class="token string">"小扣"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10003</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从姓名查找学号</span>dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"小力"</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> 10001</span>dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"小特"</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> 10002</span>dic<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">"小扣"</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// -> 10003</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599811794-ruXMOV-Picture8.png" alt="Picture8.png"></p><h4 id="Hash-函数设计-Demo"><a href="#Hash-函数设计-Demo" class="headerlink" title="Hash 函数设计 Demo"></a>Hash 函数设计 Demo</h4><p>将三人的姓名存储至以下数组中，则各姓名在数组中的索引分别为 0, 1, 2 。</p><p>string names[] = { “小力”, “小特”, “小扣” };</p><p>此时，我们构造一个简单的 Hash 函数（ %% 为取余符号 ），公式和封装函数如下所示：</p><p><code>hash(key) = (key - 1) \% 10000</code><br><code>hash(key)=(key−1)%10000</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>id <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10000</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> index<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>则我们构建了以学号为 key 、姓名对应的数组索引为 value 的散列表。利用此 Hash 函数，则可在 O(1)O(1) 时间复杂度下通过学号查找到对应姓名，即：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/1599811794-NfbpfW-Picture8-1.png" alt="Picture8-1.png"></p><blockquote><p>  以上设计只适用于此示例，实际的 Hash 函数需保证低碰撞率、 高鲁棒性等，以适用于各类数据和场景。</p></blockquote><hr><h3 id="七大查找算法"><a href="#七大查找算法" class="headerlink" title="七大查找算法"></a>七大查找算法</h3><ul><li><strong>1. 顺序查找</strong></li><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label1"><strong>2. 二分查找</strong></a></li><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label2"><strong>3. 插值查找</strong></a></li><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label3"><strong>4. 斐波那契查找</strong></a></li><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label4"><strong>5. 树表查找</strong></a></li><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label5"><strong>6. 分块查找</strong></a></li><li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html#_label6"><strong>7. 哈希查找</strong></a></li></ul><blockquote><p>  查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。树表查找和哈希查找会在后续的博文中进行详细介绍。</p></blockquote><p>  <strong>查找定义</strong>：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p><h3 id="查找算法分类"><a href="#查找算法分类" class="headerlink" title="查找算法分类"></a><strong>查找算法分类</strong></h3><ol><li><p>静态查找和动态查找；</p><p>注：静态或者动态都是针对查找表而言的。<strong>动态表指查找表中有删除和插入操作的表。</strong></p></li><li><p>无序查找和有序查找。</p><p><strong>无序查找</strong>：被查找数列有序无序均可；</p><p>有序查找：被查找数列必须为有序数列。</p></li></ol><blockquote><p>  <strong>平均查找长度（Average Search Length，ASL）</strong>：需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。</p><p>  　　对于含有n个数据元素的查找表，查找成功的平均查找长度为：<code>ASL = Pi*Ci</code>的和。<br>  　　<strong>Pi</strong>：查找表中第i个数据元素的概率。<br>  　　<strong>Ci</strong>：找到第i个数据元素时已经比较过的次数。</p></blockquote><h4 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h4><blockquote><p>  说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</p></blockquote><p><strong>基本思想</strong>：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p><p><strong>复杂度分析</strong>：　</p><p>　　查找成功时的平均查找长度为：（假设每个数据元素的概率相等） <code>ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;</code><br>　　当查找不成功时，需要n+1次比较，时间复杂度为O(n);</p><p>　　所以，顺序查找的时间复杂度为O(n)。</p><h4 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h4><p>　　<strong>说明：元素必须是有序的，如果是无序的则要先进行排序操作。</strong></p><p>　　<strong>基本思想：</strong>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。</p><p>　　<strong>复杂度分析：</strong>最坏情况下，关键词比较次数为log2(n+1)，且**期望时间复杂度为O(log2n)**；</p><p>　　注：<strong>折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》</strong></p><p><strong>其他查找算法后面补充</strong></p><hr><h2 id="二-题目练习"><a href="#二-题目练习" class="headerlink" title="二. 题目练习"></a>二. 题目练习</h2><h3 id="1-数组中重复的数字"><a href="#1-数组中重复的数字" class="headerlink" title="1. 数组中重复的数字"></a>1. 数组中重复的数字</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427081435148.png" alt="image-20220427081435148"></p><p><strong>解题思路:</strong></p><p>1.<strong>原地交换</strong><br>题目说明尚未被充分使用，即 在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 此说明含义：数组元素的 索引 和 值 是 一对多 的关系。<br>因此，可遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 `nums[i] = i ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p><p>遍历中，第一次遇到数字 x 时，将其交换至索引 x 处；而当第二次遇到数字 x 时，一定有 <code>nums[x] = x</code> ，此时即可得到一组重复数字。</p><blockquote><p>  <strong>算法流程：</strong><br>  遍历数组 <code>numsnums</code> ，设索引初始值为 i = 0 :</p><p>  若 <code>nums[i] = i</code>： 说明此数字已在对应索引位置，无需交换，因此跳过；<br>  若 <code>nums[nums[i]] = nums[i]</code>： 代表索引 <code>nums[i]</code> 处和索引 <code>i</code> 处的元素值都为 <code>nums[i]</code> ，即找到一组重复值，返回此值 <code>nums[i]</code> ；<br>  否则： 交换索引为 <code>i</code> 和 <code>nums[i]</code> 的元素值，将此数字交换至对应索引位置。<br>  若遍历完毕尚未返回，则返回 −1 。</p></blockquote><p><strong>复杂度分析：</strong><br>时间复杂度 O(N) ： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。<br>空间复杂度 O(1)： 使用常数复杂度的额外空间。</p><p><strong>2.利用HashSet</strong></p><p>利用数据结构特点，容易想到使用哈希表（Set）记录数组的各个数字，当查找到重复数字则直接返回。</p><blockquote><p>  <strong>算法流程：</strong><br>  初始化： 新建 HashSet ，记为 dic ；<br>  遍历数组 nums 中的每个数字 num ：<br>  当 num 在 dic中，说明重复，直接返回 num ；<br>  将 num 添加至 dic 中；<br>  返回 -1 。本题中一定有重复数字，因此这里返回多少都可以。</p></blockquote><p><strong>复杂度分析：</strong><br>时间复杂度 O(N)： 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1) 。<br>空间复杂度 O(N)： HashSet 占用O(N) 大小的额外空间。</p><p><strong>实现:</strong></p><ol><li>原地交换</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> i<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 数据与下标相同</span>            <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427084044831.png" alt="image-20220427084044831"></p><ol start="2"><li>HashSet</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> dic<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">:</span> nums<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dic<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">return</span> num<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            dic<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427084019040.png" alt="image-20220427084019040"></p><p>其他范例参考:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findRepeatNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>           <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  先让数组有序, 然后比较前后</p></blockquote><hr><h3 id="2-在排序数组中查找数字-I"><a href="#2-在排序数组中查找数字-I" class="headerlink" title="2.  在排序数组中查找数字 I"></a>2.  在排序数组中查找数字 I</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427084923052.png" alt="image-20220427084923052"></p><p><strong>解题思路:</strong></p><p>1.遍历求解</p><p>遍历<code>nums</code>并用<code>count</code>记录下<code>target</code>的次数</p><p><strong>复杂度分析：</strong><br>时间复杂度 O(N)： 遍历数组使用 O(N) ，count计数为O(1)<br>空间复杂度 O(1);</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> iterator <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iterator <span class="token operator">!=</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iterator<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>iterator <span class="token operator">==</span> target<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427085427712.png" alt="image-20220427085427712"></p><p>2.二分查找</p><p>排序数组 nums 中的所有数字 target 形成一个窗口，记窗口的 左 / 右边界 索引分别为 left和 right ，分别对应窗口左边 / 右边的首个元素。</p><p>本题要求统计数字 target 的出现次数，可转化为：使用二分法分别找到 左边界 leftleft 和 右边界 rightright ，易得数字 target 的数量为 right - left - 1。</p><blockquote><p>  <strong>算法解析：</strong><br>  初始化： 左边界 i = 0 ，右边界 j = len(nums) - 1 。<br>  循环二分： 当闭区间 [i, j] 无元素时跳出；<br>  计算中点 m = (i + j) / 2（向下取整）；<br>  若 nums[m] &lt; target ，则 target 在闭区间 [m + 1, j]中，因此执行 i = m + 1；<br>  若 nums[m] &gt; target ，则 target 在闭区间 [i, m - 1]中，因此执行 j = m - 1；<br>  若 nums[m] = target ，则右边界 right在闭区间 [m+1, j]中；左边界 left在闭区间 [i, m-1] 中。因此分为以下两种情况：<br>  若查找 右边界 right ，则执行 i = m + 1 ；（跳出时 i 指向右边界）<br>  若查找 左边界 left ，则执行 j = m - 1 ；（跳出时 j指向左边界）<br>  返回值： 应用两次二分，分别查找 right 和 left ，最终返回 right - left - 1right−left−1 即可。</p></blockquote><blockquote><p>  效率优化：<br>  以下优化基于：查找完右边界 right = i 后，则 nums[j]指向最右边的 target （若存在）。</p></blockquote><ol><li>查找完右边界后，可用 nums[j] = target判断数组中是否包含 target，若不包含则直接提前返回 0 ，无需后续查找左边界。</li><li>查找完右边界后，左边界 left一定在闭区间 [0, j] 中，因此直接从此区间开始二分查找即可。</li></ol><p><strong>复杂度分析：</strong><br>时间复杂度 O(logN) ： 二分法为对数级别复杂度。<br>空间复杂度 O(1)： 几个变量使用常数大小的额外空间。<br>代码：<br>可将 nums[m] = target情况合并至其他两种情况中。</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* 搜索右边界 right */</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">)</span> i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 若数组中无 target ，则提前返回 */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 搜索左边界 right */</span>        i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> j<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> j<span class="token punctuation">;</span>        <span class="token keyword">return</span> right <span class="token operator">-</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-0～n-1-中缺失的数字"><a href="#3-0～n-1-中缺失的数字" class="headerlink" title="3. 0～n-1 中缺失的数字"></a>3. 0～n-1 中缺失的数字</h3><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427204205526.png" alt="image-20220427204205526"></p><p><strong>解题思路</strong><br>1.二分查找到某个值(最优解)，满足：</p><p>左子数组： <code>nums[i] = i</code><br>右子数组： <code>nums[i] != i</code></p><p>时间复杂度O(logN)</p><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//使用(left + right)/2 也可以 但是要注意 left + right 可能会超过 int 表示范围</span>            <span class="token comment" spellcheck="true">//left + (right - left )/2 可以有效的 防止溢出;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             left <span class="token operator">=</span> middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427205126432.png" alt="image-20220427205126432"></p><p>2.顺序查找</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427205223931.png" alt="image-20220427205223931"></p><p>其他方法参考:</p><p><strong>位运算处理</strong></p><ul><li>我们知道异或具有交换律</li><li>令0~n的数与<strong>nums</strong>中的数异或，运算中除了缺失值只出现一次外，其他数都出现两次等同于与自身异或。</li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">missingNumber</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span>     <span class="token punctuation">{</span>          <span class="token keyword">int</span> res <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            res <span class="token operator">^</span><span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>              res <span class="token operator">^</span><span class="token operator">=</span> i<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//其是就是 比较 数组下标 和 对应的元素 是否相等，不相等即为miss的数</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/image-20220427210015051.png" alt="image-20220427210015051"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第四天-查找算法（简单）&quot;&gt;&lt;a href=&quot;#第四天-查找算法（简单）&quot; class=&quot;headerlink&quot; title=&quot;第四天_查找算法（简单）&quot;&gt;&lt;/a&gt;第四天_查找算法（简单）&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  刷题日程指引: &lt;a href</summary>
      
    
    
    
    <category term="刷题笔记" scheme="https://roranrui.cn/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="Programming" scheme="https://roranrui.cn/tags/Programming/"/>
    
    <category term="算法" scheme="https://roranrui.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HTML学习笔记</title>
    <link href="https://roranrui.cn/2022/04/26/html-xue-xi-bi-ji/"/>
    <id>https://roranrui.cn/2022/04/26/html-xue-xi-bi-ji/</id>
    <published>2022-04-26T14:22:03.000Z</published>
    <updated>2022-04-26T15:14:18.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML学习笔记"><a href="#HTML学习笔记" class="headerlink" title="HTML学习笔记"></a>HTML学习笔记</h1><blockquote><p>  文章转载至: [<a href="https://docs.mphy.top/">MurphyChen’s Notes</a>]仅供学习交流使用</p><p>  如有侵权, 请立即联系我删除!</p></blockquote><h1 id="（一）HTML-标签（上）"><a href="#（一）HTML-标签（上）" class="headerlink" title="（一）HTML 标签（上）"></a>（一）HTML 标签（上）</h1><h2 id="1-HTML-语法规范"><a href="#1-HTML-语法规范" class="headerlink" title="1. HTML 语法规范"></a>1. HTML 语法规范</h2><h3 id="1-1-基本语法规范"><a href="#1-1-基本语法规范" class="headerlink" title="1.1 基本语法规范"></a>1.1 基本语法规范</h3><ol><li>HTML 标签通常是成对出现的，例如<code>&lt;html&gt;</code>和<code>&lt;html/&gt;</code>，称为双标签。第一个是开始标签，第二个是结束标签。</li><li>有些特殊标签必须是单个标签（极少情况），例如<code>&lt;br/&gt;</code>，我们称之为单标签。</li></ol><h3 id="1-2-标签关系"><a href="#1-2-标签关系" class="headerlink" title="1.2 标签关系"></a>1.2 标签关系</h3><p>标签关系可以分为两类：包含关系和并列关系</p><h2 id="2-HTML-基本结构标签"><a href="#2-HTML-基本结构标签" class="headerlink" title="2. HTML 基本结构标签"></a>2. HTML 基本结构标签</h2><p>每个网页都会有一个基本的结构标签，页面内容都是在这些基本标签上书写。 HTML 页面也叫 HTML 文档。</p><h2 id="3-开发工具"><a href="#3-开发工具" class="headerlink" title="3. 开发工具"></a>3. 开发工具</h2><h3 id="3-1-文档类型声明标签"><a href="#3-1-文档类型声明标签" class="headerlink" title="3.1 文档类型声明标签"></a>3.1 文档类型声明标签</h3><p><code>!&lt;DOCTYPE&gt;</code> 文档类型声明，告诉浏览器使用何种 HTML 版本来显示网页。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>这句话的意思是：当前页面采用的是 HTML5 版本来显示网页。</strong> <strong>注意：</strong></p><ol><li><code>&lt;!DOCTYPE&gt;</code> 声明位于文档最前面的位置，处于<code>&lt;html&gt;</code>标签之前。</li><li><code>&lt;!DOCTYPE&gt;</code> 不是一个 HTML 标签，他就是文档类型声明标签。</li></ol><h3 id="3-2-lang-语言种类"><a href="#3-2-lang-语言种类" class="headerlink" title="3.2 lang 语言种类"></a>3.2 lang 语言种类</h3><p>用来显示当前文档显示的语言。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>zh-CN<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li><code>en</code> 定义语言为英文。</li><li><code>zh-CN</code> 定义语言为中文。</li></ol><p>这个属性对浏览器和搜索引擎（谷歌/百度）还是有作用的。</p><h3 id="3-3-charset-字符集"><a href="#3-3-charset-字符集" class="headerlink" title="3.3 charset 字符集"></a>3.3 charset 字符集</h3><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>字符集（character set）是多个字符的集合，以便计算机能够识别和存储各种文字。</p><p>在<code>&lt;head&gt;</code>标签内，可以通过<code>&lt;meta&gt;</code>标签的<code>charset</code> 属性来设置文档使用何种字符编码。</p><p><code>charset</code>常用的值有：GBK、UTF-8，其中UTF-8被称为万国码，基本包含了全世界所有国家需要用到的字符。</p><h2 id="4-HTML-常用标签"><a href="#4-HTML-常用标签" class="headerlink" title="4. HTML 常用标签"></a>4. HTML 常用标签</h2><h3 id="4-1-标签语义"><a href="#4-1-标签语义" class="headerlink" title="4.1 标签语义"></a>4.1 标签语义</h3><p>标签语义就是标签的含义。</p><p>根据标签的语义，再合适的地方给一个最合理的标签，可以让页面结构更清晰。</p><h3 id="4-2-标题标签-h1-h6（重要）"><a href="#4-2-标题标签-h1-h6（重要）" class="headerlink" title="4.2 标题标签 h1-h6（重要）"></a>4.2 标题标签 h1-h6（重要）</h3><p>为了使网页具有语义化，经常使用标题标签，HTML 提供 6 个等级的网页标题标签即 <code>&lt;h1&gt;-&lt;h6&gt;</code>。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>标题标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>标题一共六级选,<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>文字加粗一行显。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>由大到小依次减，<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>从重到轻随之变。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h5</span><span class="token punctuation">></span></span>语法规范书写后，<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h5</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span><span class="token punctuation">></span></span>具体效果刷新见。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h6</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单词为 head 简写，从 h1-h6 依据重要性递减。</p><h3 id="4-3-段落和换行标签（重要）"><a href="#4-3-段落和换行标签（重要）" class="headerlink" title="4.3 段落和换行标签（重要）"></a>4.3 段落和换行标签（重要）</h3><p><code>p</code> 指<strong>paragraph</strong>，意为段落。把文字有条理的显示出来就需要将文字分段显示。在 html 中，<code>&lt;p&gt;</code> 标签用于定义段落，将整个网页分成若干个段落。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>我是一个段落标签<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>标签语义: 把 HTML 文档分割为若干段落。</p><p><strong>特点：</strong></p><ol><li>文本在一个段落中会根据浏览器窗口的大小自动换行。</li><li>段落和段落之间保有空隙。</li></ol><hr><p><code>&lt;br/&gt;</code> 是 break 缩写，意为打断、换行。</p><p>标签语义： 强制换行</p><p><strong>特点：</strong></p><ol><li><code>&lt;br/&gt;</code> 是个单标签。</li><li><code>&lt;br/&gt;</code> 标签只是简单地开始新的一行，跟段落不一样，段落之间会插入一些垂直的间距。</li></ol><p>课堂案例</p><p>体育新闻显示页面——基本标签的使用</p><h3 id="4-4-文本格式化标签"><a href="#4-4-文本格式化标签" class="headerlink" title="4.4 文本格式化标签"></a>4.4 文本格式化标签</h3><p>在网页中，有时候需要为文字设置<strong>粗体</strong>、<em>斜体</em>或下划线等效果，需要使用 HTML 中的文本格式化标签，使文字以特殊方式显示。</p><p>标签语义： 突出重要性，比普通文字重要。</p><table><thead><tr><th>语义</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>加粗</td><td><code>&lt;strong&gt;&lt;/strong&gt;</code>或<code>&lt;b&gt;&lt;/b&gt;</code></td><td>更推荐<code>&lt;strong&gt;</code>，语义更强烈</td></tr><tr><td>斜体</td><td><code>&lt;em&gt;&lt;/em&gt;</code>或<code>&lt;i&gt;&lt;/i&gt;</code></td><td>更推荐使用<code>&lt;em&gt;</code>，语义更强烈</td></tr><tr><td>删除线</td><td><code>&lt;del&gt;&lt;/del&gt;</code>或<code>&lt;s&gt;&lt;s/&gt;</code></td><td>更推荐使用<code>&lt;del&gt;</code>，语义更强烈</td></tr><tr><td>下划线</td><td><code>&lt;ins&gt;&lt;/ins&gt;</code>或<code>&lt;u&gt;&lt;/u&gt;</code></td><td>更推荐使用<code>&lt;ins&gt;</code>，语义更强烈</td></tr></tbody></table><h3 id="4-5-div-和-span-标签"><a href="#4-5-div-和-span-标签" class="headerlink" title="4.5 div 和 span 标签"></a>4.5 div 和 span 标签</h3><div>&nbsp;和&nbsp;<span>&nbsp;是没有语义的，它们是一个盒子，用来装内容的。<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>这是头部<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>今日价格<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>div 是 division 的缩写，表示分割、分区。span 意思是跨度、跨距。</p><p><strong>特点：</strong></p><ol><li>div 标签用来布局，但是现在一行只能放一个 div，大盒子。</li><li>span 标签用来布局，一行可以多个 span，小盒子。</li></ol><h3 id="4-6-图像标签和路径（重点）"><a href="#4-6-图像标签和路径（重点）" class="headerlink" title="4.6 图像标签和路径（重点）"></a>4.6 图像标签和路径（重点）</h3><h4 id="4-6-1-图像标签"><a href="#4-6-1-图像标签" class="headerlink" title="4.6.1 图像标签"></a>4.6.1 图像标签</h4><p>在 HTML 标签中，<code>&lt;img /&gt;</code> 标签用于定义 HTML 标签页面中的图像。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>图像url<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>单词 image 的缩写，意为图像。</p><p>src 是标签的 必须属性，用于指定图像文件的路径和文件名。</p><p><strong>属性：</strong> 属于这个图像标签的特性。</p><p><strong>图像标签的其他属性</strong></p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td><code>src</code></td><td>图片路径</td><td>必须属性</td></tr><tr><td><code>alt</code></td><td>文本</td><td>替换文本，当图片不显示时显示文字</td></tr><tr><td><code>title</code></td><td>文本</td><td>提示文本。鼠标放到图像上显示文字</td></tr><tr><td><code>width</code></td><td>像素</td><td>图像宽度</td></tr><tr><td><code>height</code></td><td>像素</td><td>图像高度</td></tr><tr><td><code>border</code></td><td>像素</td><td>图像边框粗细</td></tr></tbody></table><h4 id="4-6-2-路径"><a href="#4-6-2-路径" class="headerlink" title="4.6.2 路径"></a>4.6.2 路径</h4><ul><li>相对路径</li><li>绝对路径</li></ul><h5 id="1-相对路径"><a href="#1-相对路径" class="headerlink" title="1. 相对路径"></a>1. 相对路径</h5><p>相对路径： 以引用文件位置为参考基础，而建立出来的目录路径。是相对于 HTML 页面的位置。</p><table><thead><tr><th>分类</th><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>同级路径</td><td></td><td>同一级</td></tr><tr><td>下一级路径</td><td><code>/</code></td><td>位于 HTML 文件上一级</td></tr><tr><td>上一级路径</td><td><code>../</code></td><td>位于 HTML 文件下一级</td></tr></tbody></table><h5 id="2-绝对路径"><a href="#2-绝对路径" class="headerlink" title="2. 绝对路径"></a>2. 绝对路径</h5><p>绝对路径： 是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径或者完整的网络地址。</p><h3 id="4-7-超链接标签"><a href="#4-7-超链接标签" class="headerlink" title="4.7 超链接标签"></a>4.7 超链接标签</h3><p>在 HTML 标签中，<code>&lt;a/&gt;</code> 标签用于从一个页面链接到另一个页面。</p><h4 id="4-7-1-链接的语法格式"><a href="#4-7-1-链接的语法格式" class="headerlink" title="4.7.1 链接的语法格式"></a>4.7.1 链接的语法格式</h4><p>a 是单词 anchor 的简写，是锚的意思。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>跳转目标<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>目标窗口的弹出方式<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>文本或图像<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>属性</strong></p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>href</code></td><td>指定链接地址 url，为必须属性。</td></tr><tr><td><code>target</code></td><td>指定页面打开方式，<code>_self</code>为默认值，<code>_blank</code>为在新窗口中打开</td></tr></tbody></table><h4 id="4-7-2-超链接分类"><a href="#4-7-2-超链接分类" class="headerlink" title="4.7.2 超链接分类"></a>4.7.2 超链接分类</h4><ol><li><p>外部链接</p></li><li><p>内部链接：网站内部页面之间的相互链接。</p></li><li><p>空链接: <code>#</code></p></li><li><p>下载链接：地址链接的是文件.exe、压缩包.zip 等。</p></li><li><p>网页元素链接：在网页中的各种网页元素。如文本、图像、表格、音频、视频等。</p></li><li><p>锚点链接：</p><p>点击链接，可以快速定位到页面中的某个位置。</p><ul><li>在链接文本的<code>href</code>属性中，设置属性为 #名字的形式</li><li>找到目标位置标签，里面添加一个 id 属性 = 名字</li></ul></li></ol><p>Tip</p><p>阻止 <code>a</code> 链接跳转，课可给 <code>href</code> 属性设置 <code>javascript:void(0);</code> 或者 <code>javascript:;</code>。</p><h2 id="5-HTML-中的注释和特殊字符号"><a href="#5-HTML-中的注释和特殊字符号" class="headerlink" title="5. HTML 中的注释和特殊字符号"></a>5. HTML 中的注释和特殊字符号</h2><ol><li>注释: <code>&lt;!--注释--&gt;</code> VSCode 中快捷键：Ctrk + /</li><li>字符实体</li></ol><table><thead><tr><th>字符</th><th>显示</th></tr></thead><tbody><tr><td><code> </code></td><td>空格</td></tr><tr><td><code>&lt;</code></td><td>＜</td></tr><tr><td><code>&gt;</code></td><td>＞</td></tr><tr><td><code>©</code></td><td>©</td></tr></tbody></table><hr><h1 id="（二）HTML-标签（下）"><a href="#（二）HTML-标签（下）" class="headerlink" title="（二）HTML 标签（下）"></a>（二）HTML 标签（下）</h1><h2 id="1-表格标签"><a href="#1-表格标签" class="headerlink" title="1. 表格标签"></a>1. 表格标签</h2><h3 id="1-1-表格的主要作用"><a href="#1-1-表格的主要作用" class="headerlink" title="1.1 表格的主要作用"></a>1.1 表格的主要作用</h3><p>表格主要用于显示、展示数据，因为可以让数据显示非常规整，可读性好。 表格不是来布局的，而是来展示数据的。</p><h3 id="1-2-表格基本语法"><a href="#1-2-表格基本语法" class="headerlink" title="1.2 表格基本语法"></a>1.2 表格基本语法</h3><ol><li><code>&lt;table&gt;&lt;/table&gt;</code> 用于定义表格的标签。</li><li><code>&lt;tr&gt;&lt;/tr&gt;</code> 标签用于定义表格中的行，必须嵌套在 <code>&lt;table&gt;&lt;/table&gt;</code>中。</li><li><code>&lt;td&gt;&lt;/td&gt;</code> 用于定义表格中的单元格，必须嵌套在 <code>&lt;tr&gt;&lt;/tr&gt;</code> 中。</li><li>字母 td 指表格数据（table data），即单元格的内容。</li></ol><h3 id="1-3-表头单元格标签-th"><a href="#1-3-表头单元格标签-th" class="headerlink" title="1.3 表头单元格标签 th"></a>1.3 表头单元格标签 th</h3><p>一般单元格位于表格的第一行或第一列，表格单元格里面的文本内容 <strong>加粗显示</strong>。 <code>&lt;th&gt;</code> 标签表示 HTML 表格的表头部分（table head 的缩写） 表头单元格(<code>&lt;th&gt;</code>)也是单元格，常用于表格第一行，突出重要性，表头单元格里面的文字会加粗居中显示。</p><h3 id="1-4-表格属性"><a href="#1-4-表格属性" class="headerlink" title="1.4 表格属性"></a>1.4 表格属性</h3><p>只作了解，后期通过 CSS 来设置。 这些属性都要写到 <code>&lt;table&gt;&lt;/table&gt;</code> 标签中</p><table><thead><tr><th>属性名</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>align</code></td><td>left、center、right</td><td>表格元素对齐方式</td></tr><tr><td><code>border</code></td><td>1 或””</td><td>规定是否有边框，默认为<code>""</code>，表示没有边框</td></tr><tr><td><code>cellpadding</code></td><td>像素值</td><td>规定单元边沿与其内容之间空白，默认 1px</td></tr><tr><td><code>cellspacing</code></td><td>像素值</td><td>规定单元格之间的空白，默认为 2px</td></tr><tr><td><code>width</code></td><td>像素值或百分比</td><td>规定表格宽度</td></tr><tr><td><code>hight</code></td><td>像素</td><td>表格高度</td></tr></tbody></table><h3 id="1-5-表格结构标签"><a href="#1-5-表格结构标签" class="headerlink" title="1.5 表格结构标签"></a>1.5 表格结构标签</h3><p>场景：表格可能很长，将表格分割为表格头部和表格主题两大部分。</p><p>加强语义化：<code>&lt;thead&gt;</code> 表示头部区域，<code>&lt;tbody&gt;</code> 表示主体区域，更好区分表格结构。</p><p>注意：</p><ol><li><code>&lt;thead&gt;&lt;/thead&gt;</code>：定义表格头部，且内部必须有<code>&lt;tr&gt;</code>标签。</li><li><code>&lt;tbody&gt;&lt;/tbody&gt;</code>：定义表格主体，存放数据。</li><li>以上标签都放在 <code>&lt;table&gt;&lt;/table&gt;</code> 里面。</li></ol><h3 id="1-6-合并单元格"><a href="#1-6-合并单元格" class="headerlink" title="1.6 合并单元格"></a>1.6 合并单元格</h3><p><strong>合并单元格方式：</strong></p><ul><li>跨行合并：rowspan=”合并单元格个数”</li><li>跨列合并：colspan=”合并单元格个数”</li></ul><p>合并三部曲：</p><ol><li>确定跨行 or 跨列。</li><li>找到目标单元格：跨行取最上面为目标单元格，跨列取最左边为目标单元格。<code>&lt;td colspan="2"&gt;&lt;/td&gt;</code></li><li>删除多余单元格。</li></ol><h2 id="2-列表标签"><a href="#2-列表标签" class="headerlink" title="2. 列表标签"></a>2. 列表标签</h2><p>表格展示数据，列表则用来布局。 列表特点是整齐、整洁、有序，作为布局更方便自由。 根据使用场景不同，列表分为三大类：</p><ul><li>无序列表</li><li>有序列表</li><li>自定义列表。</li></ul><h3 id="2-1-无序列表（重要）"><a href="#2-1-无序列表（重要）" class="headerlink" title="2.1 无序列表（重要）"></a>2.1 无序列表（重要）</h3><p><code>&lt;ul&gt;</code> 标签标识 HTML 页面项目中的无序列表，一般以项目符号呈现列表项。</p><p>语法格式:</p><pre class="line-numbers language-HTML"><code class="language-HTML"><ul>    <li>列表项1</li>    <li>列表项2</li>    <li>列表项3</li></ul>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意:</p><ol><li>各个列表项之间无需，并列关系。</li><li><code>&lt;ul&gt;&lt;/ul&gt;</code>中只能包含<code>&lt;li&gt;&lt;/li&gt;</code>，写入其他标签或文字是不允许的。</li><li>无序列表带有自己的属性，可用 CSS 修改样式属性。</li></ol><h3 id="2-2-有序列表（理解）"><a href="#2-2-有序列表（理解）" class="headerlink" title="2.2 有序列表（理解）"></a>2.2 有序列表（理解）</h3><p>使用 <code>&lt;ol&gt;</code> 标签来定义有序列表，<code>&lt;li&gt;</code> 来定义列表项。</p><pre class="line-numbers language-HTML"><code class="language-HTML"><ol>    <li>列表项1</li>    <li>列表项2</li>    <li>列表项3</li></ol>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与无需列表类似，有自己的样式属性，通过 CSS 设置。</p><h3 id="2-3-自定义列表（重点）"><a href="#2-3-自定义列表（重点）" class="headerlink" title="2.3 自定义列表（重点）"></a>2.3 自定义列表（重点）</h3><p><code>&lt;dl&gt;</code> 定义描述列表，与 <code>&lt;dt&gt;</code> 和 <code>&lt;dd&gt;</code> 标签配合使用。</p><p>基本语法：</p><pre class="line-numbers language-HTML"><code class="language-HTML"><dl>    <dt>名词1</dt>    <dd>名词1解释1</dd>    <dd>名词1解释2</dd></dl>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ol><li>dl 里面只能包含 dt 和 dd。</li></ol><h2 id="3-表头标签"><a href="#3-表头标签" class="headerlink" title="3. 表头标签"></a>3. 表头标签</h2><h3 id="3-1-为什么需要表头"><a href="#3-1-为什么需要表头" class="headerlink" title="3.1 为什么需要表头"></a>3.1 为什么需要表头</h3><p>收集用户信息。 和用户进行交互，收集用户资料。</p><h3 id="3-2-表头组成"><a href="#3-2-表头组成" class="headerlink" title="3.2 表头组成"></a>3.2 表头组成</h3><ul><li>表单域</li><li>表单控件（元素）</li><li>提示信息</li></ul><h3 id="3-3-表单域"><a href="#3-3-表单域" class="headerlink" title="3.3 表单域"></a>3.3 表单域</h3><p>表单域是一个包含表单元素的区域。 使用 <code>&lt;form&gt;</code> 标签用于定义表单域，手机和传递用户信息。 form 标签会将它范围内的表单元素信息提交给服务器。</p><p>目前而言，暂时不需要用表单域提交数据，只需要写上 <code>form</code> 标签即可。</p><p><strong>语法格式</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>url地址<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>提交方式<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>表单域名称<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  各种表单元素控件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>常用属性：</strong></p><table><thead><tr><th>属性</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td>url 地址</td><td>指定接受并处理表单数据的服务器的 url 地址</td></tr><tr><td>method</td><td>get/post</td><td>设置表单数据的提交方式</td></tr><tr><td>name</td><td>名称</td><td>用于指定表单名称，区分同一个页面中的多个表单域</td></tr></tbody></table><p>注意：</p><ol><li>写表单元素之前需要有表单域将其包含。</li><li>表单域是 <code>form</code> 标签。</li></ol><h3 id="3-4-表单控件（表单元素）"><a href="#3-4-表单控件（表单元素）" class="headerlink" title="3.4 表单控件（表单元素）"></a>3.4 表单控件（表单元素）</h3><p>在表单域中定义各种表单元素，允许用户在表单中输入或选择的内容控件。</p><h4 id="3-4-1-表单元素"><a href="#3-4-1-表单元素" class="headerlink" title="3.4.1 表单元素"></a>3.4.1 表单元素</h4><p><code>&lt;input&gt;</code> 标签用于收集用户信息。</p><p><code>input</code> 标签包含 <code>type</code> 属性，决定了输入字段的不同形式：文本字段、复选框、掩码后的文本控件、单选按钮、按钮等。</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>属性值<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>input</code> 标签为单标签</li><li><code>type</code> 属性设置不同属性值来指定不同控件类型</li></ul><p>type 常用属性值</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>button</td><td>定义可点击按钮</td></tr><tr><td>checkox</td><td>复选框</td></tr><tr><td>file</td><td>定义输入字段和“浏览”按钮，供文件上传</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段</td></tr><tr><td>image</td><td>定义图像形式的提交按钮</td></tr><tr><td>password</td><td>定义密码字段。字符被掩码。</td></tr><tr><td>radio</td><td>定义单选按钮</td></tr><tr><td>reset</td><td>定义重置按钮，清除表单所有数据。</td></tr><tr><td>submit</td><td>定义提交按钮。重置按钮会清除表单所有数据。</td></tr><tr><td>text</td><td>定义输入字段。用户可输入文本，默认宽度为 20 个字符。</td></tr></tbody></table><p>input 的其他属性</p><table><thead><tr><th>属性</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>自定义</td><td>定义 input 元素名称</td></tr><tr><td>value</td><td>自定义</td><td>规定 input 元素的值</td></tr><tr><td>checked</td><td>checked</td><td>规定此 input 元素首次加载时应当被选中</td></tr><tr><td>maxlength</td><td>正整数</td><td>规定输入字段字符的最大长度</td></tr></tbody></table><p>注意</p><ol><li>对于 <code>radio</code> 单选框，必须使 <code>input</code> 的 <code>name</code> 具有相同的属性值，才能实现多选一。 同理，复选框也要有相同的<code>name</code>值。</li><li>单选框和复选框可以设置 <code>checked</code> 属性，页面打开默认选择按钮。</li><li>设置 <code>type</code> 的值为 <code>submit</code>，点击按钮后可以把表单域 form 里面的表单元素里面的值提交给后台。</li><li>设置 <code>type="button"</code>，普通按钮，后期结合 js 使用</li></ol><h3 id="3-4-2-label-标签"><a href="#3-4-2-label-标签" class="headerlink" title="3.4.2 label 标签"></a>3.4.2 label 标签</h3><p><code>&lt;label&gt;</code> 标签为 input 元素定义标注。 <code>&lt;label&gt;</code> 标签用于绑定一个表单源深路，当点击 label 标签内的文本时，浏览器自动将焦点转到或者选择对应的表单元素上，提升用户体验。 <strong>语法：</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>男<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>radio<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sex<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>核心：</strong> <code>&lt;lable&gt;</code>标签的 for 属性与相关元素的 id 属性相同。</p><h3 id="3-4-3-select-下拉表单元素"><a href="#3-4-3-select-下拉表单元素" class="headerlink" title="3.4.3 select 下拉表单元素"></a>3.4.3 select 下拉表单元素</h3><p><code>select</code> 标签设置多个选项让用户选择，节约页面空间。 <strong>语法</strong></p><pre class="line-numbers language-HTML"><code class="language-HTML"><select>    <option>选项1</option>    <option>选项2</option>    <option>选项3</option></select>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong></p><ol><li>select 中至少包含一对 option。</li><li>在 option 中定义属性<code>selected=selected</code>，当前项即为默认选项。</li></ol><h3 id="3-4-4-textarea-文本域表单元素"><a href="#3-4-4-textarea-文本域表单元素" class="headerlink" title="3.4.4 textarea 文本域表单元素"></a>3.4.4 textarea 文本域表单元素</h3><p>场景：输入内容较多时。</p><p><strong>语法：</strong></p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>textarea</span> <span class="token attr-name">rows</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span> <span class="token attr-name">cols</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    文本内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>textarea</span><span class="token punctuation">></span></span>Copy to clipboardErrorCopied<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Tip</p><p>&gt; <code>cols="每行字符数"，rows="显示的行数"</code></p></span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML学习笔记&quot;&gt;&lt;a href=&quot;#HTML学习笔记&quot; class=&quot;headerlink&quot; title=&quot;HTML学习笔记&quot;&gt;&lt;/a&gt;HTML学习笔记&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  文章转载至: [&lt;a href=&quot;https://docs.m</summary>
      
    
    
    
    <category term="前端学习" scheme="https://roranrui.cn/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="html" scheme="https://roranrui.cn/tags/html/"/>
    
    <category term="前端" scheme="https://roranrui.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概谈</title>
    <link href="https://roranrui.cn/2022/04/26/she-ji-mo-shi-gai-tan/"/>
    <id>https://roranrui.cn/2022/04/26/she-ji-mo-shi-gai-tan/</id>
    <published>2022-04-26T14:15:32.000Z</published>
    <updated>2022-04-26T14:16:35.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式概谈"><a href="#设计模式概谈" class="headerlink" title="设计模式概谈"></a>设计模式概谈</h1><h2 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1.设计模式"></a>1.设计模式</h2><ul><li>程序灵活，维护起来可能方便，用设计模式理念写出来的代码很晦涩，但是别人接管、阅读代码都会很痛苦</li><li>老外应付特别大的项目时，把项目的开发经验、模块划分经验，总结整理成设计模式</li><li>中国零几年设计模式刚开始火时，总喜欢拿一个设计模式往上套，导致一个小小的项目总要加几个设计模式，本末倒置</li><li>设计模式有其独特的优点，要活学活用，不要深陷其中，生搬硬套</li></ul><hr><h2 id="2-单例设计模式："><a href="#2-单例设计模式：" class="headerlink" title="2.单例设计模式："></a>2.单例设计模式：</h2><p>整个项目中，有某个或者某些特殊的类，只能创建一个属于该类的对象。</p><blockquote><p>  单例类：只能生成一个对象。</p></blockquote><hr><h2 id="3-单例设计模式共享数据分析、解决"><a href="#3-单例设计模式共享数据分析、解决" class="headerlink" title="3.单例设计模式共享数据分析、解决"></a>3.单例设计模式共享数据分析、解决</h2><p>面临问题：需要在自己创建的线程中来创建单例类的对象，这种线程可能不止一个。我们可能面临<code>GetInstance()</code>这种成员函数需要互斥。</p><blockquote><p>  如果觉得在单例模式<code>new</code>了一个对象，而没有自己delete掉，这样不合理。可以增加一个类中类<code>Recycle</code>，<code>new</code>一个单例类时创建一个静态的<code>Recycle</code>对象，这样在程序结束时会调用<code>Recycle</code>的析构函数，释放掉<code>new</code>出来的单例对象。</p></blockquote><p><strong>单例类</strong>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MyCAS</span>  <span class="token comment" spellcheck="true">// 单例类</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">MyCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 私有化构造函数</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> MyCAS <span class="token operator">*</span>my_intstance<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> MyCAS <span class="token operator">*</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>my_intstance <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            my_intstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MyCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">static</span> Recycle recycle<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> my_intstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"for Test."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Recycle</span>    <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token operator">~</span><span class="token function">Recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>MyCAS<span class="token operator">::</span>my_intstance <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">delete</span> MyCAS<span class="token operator">::</span>my_intstance<span class="token punctuation">;</span>                MyCAS<span class="token operator">::</span>my_intstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    ~MyCAS()  // 不能在类中直接调用, 因为不会析构(没有创建实体类)</span><span class="token comment" spellcheck="true">//    {</span><span class="token comment" spellcheck="true">//        if (my_intstance != nullptr)</span><span class="token comment" spellcheck="true">//        {</span><span class="token comment" spellcheck="true">//            delete my_intstance;</span><span class="token comment" spellcheck="true">//            my_intstance = nullptr;</span><span class="token comment" spellcheck="true">//        }</span><span class="token comment" spellcheck="true">//    }</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化静态成员变量</span>MyCAS <span class="token operator">*</span>MyCAS<span class="token operator">::</span>my_intstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 单例类</span>    MyCAS <span class="token operator">*</span>p_m <span class="token operator">=</span> MyCAS<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 创建一个对象, 返回该类的对象指针</span><span class="token comment" spellcheck="true">//    MyCAS *p_b = MyCAS::getInstance();  // 返回的仍是同一个</span>    p_m<span class="token operator">-</span><span class="token operator">></span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MyCAS<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决线程重复调用<code>getInstance()</code>问题:</p><blockquote><p>  可以在加锁前判断m_instance是否为空，否则每次调用<code>MyCAS::getInstance()</code>都要加锁，十分影响效率。</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">        <span class="token comment" spellcheck="true">// 提高效率</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>my_intstance <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 双重锁定</span>        <span class="token punctuation">{</span>            unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">myMtx</span><span class="token punctuation">(</span>recursive_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>my_intstance <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                my_intstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MyCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">static</span> Recycle recycle<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> my_intstance<span class="token punctuation">;</span>        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="4-call-once"><a href="#4-call-once" class="headerlink" title="4. call_once()"></a>4. call_once()</h2><blockquote><p>  函数模板，该函数的第一个参数为标记，第二个参数是一个函数名（如a()）。<br>  <strong>功能：能够保证函数a()只被调用一次。具备互斥量的能力，而且比互斥量消耗的资源更少，更高效。</strong><br>  <code>call_once()</code>需要与一个标记结合使用，这个标记为<code>std::once_flag</code>；其实<code>once_flag</code>是一个结构，<code>call_once()</code>就是通过标记来决定函数是否执行，调用成功后，就把标记设置为一种已调用状态。</p><p>  多个线程同时执行时，一个线程会等待另一个线程先执行。</p></blockquote><p>实现:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">static</span> once_flag m_flag<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 系统定义的标记</span><span class="token keyword">class</span> <span class="token class-name">MyCAS</span>  <span class="token comment" spellcheck="true">// 单例类</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        my_intstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">MyCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> Recycle recycle<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"creatInstance()只执行了一次"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token function">MyCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 私有化构造函数</span>    <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> MyCAS <span class="token operator">*</span>my_intstance<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">static</span> MyCAS <span class="token operator">*</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">call_once</span><span class="token punctuation">(</span>m_flag<span class="token punctuation">,</span> createInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call_once执行完毕"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">return</span> my_intstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"for Test."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Recycle</span>    <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token operator">~</span><span class="token function">Recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>MyCAS<span class="token operator">::</span>my_intstance <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">delete</span> MyCAS<span class="token operator">::</span>my_intstance<span class="token punctuation">;</span>                MyCAS<span class="token operator">::</span>my_intstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化静态成员变量</span>MyCAS <span class="token operator">*</span>MyCAS<span class="token operator">::</span>my_intstance <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">myThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程 "</span> <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 开始执行"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    MyCAS <span class="token operator">*</span>p_A<span class="token operator">=</span> MyCAS<span class="token operator">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p_A<span class="token operator">-</span><span class="token operator">></span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    thread <span class="token function">ts1</span><span class="token punctuation">(</span>myThread<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread <span class="token function">ts2</span><span class="token punctuation">(</span>myThread<span class="token punctuation">)</span><span class="token punctuation">;</span>    ts1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ts2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式概谈&quot;&gt;&lt;a href=&quot;#设计模式概谈&quot; class=&quot;headerlink&quot; title=&quot;设计模式概谈&quot;&gt;&lt;/a&gt;设计模式概谈&lt;/h1&gt;&lt;h2 id=&quot;1-设计模式&quot;&gt;&lt;a href=&quot;#1-设计模式&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="语言学习" scheme="https://roranrui.cn/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="C++" scheme="https://roranrui.cn/tags/C/"/>
    
    <category term="设计模式" scheme="https://roranrui.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Shell入门</title>
    <link href="https://roranrui.cn/2022/04/26/shell-ru-men/"/>
    <id>https://roranrui.cn/2022/04/26/shell-ru-men/</id>
    <published>2022-04-26T12:35:20.000Z</published>
    <updated>2022-04-26T12:36:30.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell基础"><a href="#Shell基础" class="headerlink" title="Shell基础"></a>Shell基础</h1><h1 id="一、关于shell"><a href="#一、关于shell" class="headerlink" title="一、关于shell"></a>一、关于shell</h1><h2 id="1、什么是shell"><a href="#1、什么是shell" class="headerlink" title="1、什么是shell"></a>1、什么是shell</h2><p><strong>什么是shell？</strong></p><p>Shell（外壳） 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。<strong>Shell</strong> <strong>既是一种命令语言</strong>，<strong>又是一种程序设计语言</strong>。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p><strong>什么是脚本？</strong></p><p>脚本简单地说就是一条条的文字命令，这些文字命令是可以看到的（如可以用记事本打开查看、编辑）。</p><p>常见的脚本： <strong>JavaScript（JS，前端）</strong>，VBScript， <strong>ASP，JSP，PHP（后端）</strong>，SQL（数据库操作语言），Perl，<strong>Shell</strong>，python，Ruby，JavaFX，Lua等。</p><p><strong>为什么要学习和使用shell？</strong></p><p>Shell属于内置的脚本</p><p>程序开发的效率非常高，依赖于功能强大的命令可以迅速地完成开发任务（批处理）</p><p>语法简单，代码写起来比较轻松，简单易学</p><p><strong>常见的shell种类？</strong></p><p>在linux中有很多类型的shell，不同的shell具备不同的功能，shell还决定了脚本中函数的语法，Linux中默认的shell是**/bin/bash（重点）**，流行的shell有ash、bash、ksh、csh、zsh等，不同的shell都有自己的特点以及用途。</p><p>csh</p><p>C shell 使用的是“类C”语法,csh是具有C语言风格的一种shell，其内部命令有52个，较为庞大。目前使用的并不多，已经被/bin/tcsh所取代。</p><p>ksh</p><p>Korn shell 的语法与 Bourne shell 相同，同时具备了 C shell 的易用特点。许多安装脚本都使用 ksh ，ksh有42条内部命令，与bash相比有一定的限制性。</p><p>tcsh</p><p>tcsh是csh的增强版，与 C shell 完全兼容。</p><p>sh </p><p>是一个快捷方式，已经被/bin/bash所取代。</p><p>nologin</p><p>指用户不能登录</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image1.png" alt="img"></p><p>zsh</p><p>目前Linux里最庞大的一种shell：zsh。它有84个内部命令，使用起来也比较复杂。一般情况下，不会使用该shell。</p><p><strong>bash</strong></p><p><strong>大多数Linux系统默认使用的shell</strong>，bash shell 是 Bourne shell 的一个免费版本，它是最早的 Unix shell，bash还有一个特点，可以通过help命令来查看帮助。包含的功能几乎可以涵盖shell所具有的功能，所以一般的shell脚本都会指定它为执行路径。</p><h2 id="2、shell入门"><a href="#2、shell入门" class="headerlink" title="2、shell入门"></a>2、shell入门</h2><p>编写规范：</p><p>代码规范：</p><p>​    #!/bin/bash            [指定告知系统当前这个脚本要使用的shell解释器]</p><p>​    Shell相关指令</p><p>文件命名规范：</p><p>​    文件名.sh              .sh是linux下bash shell 的默认后缀</p><p>使用流程：</p><p>①创建.sh文件          touch/vim</p><p>②编写shell代码</p><p>③执行shell脚本        脚本必须得有执行权限</p><p>案例1：创建test.sh，实现第一个shell脚本程序，输出hello world.</p><p>输出命令：#echo 123</p><p>注意：输出的内容如果包含字母和符号（不包含变量），则需要用引号包括起来。如果是纯数字可以包也可以不包。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image2.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image4.jpg" alt="img"></p><p>注意，这里在运行时一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，Linux 系统会去 PATH（环境变量） 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p><p>案例2：使用root用户帐号创建并执行test2.sh，实现创建一个shelltest用户，并在其家目录中新建文件try.html。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image5.png" alt="img"></p><p>脚本执行的另外一个方式：/bin/bash 脚本的路径（了解）</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image6.png" alt="img"></p><p>Shell脚本分为简单的写法（简单命令的堆积）和复杂写法（程序的设计）</p><h1 id="二、shell进阶（重点）"><a href="#二、shell进阶（重点）" class="headerlink" title="二、shell进阶（重点）"></a>二、shell进阶（重点）</h1><h2 id="1、变量（重点）"><a href="#1、变量（重点）" class="headerlink" title="1、变量（重点）"></a>1、变量（重点）</h2><h3 id="1-1、变量的含义"><a href="#1-1、变量的含义" class="headerlink" title="1.1、变量的含义"></a>1.1、变量的含义</h3><p>a. 什么是量</p><p>量就是数据.</p><p>b. 什么是变量</p><p>数据可以发生改变就是变量.</p><p><strong>在一个脚本周期内,其值可以发生改变的量就是变量.</strong></p><p>c. 什么叫做一个脚本周期</p><p>一个脚本周期我们可以简单的理解为当前的shell文件</p><p>变量是shell中不可或缺的一部分，也是<strong>最基础、最重要</strong>的组成部分。</p><h3 id="1-2、变量的定义与使用（重点）"><a href="#1-2、变量的定义与使用（重点）" class="headerlink" title="1.2、变量的定义与使用（重点）"></a>1.2、变量的定义与使用（重点）</h3><p>变量，先定义后使用。</p><p><strong>定义形如：class_name=”yunwe “</strong></p><p><strong>使用形如：echo $class_name</strong></p><p>变量就是由2部分组成,一个是变量名（左边），另外一部分是变量的值（右边）</p><p>变量名和变量值是什么关系??</p><p>变量名和变量值是<strong>使用和被使用</strong>关系; 我们的变量名来使用变量值;</p><p>在使用变量的时候一定需要在变量名前面添加一个$符号，该要求在其他语言中也存在的（例如php）。</p><p>变量名的规范</p><p>注意，变量名后面的等号左右不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p><p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</p><p>中间不能有空格，可以使用下划线“_”。</p><p>不能使用标点符号。</p><p>不能使用bash里的关键字（可用help命令查看保留关键字）。</p><pre><code>问题：以下哪个shell变量名是合法的？A. var       B.?var       C. user*name       D.echo</code></pre><p>案例1：使用变量改写入门脚本中的第1个shell脚本。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image7.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image8.png" alt="img"></p><p><strong>关于单双引号的问题：</strong></p><p><strong>双引号能够识别变量，双引号能够实现转义（类似于“*”）</strong></p><p><strong>单引号是不能识别变量，只会原样输出，单引号是不能转义的</strong></p><p>案例2：定义一个变量，输出当前时间，要求格式为“年-月-日 时:分:秒”。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image9.png" alt="img"></p><p><strong>注意：反引号（esc键下方的那个键），当在脚本中需要执行一些指令并且将执行的结果赋给变量的时候需要使用“反引号”。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image10.png" alt="img"></p><h3 id="1-3、只读变量（了解）"><a href="#1-3、只读变量（了解）" class="headerlink" title="1.3、只读变量（了解）"></a>1.3、只读变量（了解）</h3><p>语法：readonly 变量名</p><p>案例：定义变量a并且其值为10，随后设置其为只读变量，再去尝试重新赋值</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image11.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image12.png" alt="img"></p><h3 id="1-4、接收用户输入（重点）"><a href="#1-4、接收用户输入（重点）" class="headerlink" title="1.4、接收用户输入（重点）"></a>1.4、接收用户输入（重点）</h3><p><strong>语法：read -p</strong> <strong>提示信息</strong>  <strong>变量名</strong></p><p>案例：编写一个脚本test6.sh，要求执行之后提示用户输入文件的名称（路径），然后自动为用户创建该文件</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image14.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image16.jpg" alt="img"></p><h3 id="1-5、删除变量（了解）"><a href="#1-5、删除变量（了解）" class="headerlink" title="1.5、删除变量（了解）"></a>1.5、删除变量（了解）</h3><p>语法：unset 变量名</p><p>案例：定义变量b=20，再输出b的值，随后删除b，最后再输出下b</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image17.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image18.png" alt="img"></p><h2 id="2、条件判断语句"><a href="#2、条件判断语句" class="headerlink" title="2、条件判断语句"></a>2、条件判断语句</h2><p>老婆给当程序员的老公打电话：<strong>下班顺路买一斤包子带回来，如果看到卖西瓜的，买一个</strong>。当晚，程序员老公手捧一个包子进了家门…老婆怒道：你怎么就买了一个包子？！老公答曰：因为看到了卖西瓜的。</p><p>把程序员老婆的话当作一段需求分析一下吧。买一斤包子是一个确定无疑的需求项，无论后面是什么情况什么条件，前面这一斤包子是肯定要买的。看到卖西瓜的是一个条件判断，后面“买一个”是一个模糊不清的需求项，买一个什么呢？需求里没说啊。客户把这个当作开发人员默认了解的内容了。可是作为一个成熟合格的程序员，该老婆的丈夫应该马上跟进确认需求“买一个什么？”，要不然程序可怎么写呢？所以笑话里该程序员是不合格的，起码是不积极不负责的。在没有明确需求的情况下，他只能按照自己的理解来完成工作了。那比较可能的结果就有如下几种：</p><p>1 看到卖西瓜的，买一个西瓜</p><p>​    <strong>如果</strong> <strong>看到卖西瓜的</strong></p><p>​         <strong>那么</strong></p><p>​         <strong>买一个西瓜</strong></p><p>​    <strong>否则</strong></p><p>​        <strong>买一斤包子</strong></p><p>2 看到卖西瓜的，买一个包子</p><p>​    <strong>如果</strong> <strong>看到卖西瓜的</strong></p><p>​         <strong>那么</strong></p><p>​         <strong>买一个包子</strong></p><p>3 看到卖西瓜的，买一个卖西瓜的</p><p>4 看到卖西瓜的，买一个老婆一直想买的东西</p><p>5 看到卖西瓜的，随便买一个东西</p><p><strong>上述1和2下面的条件汉字描述称之为“伪代码”，也是属于条件表达式的语法。</strong></p><p>语法1（一个条件）：</p><p><strong>if condition</strong></p><p><strong>then</strong></p><p>  <strong>command1</strong> </p><p>  <strong>command2</strong></p><p>  <strong>…</strong></p><p><strong>fi</strong></p><p>单行写法（一般在命令行中执行的时候）：if [ condition ]; then command; fi</p><p>语法2（两个条件）：</p><p><strong>if condition</strong></p><p><strong>then</strong></p><p>  <strong>command1</strong> </p><p>  <strong>command2</strong></p><p>  <strong>…</strong></p><p><strong>else</strong></p><p>  <strong>command</strong></p><p><strong>fi</strong></p><p>语法3（多个条件）：</p><p><strong>if condition1</strong></p><p><strong>then</strong></p><p>  <strong>command1</strong></p><p><strong>elif condition2</strong> </p><p><strong>then</strong></p><p>  <strong>command2</strong></p><p><strong>else</strong></p><p>  <strong>commandN</strong></p><p><strong>fi</strong></p><h2 id="3、运算符"><a href="#3、运算符" class="headerlink" title="3、运算符"></a>3、运算符</h2><p>在shell中，运算符和其他编程脚本语言一样，常见的有算数运算符、关系运算符、</p><p>逻辑运算符、字符串运算符、<strong>文件测试运算符</strong>等</p><h3 id="3-1、算数运算符"><a href="#3-1、算数运算符" class="headerlink" title="3.1、算数运算符"></a>3.1、算数运算符</h3><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>+</td><td>加法</td><td><code>expr  $a + $b</code> 结果为 30。</td></tr><tr><td>-</td><td>减法</td><td><code>expr  $a - $b</code> 结果为 -10。</td></tr><tr><td>*</td><td>乘法</td><td><code>expr  $a \* $b</code> 结果为  200。</td></tr><tr><td>/</td><td>除法</td><td><code>expr  $b / $a</code> 结果为 2。</td></tr><tr><td>%</td><td>取余</td><td><code>expr  $b % $a</code> 结果为 0。</td></tr><tr><td>=</td><td>赋值</td><td>a=$b 将把变量 b 的值赋给 a。</td></tr><tr><td>==</td><td>相等。用于比较两个数字，相同则返回 true（真）。</td><td>[ $a  == $b ] 返回 false（假）。</td></tr><tr><td>!=</td><td>不相等。用于比较两个数字，不相同则返回 true。</td><td>[ $a  != $b ] 返回 true。</td></tr></tbody></table><p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <strong>[$a==$b]</strong> 是错误的，必须写成 **[ $a == $b ]**。</p><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><p>例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ‘)：</p><p>#!/bin/bash</p><p>val=<code>expr 2 + 2</code></p><p>echo “两数之和为 : $val”</p><p>两点注意：</p><p>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</p><p>完整的表达式要被 <code> </code> 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image19.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image20.png" alt="img"></p><h3 id="3-2、关系运算符"><a href="#3-2、关系运算符" class="headerlink" title="3.2、关系运算符"></a>3.2、关系运算符</h3><p><strong>关系运算符只支持数字，不支持字符串，除非字符串的值是数字</strong>。</p><p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>-eq</td><td>检测<strong>两个数是否相等</strong>，相等返回 true。</td><td>[ $a  -eq $b ] 返回 false。</td></tr><tr><td>-ne</td><td>检测<strong>两个数是否相等</strong>，不相等返回 true。</td><td>[ $a  -ne $b ] 返回 true。</td></tr><tr><td>-gt</td><td>检测左边的数<strong>是否大于</strong>右边的，如果是，则返回 true。</td><td>[ $a  -gt $b ] 返回 false。</td></tr><tr><td>-lt</td><td>检测左边的数<strong>是否小于</strong>右边的，如果是，则返回 true。</td><td>[ $a  -lt $b ] 返回 true。</td></tr><tr><td>-ge</td><td>检测左边的数<strong>是否大于等于</strong>右边的，如果是，则返回 true。</td><td>[ $a  -ge $b ] 返回 false。</td></tr><tr><td>-le</td><td>检测左边的数<strong>是否小于等于</strong>右边的，如果是，则返回 true。</td><td>[ $a  -le $b ] 返回 true。</td></tr></tbody></table><p>-eq：equal</p><p>-ne：not equal</p><p>-gt：great than</p><p>-lt：less than</p><p>-ge：great than or equal</p><p>-le：less than or equal</p><p>案例：使用a=10，b=20来实现本案例</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image21.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image22.png" alt="img"></p><p><strong>课堂作业：</strong></p><p>写一个脚本，判断当前输入的用户是否存在。如果存在则提示“用户存在”否则提示“用户不存在”。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image24.jpg" alt="img"></p><h3 id="3-3、逻辑运算符"><a href="#3-3、逻辑运算符" class="headerlink" title="3.3、逻辑运算符"></a>3.3、逻辑运算符</h3><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>!</td><td>非运算，表达式为 true 则返回 false，否则返回 true。</td><td>[ !  false ] 返回 true。</td></tr><tr><td>-o</td><td>或（或者）运算，<strong>有一个表达式为</strong> <strong>true</strong> <strong>则返回</strong> <strong>true</strong>。</td><td>[ $a  -lt 20 -o $b -gt 100 ] 返回 true。</td></tr><tr><td>-a</td><td>与（并且）运算，<strong>两个表达式都为</strong> <strong>true</strong> 才返回 true。</td><td>[ $a  -lt 20 -a $b -gt 100 ] 返回 false。</td></tr></tbody></table><p><strong>或运算：一个为真即为真，全部为假才是假</strong></p><p><strong>与运算：一个为假即为假，全部为真才是真</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image25.png" alt="img"></p><h3 id="3-4、字符串运算符"><a href="#3-4、字符串运算符" class="headerlink" title="3.4、字符串运算符"></a>3.4、字符串运算符</h3><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>=</td><td>检测两个字符串是否相等，相等返回 true。</td><td>[ $a =  $b ] 返回 false。</td></tr><tr><td>!=</td><td>检测两个字符串是否相等，不相等返回 true。</td><td>[ $a  != $b ] 返回 true。</td></tr><tr><td>-z</td><td>检测字符串长度是否为0，为0返回 true。</td><td>[ -z  $a ] 返回 false。</td></tr><tr><td>-n</td><td>检测字符串长度是否为0，不为0返回 true。</td><td>[ -n  $a ] 返回 true。</td></tr><tr><td>str</td><td>检测字符串是否为空，不为空返回 true。</td><td>[ $a ]  返回 true。</td></tr></tbody></table><p>案例：将上述的语法验证下</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image26.png" alt="img"></p><h3 id="3-5、文件测试运算符（重点）"><a href="#3-5、文件测试运算符（重点）" class="headerlink" title="3.5、文件测试运算符（重点）"></a>3.5、文件测试运算符（重点）</h3><p>文件测试运算符用于检测 Unix/Linux 文件的各种属性。</p><p>属性检测描述如下：</p><table><thead><tr><th><strong>操作符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>-b  file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td><td>[ -b  $file ] 返回 false。</td></tr><tr><td>-c  file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td><td>[ -c  $file ] 返回 false。</td></tr><tr><td>-d  file</td><td><strong>检测文件是否是目录，如果是，则返回</strong> <strong>true。</strong></td><td>[ -d  $file ] 返回 false。</td></tr><tr><td>-f  file</td><td><strong>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回</strong> <strong>true。</strong></td><td>[ -f  $file ] 返回 true。</td></tr><tr><td>-g  file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td>[ -g  $file ] 返回 false。</td></tr><tr><td>-k  file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td>[ -k  $file ] 返回 false。</td></tr><tr><td>-p  file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td><td>[ -p  $file ] 返回 false。</td></tr><tr><td>-u  file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td>[ -u  $file ] 返回 false。</td></tr><tr><td>-r  file</td><td><strong>检测文件是否可读，如果是，则返回</strong> <strong>true。</strong></td><td>[ -r  $file ] 返回 true。</td></tr><tr><td>-w  file</td><td><strong>检测文件是否可写，如果是，则返回</strong> <strong>true。</strong></td><td>[ -w  $file ] 返回 true。</td></tr><tr><td>-x  file</td><td><strong>检测文件是否可执行，如果是，则返回</strong> <strong>true。</strong></td><td>[ -x  $file ] 返回 true。</td></tr><tr><td>-s  file</td><td><strong>检测文件是否为空（文件大小是否大于0），不为空返回</strong> <strong>true</strong>。</td><td>[ -s  $file ] 返回 true。</td></tr><tr><td>-e  file</td><td><strong>检测文件（包括目录）是否存在，如果是，则返回</strong> <strong>true。</strong></td><td>[ -e  $file ] 返回 true。</td></tr></tbody></table><p>案例：测试上述标绿色的效果</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image27.png" alt="img"></p><p>注意：权限几个判断，如果只有一个部分符合，则认为是有权限的。</p><h2 id="4、shell脚本附带选项（重点）"><a href="#4、shell脚本附带选项（重点）" class="headerlink" title="4、shell脚本附带选项（重点）"></a>4、shell脚本附带选项（重点）</h2><p>问题描述：在linux shell中如何处理tail -10 access.log这样的命令行选项？</p><p>步骤：</p><p>​    调用tail指令</p><p>​    <strong>系统把后续选项传递给tail</strong></p><p>​    Tail先去打开指定的文件</p><p>​    取出最后10行</p><p>问题：自己写的shell是否也可以像内置命令一样传递一些选项呢？</p><p>答：可以的，传递方式与上述的描述是一样的，关键是怎么接收。例如：</p><p>传递：</p><p>#./test.sh a b c</p><p>接收：</p><p>在脚本中可以用“$1”来表示a，“$2”来表示b，以此类推。</p><p><strong>接收可以用“$”加上选项对应的序号即可。</strong></p><p>测试：编写test14.sh，传递a，b，c，输出其值</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image28.png" alt="img"></p><p>其实$1、$2是变量。</p><p>练习：创建自定义<strong>指令“user”</strong>，可以直接执行，要求该指令具备以下语法和功能：</p><p>​    a. #user -add 用户名           【添加用户】</p><p>​    b. #user -del 用户名            【删除用户及其家目录】</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image29.png" alt="img"></p><p>同时题目中要求是指令，所以可以再去添加个别名：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/blip_image30.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shell基础&quot;&gt;&lt;a href=&quot;#Shell基础&quot; class=&quot;headerlink&quot; title=&quot;Shell基础&quot;&gt;&lt;/a&gt;Shell基础&lt;/h1&gt;&lt;h1 id=&quot;一、关于shell&quot;&gt;&lt;a href=&quot;#一、关于shell&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Shell脚本" scheme="https://roranrui.cn/categories/Shell%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="shell" scheme="https://roranrui.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>七.Linux网络基础</title>
    <link href="https://roranrui.cn/2022/04/26/qi-linux-wang-luo-ji-chu/"/>
    <id>https://roranrui.cn/2022/04/26/qi-linux-wang-luo-ji-chu/</id>
    <published>2022-04-26T12:34:05.000Z</published>
    <updated>2022-05-01T03:49:35.579Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux的网络基础"><a href="#Linux的网络基础" class="headerlink" title="Linux的网络基础"></a>Linux的网络基础</h1><h1 id="一、网络相关概述"><a href="#一、网络相关概述" class="headerlink" title="一、网络相关概述"></a>一、网络相关概述</h1><h2 id="1、网络发展"><a href="#1、网络发展" class="headerlink" title="1、网络发展"></a>1、网络发展</h2><p><strong>信息传递</strong></p><p>n 远古时期，人们就通过简单的语言、壁画等方式交换信息</p><p>n 千百年来，人们一直在用语言、图符、钟鼓、烟火、竹简、纸书等传递信息</p><p>n 古代人的烽火狼烟、飞鸽传信、驿马邮递</p><p>n 现代社会中，交通警的指挥手语、航海中的旗语等</p><p>n 这些信息传递的基本方式都是依靠人的视觉与听觉</p><p><strong>电的产生</strong></p><p>n 1831年，法拉第制出了世界上最早的第一台发电机</p><p>n 1866年，德国人西门子（Siemens）制成世界上第一台大功率发电机</p><p>n 1837年，美国人塞缪乐·莫乐斯成功地研制出世界上第一台电磁式电报机</p><p>n 1844年5月24日，莫乐斯在国会大厦联邦最高法院会议厅进行了“用莫尔斯电码”发出了人类历史上的第一份电报，从而实现了长途电报通信</p><p><strong>网络诞生</strong></p><p>n 1957年，前苏联发射了第一颗人造卫星，震惊了美国</p><p>n 1958年美国成立了国防部<strong>高级研究计划署</strong>（ARPA，Advanced Research Projects Agency），应对冷战形势，ARPA是一个管理机构，没有实验室和科学家</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image2.png" alt="http://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Arpanet_1974.svg/800px-Arpanet_1974.svg.png"></p><p>n 1969年，ARPANET（阿帕网）开始联机，<strong>因此1969年被称为Internet元年</strong></p><p><strong>网络分类（记忆）</strong></p><p>n <strong>局域网</strong>（Local Area Network，<strong>LAN</strong>）是指范围在几百米到十几公里内办公楼群或校园内的计算机相互连接所构成的计算机网络。</p><p>n 城域网（Metropolitan Area Network，MAN）所采用的技术基本上与局域网相类似，只是规模上要大一些。城域网既可以覆盖相距不远的几栋办公楼，也可以覆盖一个城。</p><p>n <strong>广域网</strong>（Wide Area Network，<strong>WAN</strong>）通常跨接很大的物理范围，如一个国家。</p><p>除了上述的划分，<strong>网络还可以按照所有者分</strong>为公网、私网是两种Internet的接入方式。公网接入方式：上网的计算机得到的IP地址是Internet上的非保留地址，公网的计算机和Internet上的其他计算机可随意互相访问。私网则反之。</p><h2 id="2、ip地址（重点记忆）"><a href="#2、ip地址（重点记忆）" class="headerlink" title="2、ip地址（重点记忆）"></a>2、ip地址（重点记忆）</h2><p>IP是英文Internet Protocol的缩写，意思是“网络之间互连的协议”，也就是为计算机网络相互连接进行通信而设计的<strong>协议</strong>。</p><p><strong>IP地址类型分为：公有地址、私有地址。</strong></p><p>公有地址</p><p>公有地址（Public address）由Inter NIC（Internet Network Information Center因特网信息中心）负责。这些IP地址分配给注册并向Inter NIC提出申请的组织机构。通过它直接访问因特网。</p><p><strong>私有地址（重点）</strong></p><p>私有地址（Private address）属于<strong>非注册地址</strong>，专门为组织机构内部使用。以下列出留用的内部私有地址：</p><p>A类 10.0.0.0–10.255.255.255</p><p>B类 172.16.0.0–172.31.255.255</p><p><strong>C类 192.168.0.0–192.168.255.255</strong></p><p><strong>IP地址按类型可以分为三类：</strong></p><table><thead><tr><th>类别</th><th>最大网络数</th><th>IP地址范围</th><th>最大主机数</th><th>私有IP地址范围</th></tr></thead><tbody><tr><td>A</td><td>126（2^7-2)</td><td>1.0.0.0-127.255.255.255</td><td>16777214</td><td>10.0.0.0-10.255.255.255</td></tr><tr><td>B</td><td>16384(2^14)</td><td>128.0.0.0-191.255.255.255</td><td>65534</td><td>172.16.0.0-172.31.255.255</td></tr><tr><td>C</td><td>2097152(2^21)</td><td>192.0.0.0-223.255.255.255</td><td>254</td><td>192.168.0.0-192.168.255.255</td></tr></tbody></table><p>网络运维相关技能：ip分类、<strong>子网划分</strong>、划分vlan、ACL、综合布线、各种Serve的搭建。</p><p>127.0.0.1         本机ip</p><h2 id="3、网卡"><a href="#3、网卡" class="headerlink" title="3、网卡"></a>3、网卡</h2><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image004.jpg" alt="img"></p><p>网卡是一个网络组件，属于硬件范畴，主要负责计算机之间数据的<strong>封装和解封</strong>。</p><p>MAC地址：网卡的物理地址，网卡设备的编号，<strong>默认</strong>情况是全球唯一的（16进制）。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image5.png" alt="img"></p><p><strong>与IP地址的区别：</strong></p><p>n 长度不同。IP地址为32位，MAC地址为48位。</p><p>n 分配依据不同。</p><p>n <strong>网络寻址方式不同</strong>。OSI参考模型，ip地址是基于第三层工作（网络层），mac地址是第二层（数据链路层）</p><h2 id="4、网线"><a href="#4、网线" class="headerlink" title="4、网线"></a>4、网线</h2><p>网线是连接局域网必不可少的。在局域网中常见的网线主要有双绞线（RJ45接口）、铜轴电缆、光缆三种。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image7.jpg" alt="img"><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image9.jpg" alt="img"><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image11.jpg" alt="img"></p><p>​         双绞线                       铜轴电缆                  光纤</p><h2 id="5、交换机"><a href="#5、交换机" class="headerlink" title="5、交换机"></a>5、交换机</h2><p>交换机（Switch）意为“开关”，是一种用于电（光）信号转发的网络设备，交换机它可以为接入交换机的任意两个网络节点提供<strong>独享</strong>的电信号通路。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image13.jpg" alt="img"></p><p>目前，交换机品牌比较有名的是：华为、华三（h3c）、思科、锐捷。</p><h2 id="6、路由器"><a href="#6、路由器" class="headerlink" title="6、路由器"></a>6、路由器</h2><p>路由器（Router）又称网关设备（Gateway）是用于<strong>连接多个逻辑上分开、相对独立的网络</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image15.jpg" alt="img">       <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image17.jpg" alt="img"></p><h2 id="7、拓扑结构图（扩展）"><a href="#7、拓扑结构图（扩展）" class="headerlink" title="7、拓扑结构图（扩展）"></a>7、拓扑结构图（扩展）</h2><p>所谓“拓扑”就是把实体抽象成与其大小、形状无关的“点”，而把连接实体的线路抽象成“线”，进而以图的形式来表示这些点与线之间关系的方法，<strong>其目的在于研究这些点、线之间的相连关系</strong>。表示点和线之间关系的图被称为拓扑结构图。</p><p>常见的几种拓扑结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image019.jpg" alt="img">  <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image21.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image23.jpg" alt="img">          <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image25.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image27.jpg" alt="img">         <img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image29.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image31.jpg" alt="img"></p><h1 id="二、网络相关命令"><a href="#二、网络相关命令" class="headerlink" title="二、网络相关命令"></a>二、网络相关命令</h1><h2 id="1、ping"><a href="#1、ping" class="headerlink" title="1、ping"></a>1、ping</h2><p><strong>作用：检测当前主机与目标主机之间的连通性</strong>（不是100%准确，有的服务器是禁ping）</p><p>语法：#ping 主机地址（ip地址、主机名、域名等）</p><p>例如：测试和baidu.com之间的连通性。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image33.jpg" alt="img"></p><p>该命令可以跨平台，windows下也可以使用，语法一致。（区别在于Linux下默认一直发送，windows下默认发送4个数据包）</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image35.jpg" alt="img"></p><h2 id="2、netstat"><a href="#2、netstat" class="headerlink" title="2、netstat"></a>2、netstat</h2><p><strong>作用：表示查看网络的连接信息</strong></p><p>语法：#netstat -tnlp      （-t：tcp协议，-n：将字母转化成数字，-l：列出状态为监听，-p：显示进程相关信息）</p><p>​     #netstat -an       （-a：表示全部，-n：将字母转化为数字）</p><p>TCP/IP协议需要使用这个命令。</p><h2 id="3、traceroute"><a href="#3、traceroute" class="headerlink" title="3、traceroute"></a>3、traceroute</h2><p><strong>作用：查找当前主机与目标主机之间所有的网关</strong>（路由器，会给沿途各个路由器发送icmp数据包，路由器可能会不给响应）。</p><p>该命令不是内置命令，需要安装，但是目前的已经安装好了（之前选了开发工具）。</p><p>语法：#traceroute 主机地址</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image37.jpg" alt="img"></p><p>类似于查看快递的跟踪路由：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image39.jpg" alt="img"></p><p>扩展：在windows下也有类似的命令：tracert 主机地址</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image41.jpg" alt="img"></p><p>在线工具网址：<a href="http://tool.chinaz.com/">http://tool.chinaz.com</a></p><h2 id="4、arp"><a href="#4、arp" class="headerlink" title="4、arp"></a>4、arp</h2><p>地址解析协议，即ARP（Address Resolution Protocol），是<strong>根据IP地址获取（MAC）物理地址的协议</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image043.png" alt="img"></p><p><strong>当一个主机发送数据时，首先查看本机MAC地址缓存中有没有目标主机的MAC地址，</strong> <strong>如果有就使用缓存中的结果；如果没有，ARP协议就会发出一个广播包，该广播包要求查询目标主机IP地址对应的MAC地址，拥有该IP地址的主机会发出回应，回应中包括了目标主机的MAC地址，这样发送方就得到了目标主机的MAC地址。如果目标主机不在本地子网中，则ARP解析到的MAC地址是默认网关的MAC地址</strong>。</p><p>常用语法：#arp -a     查看本地缓存mac表</p><p>​          #arp -d 主机地址            删除指定的缓存记录</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image45.jpg" alt="img"></p><p>该命令在windows下同样适用。</p><h2 id="5、tcpdump-了解"><a href="#5、tcpdump-了解" class="headerlink" title="5、tcpdump(了解)"></a>5、tcpdump(了解)</h2><p>作用：抓包，抓取数据表</p><p>常用语法：</p><p>​    #tcpdump 协议 port 端口</p><p>​    #tcpdump 协议 port 端口 host 地址</p><p>​    #tcpdump -i 网卡设备名</p><p>查看22端口（ssh）的数据包：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/cclip_image47.jpg" alt="img"></p><p>00:09:17.xxxx         监听数据的时分秒</p><p>IP：使用的协议类型</p><p>192.168.21.1          数据包的一个方向（来自）</p><p>&gt;                    数据的流向</p><p>192.168.21.136        数据包的另外一个方向（到达）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux的网络基础&quot;&gt;&lt;a href=&quot;#Linux的网络基础&quot; class=&quot;headerlink&quot; title=&quot;Linux的网络基础&quot;&gt;&lt;/a&gt;Linux的网络基础&lt;/h1&gt;&lt;h1 id=&quot;一、网络相关概述&quot;&gt;&lt;a href=&quot;#一、网络相关概述&quot; cla</summary>
      
    
    
    
    <category term="操作系统学习" scheme="https://roranrui.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="操作系统" scheme="https://roranrui.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>六.Linux权限管理操作</title>
    <link href="https://roranrui.cn/2022/04/26/liu.linux-quan-xian-guan-li-cao-zuo/"/>
    <id>https://roranrui.cn/2022/04/26/liu.linux-quan-xian-guan-li-cao-zuo/</id>
    <published>2022-04-26T07:37:28.000Z</published>
    <updated>2022-04-26T07:38:06.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux的权限管理操作"><a href="#Linux的权限管理操作" class="headerlink" title="Linux的权限管理操作"></a>Linux的权限管理操作</h1><p><strong>Linux的权限操作与用户、用户组是兄弟操作。</strong></p><h1 id="一、权限概述"><a href="#一、权限概述" class="headerlink" title="一、权限概述"></a>一、权限概述</h1><p>总述：Linux系统一般将文件可存/取访问的身份分为3个类别：owner、group、others，且3种身份各有read、write、execute等权限。</p><h2 id="1、权限介绍"><a href="#1、权限介绍" class="headerlink" title="1、权限介绍"></a>1、权限介绍</h2><p>什么是权限？</p><p>在多用户（可以不同时）计算机系统的管理中，权限是指某个特定的用户具有特定的系统资源使用权力，像是文件夹、特定系统指令的使用或存储量的限制。</p><p>在Linux中分别有读、写、执行权限：</p><p>读权限：</p><p>​    对于文件夹来说，读权限影响用户是否能够列出目录结构</p><p>​    对于文件来说，读权限影响用户是否可以查看文件内容</p><p>写权限：</p><p>​    对文件夹来说，写权限影响用户是否可以在文件夹下“创建/删除/复制到/移动到”文档</p><p>​    对于文件来说，写权限影响用户是否可以编辑文件内容</p><p>执行权限：</p><p>​    一般都是对于文件来说，特别脚本文件。</p><h2 id="2、身份介绍"><a href="#2、身份介绍" class="headerlink" title="2、身份介绍"></a>2、身份介绍</h2><h3 id="Owner身份（文件所有者，默认为文档的创建者）"><a href="#Owner身份（文件所有者，默认为文档的创建者）" class="headerlink" title="Owner身份（文件所有者，默认为文档的创建者）"></a>Owner身份（文件所有者，默认为文档的创建者）</h3><p>由于Linux是多用户、多任务的操作系统，因此可能常常有多人同时在某台主机上工作，但每个人均可在主机上设置文件的权限，让其成为个人的“私密文件”，即个人所有者。因为设置了适当的文件权限，除本人（文件所有者）之外的用户无法查看文件内容。</p><p>例如某个MM给你发了一封Email情书，你将情书转为文件之后存档在自己的主文件夹中。为了不让别人看到情书的内容，你就能利用所有者的身份去设置文件的适当权限，这样，即使你的情敌想偷看你的情书内容也是做不到的。</p><h3 id="Group身份（与文件所有者同组的用户）"><a href="#Group身份（与文件所有者同组的用户）" class="headerlink" title="Group身份（与文件所有者同组的用户）"></a>Group身份（与文件所有者同组的用户）</h3><p>与文件所有者同组最有用的功能就体现在<strong>多个团队在同一台主机上开发资源的时候</strong>。例如主机上有A、B两个团体，A中有a1,a2,a3三个成员，B中有b1,b2两个成员，这两个团体要共同完成一份报告F。由于设置了适当的权限，A、B团体中的成员都能互相修改对方的数据，但是团体C的成员则不能修改F的内容，甚至连查看的权限都没有。同时，团体的成员也能设置自己的私密文件，让团队的其它成员也读取不了文件数据。<strong>在Linux中，每个账户支持多个用户组。如用户a1、b1即可属于A用户组，也能属于B用户组【主组和附加组】</strong>。</p><h3 id="Others身份（其他人，相对于所有者）"><a href="#Others身份（其他人，相对于所有者）" class="headerlink" title="Others身份（其他人，相对于所有者）"></a>Others身份（其他人，相对于所有者）</h3><p>这个是个相对概念。打个比方，大明、二明、小明一家三兄弟住在一间房，房产证上的登记者是大明（owner所有者），那么，大明一家就是一个用户组，这个组有大明、二明、小明三个成员；另外有个人叫张三，和他们三没有关系，那么这个张三就是其他人了。</p><p>同时，大明、二明、小明有各自的房间，三者虽然能自由进出各自的房间，但是小明不能让大明看到自己的情书、日记等，这就是文件所有者（用户）的意义。</p><h3 id="Root用户（超级用户）"><a href="#Root用户（超级用户）" class="headerlink" title="Root用户（超级用户）"></a>Root用户（超级用户）</h3><p>在Linux中，还有一个神一样存在的用户，这就是root用户，因为在所有用户中它拥有最大的权限 ，所以管理着普通用户。</p><h2 id="3、Linux的权限介绍"><a href="#3、Linux的权限介绍" class="headerlink" title="3、Linux的权限介绍"></a>3、Linux的权限介绍</h2><p>要设置权限，就需要知道文件的一些基本属性和权限的分配规则。在Linux中，ls命令常用来查看文件的属性，用于显示文件的文件名和相关属性。</p><p>#ls -l 路径      【ls -l 等价于 ll】</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image2.jpg" alt="img"></p><p>标红的部分就是Linux的文档权限属性信息。</p><p><strong>Linux中存在用户、用户组和其他人概念</strong>，各自有不同的权限，对于一个文档来说，其权限具体分配如下：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image3.png" alt="img"></p><p>十位字符表示含义：</p><p>第1位：表示文档类型，取值常见的有“d表示文件夹”、“-表示文件”、“l表示软连接”、“s表示套接字”等等；</p><p>第2-4位：表示文档所有者的权限情况，第2位表示读权限的情况，取值有r、-；第3位表示写权限的情况，w表示可写，-表示不可写，第4位表示执行权限的情况，取值有x、-。</p><p>第5-7位：表示与所有者同在一个组的用户的权限情况，第5位表示读权限的情况，取值有r、-；第6位表示写权限的情况，w表示可写，-表示不可写，第7位表示执行权限的情况，取值有x、-。</p><p>第8-10位：表示除了上面的前2部分的用户之外的其他用户的权限情况，第8位表示读权限的情况，取值有r、-；第9位表示写权限的情况，w表示可写，-表示不可写，第10位表示执行权限的情况，取值有x、-。</p><p>权限分配中,均是rwx的三个参数组合，<strong>且位置顺序不会变化</strong>。没有对应权限就用 – 代替。</p><p><strong>例如：以下一个文档权限是怎么样的？</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image5.jpg" alt="img"></p><p>a. 其是文件夹类型</p><p>b. 所有者：拥有全部权限（读写执行）</p><p>c. 同组用户：可读、可执行</p><p>d. 其他用户：可读、可执行</p><h1 id="二、权限设置"><a href="#二、权限设置" class="headerlink" title="二、权限设置"></a>二、权限设置</h1><p><strong>语法：#chmod</strong> <strong>选项</strong> <strong>权限模式</strong> <strong>文档</strong></p><p>注意事项：</p><p>​    常用选项：</p><p>​             -R：递归设置权限 （当文档类型为文件夹的时候）</p><p>​    权限模式：就是该文档需要设置的权限信息</p><p>​    文档：可以是文件，也可以是文件夹，可以是相对路径也可以是绝对路径。</p><p><strong>注意点：如果想要给文档设置权限，操作者要么是root用户，要么就是文档的所有者。</strong></p><h2 id="1、字母形式"><a href="#1、字母形式" class="headerlink" title="1、字母形式"></a>1、字母形式</h2><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image7.jpg" alt="img"></p><p>给谁设置：</p><p>​    u：表示所有者身份owner（user）</p><p>​    g：表示给所有者同组用户设置（group）</p><p>​    o：表示others，给其他用户设置权限</p><p>​    a：表示all，给所有人（包含ugo部分）设置权限</p><p>​         <strong>如果在设置权限的时候不指定给谁设置，则默认给所有用户设置</strong></p><p>权限字符：</p><p>​    r：读</p><p>​    w：写</p><p>​    x：表示执行</p><p>​    -：表示没有权限</p><p>权限分配方式：</p><p>​    +：表示给具体的用户新增权限（相对当前）</p><p>​    -：表示删除用户的权限（相对当前）</p><p>​    =：表示将权限设置成具体的值（注重结果）【赋值】</p><p><strong>例如：需要给anaconda-ks.cfg文件（-rw——-.）设置权限，要求所有者拥有全部的权限，同组用户拥有读和执行权限，其他用户只读权限。</strong></p><p>答案：</p><p>①#chmod u+x,g+rx,o+r anaconda-ks.cfg</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image9.jpg" alt="img"></p><p>​    ②#chmod u=rwx,g=rx,o=r anaconda-ks.cfg</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image11.jpg" alt="img"></p><p><strong>提示：当文档拥有执行权限（任意部分），则其颜色在终端中是绿色。</strong></p><p>#chmod ug=rwx 形式，如果有两部分权限一样则可以合在一起写的</p><p><strong>例如：如果anaconda-ks.cfg文件什么权限都没有，可以使用root用户设置所有人都有执行权限，则可以写成</strong></p><p>​    ①#chmod +x anaconda-ks.cfg</p><p>​    ②#chmod a=x anaconda-ks.cfg</p><p>​    ③#chmod a+x anaconda-ks.cfg</p><h2 id="2、数字形式"><a href="#2、数字形式" class="headerlink" title="2、数字形式"></a>2、数字形式</h2><p>经常会在一些技术性的网页上看到类似于**#chmod 777 a.txt**  这样的一个权限，这种形式称之为数字形式权限（777）。</p><p><strong>读：r     4</strong></p><p><strong>写：w        2</strong></p><p><strong>执行：x      1</strong></p><p>没有任何权限：0</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image13.jpg" alt="img"></p><p>例如：需要给anaconda-ks.cfg设置权限，权限要求所有者拥有全部权限，同组用户拥有读执行权限，其他用户只读。</p><p><strong>全部权限（u）：读+写+执行=4+2+1=7</strong></p><p><strong>读和执行（g）：读+执行=4+1=5</strong></p><p><strong>读权限（o）：读=4</strong></p><p>由上得知权限为：754</p><p>#chmod 754 anaconda-ks.cfg</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image15.jpg" alt="img"></p><p><strong>面试题：用超级管理员设置文档的权限命令是#chmod -R 731 aaa，请问这个命令有没有什么不合理的地方？</strong></p><p>拥有者：7=4+2+1=读+写+执行</p><p>同组用户：3=2+1=写+执行</p><p>其他用户：1=1=执行</p><p>注意：<strong>在写权限的时候千万不要设置类似于上面的这种“奇葩权限”</strong>。如果一个权限数字中但凡出现2与3的数字，则该权限有不合理的情况。</p><h2 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h2><p>使用root用户创建一个文件夹（/oo），权限默认，权限如下：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image016.png" alt="img"></p><p>需要在oo目录下创建文件（oo/xx.txt），需要给777权限：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image18.jpg" alt="img"></p><p>切换到test用户（不是文档所有者，也不是同组用户，属于other部分）：</p><p>问题1：test用户是否可以打开oo/xx.txt文件？【能打开】</p><p>问题2：test用户是否可以编辑oo/xx.txt文件？【可以】</p><p>问题3：test用户是否可以删除oo/xx.txt文件？【不可以，同样还不允许创建文件/文件夹、移动文件、重命名文件】</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image20.jpg" alt="img"></p><p><strong>在Linux中，如果要删除一个文件，不是看文件有没有对应的权限，而是看文件所在的目录是否有写权限，如果有才可以删除</strong>。</p><h1 id="三、属主与属组设置"><a href="#三、属主与属组设置" class="headerlink" title="三、属主与属组设置"></a>三、属主与属组设置</h1><p>属主：所属的用户（文件的主人）</p><p>属组：所属的用户组</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image022.jpg" alt="img"></p><p>前面的那个root就是属主</p><p>后面的那个root就是属组</p><p>这两项信息在文档创建的时候会使用创建者的信息（用户名、用户所属的主组名称）。</p><p>如果有时候去删除某个用户，则该用户对应的文档的属主和属组信息就需要去修改。</p><h2 id="1、chown（重点）"><a href="#1、chown（重点）" class="headerlink" title="1、chown（重点）"></a>1、chown（重点）</h2><p><strong>作用：更改文档的所属用户</strong></p><p>语法：#chown -R username 文档路径</p><p>案例：将刚才root用户创建的oo目录，所有者更改为test</p><p>#chown test oo/</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image24.jpg" alt="img"></p><h2 id="2、chgrp（了解）"><a href="#2、chgrp（了解）" class="headerlink" title="2、chgrp（了解）"></a>2、chgrp（了解）</h2><p><strong>作用：更改文档的所属用户组</strong></p><p>语法：#chgrp -R groupname 文档的路径</p><p>案例：将刚才root用户创建的oo目录，所有者更改为test，并且将所属用户组也改为test</p><p>#chgrp test oo/</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image26.jpg" alt="img"></p><p><strong>思考，如何通过一个命令实现既可以更改所属的用户，也可以修改所属的用户组呢？</strong></p><p>答：可以实现的，通过chown命令</p><p>​    语法：#chown -R username:groupname  文档路径</p><p>案例：要求只使用chown指令，将oo目录的所属用户和用户组改回成root，并且包含其子目录</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image28.jpg" alt="img"></p><h1 id="四、扩展（1）"><a href="#四、扩展（1）" class="headerlink" title="四、扩展（1）"></a>四、扩展（1）</h1><p>问题：reboot、shutdown、init、halt、user管理，在普通用户身份上都是操作不了，但是有些特殊的情况下又需要有执行权限。又不可能让root用户把自己的密码告诉普通用户，这个问题该怎么解决？</p><p><strong>该问题是可以被解决的，可以使用sudo（switch user do）命令来进行权限设置。Sudo可以让管理员（root）事先定义某些特殊命令谁可以执行</strong>。</p><p>默认sudo中是没有除root之外用户的规则，要想使用则先<strong>配置</strong>sudo。</p><p><strong>Sudo配置文件：/etc/sudoers</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image29.png" alt="img"></p><p>a. 配置sudo文件请使用“#visudo”，打开之后其使用方法和vim一致</p><p>b. 配置普通用户的权限</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image030.png" alt="img"></p><p>Root表示用户名，如果是用户组，则可以写成“%组名”</p><p>ALL：表示允许登录的主机（地址白名单）</p><p>(ALL)：表示以谁的身份执行，ALL表示root身份</p><p>ALL：表示当前用户可以执行的命令，多个命令可以使用“,”分割</p><p><strong>案例：本身test用户不能添加用户，要求使用sudo配置，将其设置为可以添加用户，并且可以修改密码（但是不能修改root用户密码）。</strong></p><p>注意：在写sudo规则的时候不建议写直接形式的命令，而是写命令的完整路径。</p><p>路径可以使用which命令来查看</p><p>语法：#which 指令名称</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image31.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image32.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image034.jpg" alt="img"></p><p>在添加好对应的规则之后就可以切换用户，切换到普通用户test，再去执行：</p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image35.png" alt="img"></p><p>此时要想使用刚才的规则，则以以下命令进行：</p><p><strong>#sudo</strong> <strong>需要执行的指令</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image36.png" alt="img"></p><p><strong>在输入sudo指令之后需要输入当前的用户密码进行确认的操作（不是root用户密码），输入之后在接下来5分钟内再次执行sudo指令不需要密码</strong>。</p><p>特别注意：此处按照案例要求，不能让test用户修改root密码，因此规则还需要调整，不然其可以修改root密码的：</p><p><strong>禁止修改root密码的配置（先允许全部，再拒绝root密码设置）：</strong> /usr/bin/passwd [A-Za-z]*, <strong>!/usr/bin/passwd root</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/mlip_image38.jpg" alt="img"></p><p>补充：在普通用户下怎么查看自己具有哪些特殊权限呢？</p><p><strong>#sudo -l</strong></p><p><img src="https://cdn.jsdelivr.net/gh/roranrui/img_bed/img/clip_image040.jpg" alt="img"></p><p>最后：sudo不是任何Linux分支都有的命令，常见centos与ubuntu都存在sudo命令。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux的权限管理操作&quot;&gt;&lt;a href=&quot;#Linux的权限管理操作&quot; class=&quot;headerlink&quot; title=&quot;Linux的权限管理操作&quot;&gt;&lt;/a&gt;Linux的权限管理操作&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Linux的权限操作与用户、用户组是兄弟操作</summary>
      
    
    
    
    <category term="操作系统学习" scheme="https://roranrui.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux" scheme="https://roranrui.cn/tags/Linux/"/>
    
    <category term="操作系统" scheme="https://roranrui.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
